00000=Probable return stack overflow. Warmstart with WSLOG entry 3
00000:Set WSLOG 3
00002:Do warmstart
0000F=Interrupt routine
0000F=Return address is in RSTK
0000F:Set interrupt request
00012:Separate tests to preserve carry
00015:Interrupts allowed?
00018:Yes - continue
0001A:No - return with original CS
0001C:Save C.A
00021:Deviced not ok?
00026:Ok - continue with original CC
00029:Interrupts disabled?
0002C:Yes - return with original CS
0002E:Save C.A
00033:Devices ok?
00036:Yes - continue with original CS
0003E:C.A = D1
00041:Save D1.0 to SCRATCHPAD
0004C:Use C.0 to get RAM base nib to C.4
00062:D1 = ->INTRSAVE
00068:Restore original C.4
00070:Save C.W (with D1 in C.A)
00074:Mode = 0
00076:Get P to C.3
0007A:Get carry state to C.2
00082:Get DEC/HEX state to C.1
00089:Get SB state to C.0
00096:Save mode
0009E:Save C.A
000A4:Save A.W
000AB:Save ST
000B6:Save B.W
000C0:Save D.W
000CA:Save R0.W
000D3:Save RSTK1
000DC:Save D0
000DF:Do interrupt
00100=3 nibs for display offset (scrolling), DON=Display ON
00100=Display bit offset and DON [DON OFF2 OFF1 OFF0]
00101=Contrast Control [CON3 CON2 CON1 CON0]
00101=Higher value = darker screen
00102=Display test [VDIG LID TRIM CON4] [LRT LRTD LRTC BIN]
00102=Normally zeros
00104=16 bit hardware CRC (104-107) (X^16+X^12+X^5+1)
00104=crc = ( crc >> 4 ) ^ ( ( ( crc ^ nib ) & 0x000F )* 0x1081 );
00108=Low power registers (108-109)
00108=LowBat(2) LowBat(1) LowBat(S) VeryLowBat
00108=[LB2 LB1 LB0 VLBI] (read only)
00109=[ELBI EVLBI GRST RST] (read/write)
0010A=Mode Register (read-only)
0010B=Annunciator control [LA4 LA3 LA2 LA1] = [ alarm alpha -> <- ]
0010C=Annunciator control [AON XTRA LA6 LA5] = [ Anns_ON? XTRA io busy]
0010D=3 bits = {1200 1920 2400 3840 4800 7680 9600 15360}
0010D=Serial baud rate [UCK BD2 BD1 BD0] (bit 3 is read-only)
0010E=Enable Card Det., Run Card Det., Set Module Pulled, Software interrupt
0010E=[ECDT RCDT SMP SWINT] (read/write)
0010F=[P2W P1W P2C P1C] (read-only) Port 2 writable .. Port 1 inserted 
00110=Serial I/O Control [SON ETBE ERBF ERBZ]
00110=Serial On, Interrupt On Recv.Buf.Empty, Full, Buzy
00111=Serial Receive Control/Status [RX RER RBZ RBF] (bit 3 is read-only)
00112=Serial Transmit Control/Status [BRK LPB TBZ TBF]
00113=Serial Clear RER (writing anything clears RER bit)
00114=Serial Receive Buffer Register (Reading clears RBF bit)
00114=[RX RER RBZ RBF]
00116=Serial Transmit Buffer Register (Writing sets TBF bit)
00118=Service Request Register (read-only)
00118=[ISQR TSQR USRQ VSRQ] [KDN NINT2 NINT LSRQ]
0011A=IR Control Register [IRI EIRU EIRI IRE] (bit 3 is read-only)
0011A=IR Input, Enable IR UART mode, Enable IR Interrupt, IR Event
0011B=Used as addressto get BASENIB from 11F to the 5th nibble
0011C=Led Control Register [LED ELBE LBZ LBF] (Setting LED is draining)
0011D=Led Buffer Register [0 0 0 LBO] (bits 1-3 read zero)
0011E=Scratch pad (11F is BASEIB, 7 or F for base memory)
00120=Display Start Address (write only)
00120=bit 0 is ignored (display must start on byte boundary)
00125=Display Line offset (write only) (no of bytes skipped after each line)
00125=MSG sign extended
00128=Display Line Counter and miscellaneous (28-29)
00128=Line counter 6 bits -> max = 2^6-1 = 63 = disp height
00128=Normally has 55 -> Menu starts at display row 56
00128=[LC3 LC2 LC1 LC0] [DA19 M32 LC5 LC4]
0012E=TIMER1 Control [SRQ WKE INT XTRA]
0012F=TIMER2 Control [SRQ WKE INT RUN]
00130=Display Secondary Start Address (write only) (30-34)
00130=Menu Display Address, no line offsets
00137=Decremented 16 times/s
00138=hardware timer (38-3F), decremented 8192 times/s
00140=Main interrupt loop.
00140=Input:  Registers + state have been saved. 2 free RSTK levels
00140=	  D1.4 contains RAM base nibble
00140=Output: Resumes registers + state, continues execution
00140:Set interrupt was serviced
00140:Needed for liteslp awakening
0014E:RUN bit set?
00153:Yes - continue
00155:No - set WSLOG 4
0015B:Enable and run card detect
00166:[RCDT, ECDT]
0016D:Module not pulled?
00170:Ok - continue
00172:Wait for it
00176:Set WSLOG 11
00178:Do Warmstart
0017C:Enable very-low-bat detection
00180:[EVLBI]
00187:Test VLBI
0018F:Not very-low-bat?
00194:Ok - continue
00196:Go to coma
0019D:Set WSLOG 1
0019F:Do Warmstart
001A3:Test RAM magic constant
001AE:Magic constant
001B5:RAM ok?
001B8:Yes - continue
001BA:Set WSLOG 7
001C3:Service IO
001C7:Turn off LED interrupts
001D2:ELBE clear?
001D7:Yes - continue
001D9:Clear ELBE
001E2:Turn off IR interrupts
001EA:EIRI clear?
001F1:Clear EIRI
00200:C = saved card status
0020B:A = current card status
0020F:Cards ok?
00212:Yes - continue
00214:Set WSLOG B
00218:Service TIMER2
0021F:Service TIMER1
00223:Servive annunciatiors
00227:On key down?
0022D:No - continue
00230:Yes - check special keys
00236:Service keyboard (normal)
0023A:Fetch base to D1
00248:Restore B.W
00252:Restore D.W
0025C:Restore R0.W
00265:Restore RSTK1
0026D:Restore D0
0027A:Restore OUT
0027D:Update IN
0028C:Restore ST
00291:Restore A.W
0029B:Save C.A to RSTK
002A0:C.A = mode
002A3:Restore SB
002A8:Restore DEC/HEX
002B2:Restore carry
002B7:Restore P
002C1:Restore C.W (with D1 in C.A)
002CC:Restore D1.0
002D0:Restore D1
002D3:Restore C.A
002D5:Set interrupt services done
002DA=Run card detection until MP bit is cleared
002E3:Init module pulled bit
002E8:C.A = #100
002ED:Delay loop
002F0:[ECDT, RCDT]
002F3:Enable card detect + run
002F7:Return if ok
002FC:Wait again
002FF=Enter Coma mode
002FF:IO interrupts off
00313:Save old timer status
00319:Turn off timers?
0031E:Keep timers running
00325:Update annunciators
0032B:Keyboard interrupts off
0032F:LED off
00339:Enable card detect
0033D:[ECDT]
00344:Disable low-power detect
0034E:Display off, annunciators off
00358:Enable very-low-bat detect
0035C:[EVLBI]
0036A:Save current timer status
0036C:Run timers
00373:Wait for a while
0038A:Resume current timer status
00393:Display on, annunciators on
0039A:Wait loop
003A9:Still VLBI set?
003AE:Yes - back to sleep
003B0:Enable & run card detect
003B4:[ECDT, RCDT]
003BB:Restore old timer status
003C6=Service IO interrupts
003C8:IO control/status
003D3:SON clear?
003D8:Yes - serial is off
003DA:Clear [ETBE]
003E3:Clear SON bit
003E8:[ERBF, ERBZ] not enabled?
003EB:Yes - nothing to do
003ED:Receive control/status
003F5:Clear RX bit
003FA:[RER, RBZ, RBF] clear?
003FD:Not error, buzy or full. Done
003FF:Keyboard interrupts off
00403:Save [AON XTRA LA6 LA5]
00415:Set LA6 (IO busy)
0041E:RER or RBF set?
00424:Yep - serve them
00427:Now we have RBZ (busy)
0042B:So we have to wait for receive
0042D:to finish
00436:Fetch timer constant for BAU bits
00448:A.X = bautime
00457:C.A = target time
00462:Reached time?
00465:Yes - done
00467:RER or RBF set?
0046D:Yes - serve them
00470:Nope - continue wait
00473:Restore IO ann
00485:Enable keyboard interrupts
00489:Did nothing
0048B=Timing constants for BAU settings
004A3:RBF clear?
004A8:Yes - got nothing
004AA:Fetch received byte
004AE:Reading cleard RBF bit
004B1:B.B = byte
004C4:Clear RER
005EC=Service TIMER1
005EE:Calculations done in ticks
005FB:TIMER1 SRQ set?
00600:Yes - service
00602:Nothing to do
00604:Fetch RAM base to D1 and A.4
00608:Decrement blink counter
00615:Don't decrement 0
0061C:A.A = ->SYSNIB1
00625:Mask for BlinkOn?
0062A:A.A = ->SYSNIB5
00638:BlinkOn?
0063D:No - set new interrupt if
00643:any keys are down
0064F:Clear TIMER1 control
00655=Sets TIMER1 to interrupt on next tick
0065E:[WKE, INT]
00661:Causes interrupt when MSB is 1
00669:Init MSB to 0
00672=Checks battery, alarms and normal shift annunciators
00672:C.XS = cardstatus
00678:C.0 = cardstatus
0067A:Shift 2 bits to left
0067C:Now only P2C and P1C remain
0068C:Get RAM base to D1
00696:C.0 = warndata
006A2:Get status of alarm ann
006BD:No alarm ann
006BF:Set alarm ann
006C1:Update warndata
006CB:Update annsdata
006ED:Save C.A
006EF:Enable low-power detect
006F6:[ELBI, EVLBI]
00708:C.0 = [LB2 LB1 LB0 VLBI]
00721:Enable very-low-power detect
00725:[EVLBI]
00735=Run card detect. Resulting CARDSTATUS in C.XS
00739:Enable + run card detect
00740:[ECDT, RCDT]
00747:Now wait for 1 detect to complete
00752:A.0 = target time
0075C:Wait until target time
00762:C.2 = cardstatus
00768=Service keyboard interrupt (normal)
00768=Scans keys & sets KEYSTATE & KEYBUFFER accordingly
00768:Get RAM base to D1
00776:Keyboard enabled?
00779:Yes - service
0077B:No - return carry clear
0077F:A.W = keyscan
00783:Save to B.W
00786:Keys were pressed?
00789:Yes - service
0078B:No - check old keystate
00798:Keys were pressed?
0079B:Yes - service them
0079D:Interrupt immediately after RTI
007A2:if keys are pressed
007A6:Scan stable key pressed
007AA:No ON key?
007AF:Yep - normal service
007B1:Setting new interrupt immediately
007B5=Services key in B.W
007B5:Get RAM base to D1
007B9:Max allowed keys
007BC:No keys?
007C1:Check that max C.P keys are down
007D2:Decrement keys down
007D8:Too many keys down - new interrupt
007DC:C.S = shift state
007E0:D.S = shift state
007EC:C.13 = old keystate
007F0:Set new keystate
007F4:Keys are pressed?
007F9:No - exit via RSI
007FD:Different keys down?
00802:No - new interrupt
0080B:A.13 = new keys
00814:No new keys - new interrupt
00818:Get new shift state
008E6=Scan keyboard
008E6=Output: A.W = keys	CS if ON key pressed
008E6=Uses: A.W C.X P=0
008E6=Keyboard layout:
008E6=        IN  #20 #10 #08 #04 #02 #01
008E6= OUT   (bit)  5   4   3   2   1   0
008E6=#100    8         B   C   D   E   F
008E6=#080    7       PRG CST VAR  up NXT
008E6=#040    6       STO EVL <<< dwn >>>
008E6=#020    5       COS TAN sqt pwr inv
008E6=#010    4   ON* ENT +/- EEX DEL <==
008E6=#008    3   alp SIN  7   8   9   /
008E6=#004    2   yel MTH  4   5   6   x
008E6=#002    1   blu  A   1   2   3   -
008E6=#001    0        '   0   .  SPC  +
008ED:C.W = origA
008F0:C.X = A.X = 001
008F9:Store [0 . SPC +]
008FF:Scroll ['] away
00902:['] not pressed?
00905:Yes - continue
00907:P = [x 0 . SPC ]
0090B:C.0 = [x 0 . SPC ]
0090F:Set [' 0 . SPC]
00918:[' 0 . SPC] is now in C.S
0091C:Scan = xx8 ?
00921:Yes - next scan 5 keys on row
00923:next scan row
00926:scan it
0092F:Store the 2 nibbles
00935:Lose unsed 2 bits (6 keys on row)
0093B:Continue loop
0093F:Scan = 1x8 ?
00944:Yes - done, add ON key
00946:No , next scan row
00949:Scan it
00955:Save nibble
00958:Save next bit too
00961:Not pressed - cont
0096B:Set key
00974:Store back
00978:Continue
0097C:Scan all keys
00984:ON key now in bit 15
00987:Lose extra bytes
00990:Lose extra nibbles
00999:Store to A.W
0099C:Set carry if ON key is down
009A5=Same as ScanKeys but accepts only stable presses
009E1=A.W = keystate --> C.S = blue/yellow/alpha key-state
009E1:C.W = keystate
00AE5=6 nibbles for each keycode, bits and row data 
00AE5=Data for keycode -> scan code translation. Used by KeyCodeDown?
00C74=Carry set if down
00C8D=Converts KeyCode in A.A to a scancode & tests it
00D3B=Clears 13 nibbles from KEYSTATE
00D57=Stores 00000 to KEYBUFFER
00D71=Flush the key buffer
00D9F=Adds key in C.A to KEYBUFFER, carry set if buffer was full
00DF8=According to an old list..
00ED5=Key codes (ScanKeys) for special ON keys
00ED5=13 nibbles for key & 5 nibbles for execution address
00ED5:Exec directly
00ED6:ON_+
00EE8:Exec directly
00EE9:ON_-
00EFB:Exec on release
00EFC:ON_B
00F0E:Exec on release
00F0F:ON_A_F
00F21:Exec on release
00F22:ON_MTH
00F34:Exec on release
00F35:ON_4
00F47:Exec on release, obey INITEN
00F48:ON_C
00F5A:Exec on release, obey INITEN
00F5B:ON_D
00F6D:Exec on release, obey INITEN
00F6E:ON_E
00F80:Exec on release, obey INITEN
00F81:ON_SPC
00F93:End of table
00FF8=Increases ATTN flag, if overflow then ON_B
01011=Saves RSTK, R1.A and R2.A, executes PrintLcd then resumes via ON_B
0115A=A=IN , RTN
01160=C=IN , RTN
0119D=Prepares starting memory scanner etc (status flags??)
011AC=Configures memory for memory scanner
011FC=Get time (ticks) to C.13, carry clear if no problems
011FC=Uses: A.W B.W C.W D.W P D1
01209:D.S = 0
0120C:RUN is set?
01211:Yes - continue
01213:No - D.S = 1
01230:C.13 = accesstime
0123D:C.4 = calculated crc for accesstime
01250:Does it match with saved crc?
01253:Yes - continue
01255:No - D.S++
01265:B.13 = accesstime
01274:D.S # 0? (RUN clear or CRC diff)
01277:Yes - ignore time get (C.W=0)
01284:Wait until TIMER2 MSB changes
01286:C.W = 8 timer nibbles
0128A:A.W = accesstime
0129E:D.W = timefix
012A1:P=D.S
012A5:C.W = accesstime
012A8:C.W = accesstime-timefix = time
012AB:No problems? (D.S was 0)
012AE:Yep - continue
012B0:No - return carry set
012B4:Check ticks limits, B.W = time
012B7:Set upper limit to C.W
012BC:"SAT 01.01.1989  00:00:00"
012C8:B.W = lolimit, C.W = time
012CB:time too small?
012CE:Yep, return with CS
012D0:B.W = time
012D3:Set upper limit to C.W
012D8:"SUN 01.01.2089  00:00:00"
012E4:B.W = uplimit, C.W = time
012E7:time too big?
012EA:Yep - return with CS
012EC:time ok, return with CC
012EE=GetTime with a check for invalid timer (Warmstarts if invalid)
012EE=Uses: A.W B.W C.W D.W P D1 RSTK1
012F9=GetTime with enable & disable. No error protection.
012F9=Uses: A.W B.W C.W D.W P D1 RSTK1
01307=SAVPTR GetTime++ (calls enable&disable)
01307=Uses: A.W B.W C.W D.W P D1 RSTK2
0130E=GetTime with error protection (calls enable&disable)
0130E=Uses: A.W B.W C.W D.W P D1 RSTK2
0172B=Rescans alarms when the internal alarms list has been changed
01750=C.W = ticks for "SUN 01.01.2089  00:00:00"
01763=C.W = ticks for "SAT 01.01.1089  00:00:00"
01766=C = ticks for 1 day
017A6=beep (C=msec,D=Hz) (Checks BEEP flag first) (Does INTON!!)
018E2=Returns clock speed to A.A
01929=Initialize RAM variables etc
01929=Input: Initialized ROMPTAB, display grobs + TEMPBOT
01929:Disable interrupts
01930:Init contrasr
0193A:Mask out display test values
01947:Too low contrast?
0194A:Yes - set default
01950:Not too high contrast?
01953:Ok - continue
01955:Default contrast
0195C:Set contrast & clear display test
01960:Enable bery-low-bat detection
01964:[EVLBI]
0196B:Enable annunciators, clear them
0196F:[AON]
01976:Init uart
0197D:Init LED
0198A:Init text display settings
0198E:Iniit graphic display settings
01992:Start T1 and T2
01999:[RUN]
019A0:Enable + run card detect
019A4:[ECDT RCDT]
019AB:Init time regs
019AF:Init OUT and IN regs
019B6:Enable keyboard interrupts
019C1:Enable keyboard
019CD:Clear LCD
019D3:Display on, annunciators on
019E4:D.B = old timer status
019E9:T1: [WKE XTRA] T2:[RUN]
019F0:Init T1 MSB to 1
019FB:Wakeup when T1 MSB = 1
01A06:RST set?
01A1C:Set T1 MSB to 7
01A27:Restore old timer status
01A33=Init time settings
01A36:Set TIMEOUT to 0
01A3A:Clear TIMEOUTCLK (C.0)
01A3E:C.W = time
01A45:Got no time
01A48:B.W = time
01A4B:C.W = minute
01A52:D.W = minute
01A65:Set 'system time corrupt'
01A75:A.W = "SAT 01.01.1089  00:00:00"
01A7F:Add 1 minute
01A82:Set new accesstime
01A96=Set TIMEOUT to A.13 0 set TIMEOUTCLK
01AA3:D1 = ->TIMEOUT
01AA9:Set TIMEOUT
01AAD:Set TIMEOUTCLK to F
01ABD=Set TIMEOUTCLK? to C.0
01AC4:D1 = ->TIMEOUTCLK?
01ACA:Set C.0
01B66=Sends ORghost & does A=IN (Obeys BASENIB)
01B8F=Set DON
01BA5=Display on, annunciators on
01BBD=Clear DON
01BD3=Display off, annunciators off
01BEB=Set busy annunciator
01BFF=Clear LCD (VDISP & VDISP2)
01C03:D0 = ->Row1 (@VDISP+20))
01C07:Number of words in VDISP -1
01C11:Clear it
01C15:D0 = ->Sft1 (@VDISP2+20)
01C19:Number of words in VDISP2 -1
01C20=Clears C.A words from D0
01C2C:Loop C.A words
01C31=Gets address of current display (1st row) to D0 (Obeys BASENIB)
01C58=Gets address of menu grob (1st row) to D0 (Obeys BASENIB)
01C7F=Initialize display pointers
01C7F:D0=A.A=->Row1 (@VDISP+20)
01C83:Set display address
01C8D:Set display ghost
01C96:D0=A.A=->Sft1 (@VDISP2+20)
01C9A:Set menu address
01CA1:Set menu ghost
01CAC:Init display line offset to 0
01CB4:Init offset ghost
01CBE:Set display on
01CC6:[DON]
01CC9:Preserve state of [OFF2 OFF1 OFF0]
01CD1:Init display line counter & misc
01CD5:%55 + [DA19]
01CDC:Init ghost
01CE5:Init VDISPSTART and VDISPEND
01CEC=Initialize graphic display line offset, linecount etc
01D44=Sets display off. Resume with DispOn
01DA1=Call: b = 0x80000 or other base-address
01DA1=Ret:  cflag set: not ram;  else:  c = '128K' or '032K'
01E79=Scans & sets shift annunciators accordingly
01EEC=OUT=C then CINRTN  
01F41=03 01 40 20 10 80 00 02 00
01F41=Indexed by routine at 01EFD (byte entries)
01F6D=Clear status & stack area
01FA7=Clear status & stack & menu area (entire display)
01FBD=Calls Starter with ST=0 [2,7] ST=1 [6]
01FC6=Calls Starter with ST=0 [2,6] ST=1 [7]
01FD3=Calls Starter with ST=1 [2,6,7] (Gives Try to recover memory? first)
01FDA=Calls Starter with ST=0 [7] ST=1 [2,6] (Clears memory)
01FE3:C.S = fault
01FE7:Disable interrupts
01FEA:Reset circuitry
01FF4:Configure IO
01FF8:Configure RAM
01FFC:No WSLOG entry
01FFF:No - skip entry creation
02001:P = fault
02005:Run through address 0?
0200A:Not corrupt alarm list?
0201A:RST set?
0201F:Yes - reset pin was pressed
02021:GRST clear?
02026:Yes - RAM is ok
0202E:Add WSLOG entry P to table
02032:Not corrupt alarms list?
02035:Nope - continue warmstart
02037:Start harder
0203B:Clear Alarms pointer
02042:Will be updated by library 00D
02044:configuration object
02049:Init display grobs + TEMPBOT
0204D:Init RAM variables
02054:Set busy annunciator
0205B:Flush ATTN counter
02065:Copy cardstatus to RAM
02112:Set RAM magic constant
0212A:[WKE INT RUN]
02135:A.A = clkspeed
02146:Scan annunciators
0214D:Set default FIRSTPROC
0215E:Clear ROOT
021B8:Set rpl pointer to Boot
021BF:Execute configure obs
021DD:Execute @FIRSTPROC
021E4=Configures internal & external libraries
021E9:( --> { libnum1 .. libnumN } )
02216=Configure libraries (#libnum1 #libnum2... #n)
0221B:( --> Meta #n )
02225:( --> Meta' #libnum )
0222A:( --> Meta' cfg T / Meta F )
02234:( --> Meta' )
0223E:Drop #0
02248=Config control registers to #100
02256=Config RAM to address 70000
02258:Set RAM size
02262:Set RAM address
0226C:Set BASE nibble
02279:Store RAM size mask
0228E=Config RAM to address F0000
02290:Set RAM size
0229A:Set RAM address
022A4:Set BASE nibble
022B6:Store RAM size mask
022C8=Configure cards & extra size mask
022CA:Set card 1 size mask
022D4:Set card 1 address
022DE:Set card 2 size mask
022E8:Set card 2 address
022F2:Set extra size mask
022FC:Set extra address
0239E:D1 = ->port0
023A3:D1 = ->homeend
023A9:D1 = ->homelibs
023B0:D1 = ->home
023B3:Set RRP prlg
023BD:C.A = ->dir (empty home)
023C0:Set context
023CA:Set last context
023D4:Set home
02453=Initializies SystemFlags and sets ISysFlags 48C, 187 and 185
02494=Clears ROMPTAB, Initializes VDISP2, VDISP, ADISP, PDISP, GDISP, TEMPBOT
0249D:Clear ROMPTAB
024A4:C.A = ->ROMPTAB+3
024AE:Default start for menu grob
024C2:Init grob, C.A = ->next
024C6:Set current display
024D0:Init text display
024D7:xsize is still the same
024E3:Init adisp, C.A = ->next
024E7:Set pict display
024F1:Init empty graphic display
024FE:Init graphic display, C.A = ->next
02502:Init TEMPOB area to follow
02509:display grobs
0250E=Initializes grob
0250E=Input: D1 = ram variable pointer
0250E=       C.A = address to set
0250E=       A.15 = grob header (total size in A.A,, y+x sizes upper)
0250E=Output:
0250E:Set address of grob
02514:Set GROB prolog
02521:Set GROB header
02528:C.A = skipped grob
0252C=Move display down C.A nibbles
02536=Move display up C.A nibbles
02588=Init user environment pointers
02591:C.A = ->home
02594:context = home
0259E:last context = home
025A8:D1 = ->home
025AE:D1 = ->touchtab
025B1:clear touchtab
025B5:Set touchtab addr
025C5:D1 = ->loopenv
025C8:Set loopenv count = 0
025CD:Set loopenv addr
025DD:D1 = ->tempenv
025E0:Set offset1 = 0
025E5:Set tempenv addr
025F5:D1 = ->edit$
025F8:Clear edit$
02600:Set dsknot addr
02610:D1 = ->dsktop
02613:Clear stack
02618:Set dsktop addr
0262F:D1 = ->tempbot
02632:Clear tempob area
02637:->temptop
0263A:Set temptop addr
0264A:Set return stack end marker
0264F:->rettop
02652:Set rettop addr
0265F:D1 = ->rettop
02664=Checks relative positions of HOMETOP, PORT0TOP, TEMPOB area etc
02666:Number of pointers to check
02679:B.A = ->tempbot
02682:A.A = ->hometop
0268F:D.A = ->port0top
02691:Check RPLTOP - KeyOb
02698:->ob
0269B:->tempbot > ->ob ?
0269E:ob is below tempob area - cont
026A0:->tempbot < ->ob < ->hometop?
026A3:Yes - clear it
026A5:->hometop < ->ob < ->port0top?
026A8:ob is in home - cont
026AA:Clear pointer to tempob
026AF:Advance to next ptr
026B2:Decr counter
026B8:Loop until KeyOb is checked
026BB:Pop counter
026BF=Configures RAM to #F0000, then executes @C.A, then RetHidC
026BF:Save call address
026C3:Unconfigure RAM
026CD:Configure RAM to #F0000
026D1:Init display to new address
026D5:Restore call address
026D9:Set state restore prg to rstk
026E2:Do call
026E6=Configures RAM to #70000
026E8:Unconfigure RAM at #F0000
026F2:Configure RAM to #70000
026F6:Init display to match ram address
026FD=Add WSLOG entry P
02704:D0 = ->WSLOGLAST
0270D:D1 = ->WSLOGLASTWD
02713:Move WSLOG data forward
02745:C.0 = P
02749:Add new fault
0274F:C.W = ticks
02759:Got no time, use 00000..
0275C:A.W = ticks
0276C:Set fault time
02770:Add CRC for wslog entry
0278F:Resume fault to P
0283D=Set carry if RER or RBF is set
02845:Clear RX
0284A:Clear RBZ
0287F=Transmit byte in A.B. Doesn't check TBF
0287F:Write to TBR
028FC=Prolog signature (enter machine code)
028FC=This is executed when a prolog is executed directly
028FC:Substract 10 from prolog
02903:Execute span code
02911=# prolog (/U #)
02911:Push A.A
02933=% prolog (/U %)
02933:Push A.A
02955=%% prolog (/U %%)
02955:Push A.A
02977=C% prolog (/U C%)
02977:Push A.A
0299D=C%% prolog (/U C%%)
0299D:Push A.A
029BF=Char prolog (/U CHR)
029BF:Push A.A
029E8=Array prolog (/U ARRY)
029E8:Push A.A
02A0A=Linked Array prolog (/U LNKARRY)
02A0A:Push A.A
02A2C=$ prolog (/U $)
02A2C:Push A.A
02A4E=HXS prolog (/U HXS)
02A4E:Push A.A
02A74=List prolog (/U {)
02A74:Push A.A
02A96=Directory prolog (/U DIR)
02A96:Push A.A
02AB8=Algebraic prolog (/U DOSYMB)
02AB8:Push A.A
02ADA=Unit prolog (/U UNIT)
02ADA:Push A.A
02AFC=Tagged prolog (/U TAG)
02AFC:Push A.A
02B1E=Graphic prolog (/U GROB)
02B1E:Push A.A
02B40=Library prolog (/U LIB)
02B40:Push A.A
02B62=Backup prolog (/U BAK)
02B62:Push A.A
02B88=Library Data prolog
02B88:Push A.A
02BAA=iType <BFh> object
02BAA:Push A.A
02BCC=iType <CFh> object
02BCC:Push A.A
02BEE=iType <DFh> object
02BEE:Push A.A
02C10=iType <EFh> object
02C10:Push A.A
02C28=Direct execution of DOBINT
02C28:D0= ->#
02C2E:A.A = ->#
02C31:Size(#)=5+5
02C34:Push A.A
02C49=Direct execution of DOREAL
02C49:D0 = ->%
02C4F:A.A = ->%
02C52:Size(%%)=5+16
02C58:Push A.A
02C6D=Direct execution of DOEREL
02C6D:D0 = ->%%
02C73:A.A = ->%%
02C76:Size(%%)=5+21
02C7C:Push A.A
02C95=Direct execution of DOCMP
02C95:D0 = ->C%
02C9B:A.A = ->C%
02C9E:Size(C%)=5+2*(16)
02CA7:Push A.A
02CBC=Direct execution of DOECMP
02CBC:D0 = ->C%%
02CC2:A.A = ->C%%
02CC5:Size(C%%)=5+2*(21)
02CCE:Push A.A
02CE3=Direct execution of DOCHR
02CE3:D0 = ->chr
02CE9:A.A = ->chr
02CEC:Size(chr)=5+2
02CEF:Push A.A
02D04=Direct execution of sized data class objects
02D04:C.A = len
02D07:D0 = ->ob
02D0A:A.A = ->ob
02D0D:C.A = ->next-5
02D0F:D0 = ->next-5
02D12:D0 = ->next
02D15:Push A.A (address of ob)
02D2A=Direct execution of composite objects
02D2A:D0 = ->ob
02D30:C.A = ->ob
02D33:Save ->ob
02D35:D0 = ->next
02D39:Restore ->ob
02D3B:A.C = ->ob
02D3D:Push A.A
02D59=SP + GARBAGECOL + GP with need1. Also saves A.A, returns to address C.A
02D59:Save return address
02D61:Save A.A
02D6B:Garbage collect
02D71:Restore A.A
02D7B:Clear save (for what?)
02D86:Decrease mem
02D88:Return if enough mem for 1
02D8B:No memory left, error
02D9D=Program prolog (/U ::)
02D9D:Decrease mem
02DA5:C.B = ->rstk
02DA7:D0 = ->rstk, C.A = ->next
02DAA:Set composite return address
02DAD:Increase return stack pointer
02DB3:Set new return stack pointer
02DCC=Code prolog (/U CODE)
02DCC:Decrease mem
02DD1:Increase back, indirect takes no mem
02DD3:Skip code prolog and size
02DDA:C.A = ->code
02DDC:Jump to code at C.A
02DE0=Direct execution of a secondary
02DE0:D0 = ->seco
02DE6:C.A = ->seco
02DE9:Save ->seco
02DEB:D0 = ->next
02DEF:Restore ->seco
02DF1:A.A = ->seco
02DF3:Decrease mem
02DF8:C.B = ->rstk
02DFA:D0 = ->rstk, C.A = ->next
02DFD:Set composite return address
02E00:Increase return stack pointer
02E03:D0 = ->seco
02E06:Set new return stack pointer
02E08:Skip prolog
02E0B:Start execution inside seco
02E20=Direct execution of code
02E20:C.A = len
02E23:D0 = ->Code
02E26:A.A = ->Code
02E29:C.A = ->next-5
02E2E:D0 = ->next
02E31:Skip coode prolog and size
02E3A:Execute code at C.A
02E48=ID prolog (/U ID)
02E48:Decrease mem
02E50:Push IDNT
02E56:Execute ID, rpl code
02E6D=LAM prolog (/U LAM)
02E6D:Decrease mem
02E75:Push LAM
02E7B:Execute LAM, rpl code
02E92=XLIB Name prolog (/U ROMPTR)
02E92:Decrease mem
02E9A:Push ROMPTR
02EA0:Execute ROMPTR, rpl code
02ECE=Direct execution of DOIDNT
02ED0:C.A = chars
02ED3:D0 = ->id
02ED6:A.A = ->id
02ED9:Skip chars
02EE0:D0 = ->next
02EE3:Decrease mem
02EE8:Push A.A
02EEE:Do ID, rpl code
02EFB=Direct execution of DOLAM
02EFD:C.A = chars
02F00:D0 = ->lam
02F03:A.A = ->lam
02F06:Skip chars
02F0D:D0 = ->next
02F10:Decrease mem
02F15:Push A.A
02F1B:Do LAM, rpl code
02F28=Direct execution fo DOROMP
02F28:D0 = ->romp
02F2E:A.A = ->romp
02F31:D0 = ->next
02F34:Decrease mem
02F39:Push A.A
02F3F:Do ROMPTR, rpl code
02F4C=Execute ID (Rpl code for DOIDNT prolog)
02F51:( -> id ob T / id F )
02F60:If id is variable then DoIdntOb
02F65:else just leave id
02F6F=Execute ID when ID has contents (ID ob --> ?)
02F74:C.A = ->ob
02F77:Save ->ob
02F79:Get ->ob prolog to A.A
02F89:Is ob rrp?
02F8C:Yes - set it as context
02F8E:No - check attn then execute ob
02F98:A.A = attns
02F9E:C.A = ->ob
02FA0:attn pressed?
02FA3:Yes - quit
02FA5:No - A.A = ->ob
02FA7:Drop id and ob
02FAE:Execute ob
02FB2:Leave via rpl ?ATTNQUIT
02FBF:C.A = ->ob (rrp)
02FC1:Drop ob
02FC4:OverWr id with ob
02FC9:Exit by setting rrp to CONTEXT
02FD6=Execute LAM (Rpl code for DOLAM prolog)
02FDB:( -> ob T / F )
02FE0:If found contents then nothing
02FE5:Else error
02FEF=Execute ROMPTR (Rpl code for DOROMP prolog)
02FF4:( -> ob T / F )
02FF9:If found contents then execute it
02FFE:Else error
03012=Skip body of object (Useful for skiping in arrays)
03012=Input:  D0 = ->ob+5, A.A = prolog
03012=Output: D0 = ->next, CC (+ C.A=D1)
03012=Uses: D0, A.A, C.A, ST1, P=0
03019=Skip object.
03019=Input: D0 = ->ob
03019=Output: D0 = ->next, CC (+ C.A=D1)
03019=Uses: D0, A.A, C.A, ST1, P=0
0301C:Save D1
03021:Save B.A
03027:Init composite depth counter
03029:Skipping body?
0302C:Yes - already have prolog
0302E:A.A = prolog
03031:D0 = ->body
03034:D1 = ->prolog
03037:A.A = prolog
0303A:Prolog signature
03041:ob isn't prologed object?
03044:Nope - do special check
03046:Yes it is - D1 = ->skipptr
03049:A.A = ->skipptr
0304C:Execute skipcode for prolog
03050:SEMI+5
03057:Not SEMI either?
0305C:Found SEMI, decrease depth
0305E:If B.A was 0 we weren't in composite
03061:Still in composite?
03064:Yep - continue skip loop
03066:Restore B.A
0306A:Restore D1
0306F:Return CC
03071:Weren't in composite, back up
03074:Now exit
03077:Increase depth
03079:And continue in body
0307C:Skip 2*real body
0307F:Skip real body
03082:Continue with end check
03085:Skip 2*%% body
0308B:Skip %% body
0308E:Skip # body
03091:Continue with end check
03094:Skip ROMPTR body
03097:Continue with end check
0309A:C.A = len
0309D:A.A = ->ob+5
030A0:C.A = ->next
030A2:D0 = ->next
030A5:Continue with end check
030AA:C.A = chars
030AD:C.A = 2*chars
030AF:Skip chars
030B4:Next step skips chars count
030B7:Skip char
030BA:Continue with end check
030BD:D0 = ->rrp
030C3:A.A = ->rrp
030C6:D0 = ->rrp+5
030D0:C.A = ->home
030D3:rrp # home?
030D6:Yes - skip normal rrp
030D8:No - skip library attachments first
030DB:C.X = libs
030DB:Skip libnum, libmsg, libhash
030DE:Decrease libs
030E1:Loop all libraries
030E4:Skip libnum
030E7:C.A = offset
030EA:Empty dir?
030ED:Yes - just skip the 0-offset
030F4:D0 = ->lastword
030F9:C.A = idlen
030FC:No name?
030FF:Yep - continue
03101:C.C = 2*chars
03103:Skip id body
0310B:Skip the second idlen
0310E:Skip idlen
03111:Continue skipping in body (last ob)
03117:C.A = chars
0311F:Skip tagname
03124:Skip idlen
03127:Continue skipping in body (tagob)
0312B=End Marker (/U ;)
03130:C.A = ->rstk
03132:D0 = ->rstk, C.A = D0
03138:A.A = ->prevrpl
0313B:D0 = ->prevrpl, A.A = ->prevrstk
0313E:Set new rpl return stack pointer
03140:More room in stack now
03142:Exit
0314C=Internal DEPTH (ob1..obn --> ob1..obn #n)
0315E:D1 = ->dskbot, C.A = D1
03161:A.A = dskbot
03164:C.A = dsktop-dskbot
03166:C.A = C.A/5
0316C:Correct by 1
0316E=Push C.A as #, Loop
0316E:PUSH# pushes #R0.A
03171:Push number
03177:Exit
03181:Need 1
03185:Continue DUP
03188=Internal DUP (ob --> ob ob)
0318D:Decrease mem
0318F:No more room?
03192:Enough room, push A.A
031A5:Need room for C.A
031A9:Continue 2DUP
031AC=Internal DUP2 (ob --> ob ob)
031B8:Decrease mem
031BD:C.A = stk1&stk2
031C1:Back to the free places
031C4:Write stk1&stk2
031D2:Need C.A
031D6:Continue NDUP
031D9=Internal DUPN (ob1..obn #n --> ob1..obn ob1..obn )
031E7:C.A = n
031EA:D1 = ->stk
031ED:Drop #n
031F2:Decrease mem
031F4:Not enough room for duplicates=
031FD:A=n*5
03207:D0 = ->stkn
0320A:Save D0
0320C:C.A = n*5
0320E:Duplicate
03214:Restore D0
03219:Exit
03223=Internal SWAP (ob1 ob2 --> ob2 ob1)
03228:C.A = ob2
0322E:A.A = ob1
03231:stk2 = ob2
03237:stk1 = ob1
0323A:Exit
03244=Internal DROP (ob -->)
03249=Pop stack and continue RPL
03249:Drop
0324C:Increase free memory
0324E:Exit
03258=Internal DROP2 (ob1 ob2 -->)
0325D:Drop stk1 and stk2
03260:Increase memory with 2
03264:Exit
0326E=Internal DROPN (ob1..obn #n -->)
03273:A.A = n
0327F:A.A = 5*n
03281:Advance past ob1
03289:Increase free memory
0328B:Exit
03295=Internal ROT (ob1 ob2 ob3 --> ob2 ob3 ob1)
0329A:Get ob2 and ob3 to A.10
032A1:C.A = ->stk3
032A4:Back to stk2
032A7:Overwrite ob2 and ob3
032AB:Back to stk1
032AE:stk1 = ob1
032B1:Exit
032BB:Need 1
032BF:Continue OVER
032C2=Internal OVER (ob1 ob2 --> ob1 ob2 ob1)
032C7:Decreace memory
032C9:If no mem then garbage collection
032CF:C.A = ->ob1
032D2:'Below' stk1
032D5:Put ->ob1
032D8:Exit
032E2=Internal PICK (obn..ob1 #n --> obn..ob1 obn)
032E7:C.A = ->#n
032F0:A.A = n
032F3:Save D1
032F5:n=0?
032F8:Yes, just drop #
03300:A.A = 5*n
03302:Get old D1
03304:Skip n objects
03306:D1 = ->stkn
03309:A.A = ->obn
0330C:Restore old D1
0330F:Overwrite # with ->obn
03312:Exit
0331C=Restore D1 from RSTK, pop stack and continue RPL
03321:Drop stk1 & exit to rpl
03325=Internal ROLL (obn..ob1 #n --> obn-1..ob1 obn)
0332A:A.A = n
03332:Exit if n=0
03338:Exit if n=1
03340:A.A = 5(n-1)
03347:D1 = ->stkn
0334A:C.A = ->obn
0334D:Save ->obn
03351:C.A = 5n-6
03353:Save low nibble to P
03357:C.A = words+1 to move
0335B:No words no move
0335E:Move 1 word up
0336F:Loop all needed words
03377:C.A = final nibbles to move
0337F:Move final nibbles
0338A:Reset P
0338C:->stk1
0338F:Write ->obn
03394:Exit
0339E=Internal ROLLD (obn..ob1 #n --> ob1 obn..ob2)
03416=Garbage collect with 1 stack element. Uses R0
03416:Need 1 memory
0341D=Garbage collect with C.A stack elements. Uses R0
0341D:Save needed mem
03432:C.A = need
03435:Decrease mem
03437:Return if ok
0343A:Not enough memory - error
03442=Create unlinked array ({#dim1 #dim2} %,C%,$,# --> [])
0344D:A.A = ->ob
03450:B.A = ->ob
03452:D0 = ->ob
03455:D1 = ->obend
0345B:A.A = ->obend
0345E:A.A = oblen
03460:Correct by -5 (prolog away)
03469:R2.A = oblen-5
0346C:D1 = ->stk2
0346F:A.A = ->list
03472:R3.A = ->list
03475:D.A = number of # obs in list
0347B:C.A = dims
0347D:A.A = dims
0347F:A.A = ->list, R3 = dims
03482:A.A = elements, CS if overflow
0348B:Too many elements
03491:R4.A = elements
03494:C.A = oblen-5
03497:B.A = elements*(oblen-5)
0349D:Not enough room
034A0:A.A = n
034A3:B.A = els*(oblen-5)+dims
034AD:A.A = 4*dims
034B2:A.A = els*(oblen-5)+5*dims
034B7:Size of array prlg, size, type, dims
034BE:C.A = size
034C3:D0=->arry
034C9:A.A=->arry
034CC:D1=->arry
034CF:R0.A=->arry
034D2:D0=size
034D5:D0=size-5
034D8:A.A=size-5
034DB:Set arry prolog
034E8:Set size
034EE:Fetch ob type
034F5:A.A = ->stk
034F8:D0 = ->stk
034FB:A.A = ->ob
034FE:D0 = ->stk2
03501:A.A =->stk2, D0=->ob
03504:C.A = prolog
03507:D0=->body
0350A:A.A=->body, D0=->stk2
0350D:B.A=->body
0350F:Set type
03515:C.A=dims
03518:Set dims
0351B:D.A=dims
0351D:A.A=->list
03520:D0=->list
03523:Next arrydim
03526:dims--
03528:Copied all dims
0352B:C.A=dimn
0352F:Set dimn
03532:Copy all dims
03535:C.A=elements
03538:D.A=elements
0353A:elements--
0353C:Done copying
0353F:A.A=->body
03541:D0=->body
03544:C.A=oblen-5 (bodylen)
03547:Copy body
0354D:Copy to all elements
03550:A.A=->arry
03559:Drop ob
0355E:OverWr {} with [], loop
03562=Get array size ([] --> #elements)
03567:A.A=->arry
0356A:Drop arry
03575:D1=->arry
03578:A.A=elements
0357C=Push A as new # and continue RPL
0357F=Push R0 as new # and continue RPL
0358F=Get array type (element prolog as #) ([] --> #)
03594:C.A=->arry
03597:D1=->arry, C.A=->stk
0359A:D1=->type
0359D:A.A=type
035A0:D1=->stk
035A3:Push A.A as prolog binary
035A9=Get array dimensions ([] --> {#dim1...#dimn})
035B4:A.A=->arry
035B7:D1=->arry
035BA:D1=->dims
035C0:D.A=dims
035C9:B.A=15 (max # that is in ROM)
035CB:C.A=10 (size of empty list)
035CE:5-1
035D0:dims--
035D5:D1=->dimn
035D8:A.A=dimn
035DB:dimn<=15?
035DE:Yep - # is in ROM
035E0:No - # must be written
035E3:C.A+=5
035E6:Continue until dims=0
035E9:Size of list is now in
035EB:D0=->list
035EF:A.A=->list
035F5:R0=->list
035F8:Get array
035FF:C.A=->stk
03602:D1=->stk
03605:A.A=->arry
03608:D1=->arry
0360B:D1=->dims
03611:D.A=dims
03613:Set list prolog
03627:B.A=15 (max # that is in ROM)
03629:dims--
0362B:Done copying dimensions
0362E:D1=->dimn
03631:A.A=dimn
03634:dim<=15?
03637:Yes - copy pointer to # in ROM
03639:No - create #
03640:Set # prolog
03643:Set dimn
0364C:Continue copying all dims
0364F:A.A=2*dimn
03651:C.A=2*dimn
03655:A.A=8*dimn
03657:A.A=10*dimn
03660:A.A=->#dimn
03662:Copy dimn, continue copy loop
03665:Set list end
0366F=GETPTR, Overwrite stk1 with R0, continue RPL
03678=Overwrite A, continue RPL
03685=Does element exist? ({#dim1 (#dim2)} [] --> #loc T / F)
0368A:C.A = ->arry
0368D:Save arry
03694:A.A = ->list
0369C:Drop list and arry
036A2:C.A = ->list
036A4:Save ->list
036A6:D.A = dims
036AA:C.A = ->list
036AC:D0 = ->list
036AF:C.A = ->arry
036B1:D1 = ->arry
036B4:D1 = ->adims
036B7:C.A = adims
036BA:dims <> adims?
036BD:Yes - invalid dimension
036BF:dims--
036C1:List was empty - exit
036C4:Init loc
036C6:D1 = ->adim1
036C9:C.A = dimn
036CD:A.A = adimn
036D0:dim1 > adimn?
036D3:Yes - too big dim, exit
036D5:dimn--
036D7:dimn is zero - exit
036DA:loc += dimn-1
036DC:dims--
036DE:Done dims - exit
036E1:D1 = ->dimnext
036E4:C.A = dimnext
036E7:A.A = loc
036E9:B.A = loc*dimnext
036ED:Loop through all dims
036F0:loc++
036F2:A.A = loc
036F4:R0 = loc, push it and exit
036F7=Push # in R0.A, push TRUE, exit
0371D=Get array element (#loc [] -> ob T / F)
03722:ST3 = linked?, A.A = type
03726:R2.A = type
0372C:R1.A = ->arry
0372F:D1 = ->stk2
03735:D1 = ->#
0373B:A.A = loc
0373E:D1 = ->stk2
03741:D1 = ->stk
0374A:C.A = ->arry
0374D:D0 = ->element
03751:Normal array?
03754:Yes - continue
03756:A.A = offset
03759:Nonzero offset?
0375C:Yes - continue
0375E:No - exit by dropping []
03765:and overwriting #loc with FALSE
0376B:D0 = ->offset
0376E:C.A = ->element
03770:D0 = ->element
03773:C.A = ->arry
03776:A.A = ->element
03779:C.A = offs to element
0377B:R3.A = offs
0377E:D0 = ->element
03781:B.A = ->element
03783:A.A = type
03786:D0 = ->nextel
0378C:'Add' prolog lenght
03792:C.A = size
03794:D0 = ->ob
0379B:B.A = ->ob
0379D:D1 = ->ob
037A0:A.A = type
037A3:Set prolog
037A6:D1 = ->body
037AF:C.A = size-5
037BC:D0 = ->stk
037BF:A.A = ->[]
037C2:C.A = offs, R3.A = size-5
037C5:C.A = ->element
037C7:D0 = ->element
037CA:C.A = size-5
037CD:copy body to ob
037D3:A.A = ->ob
037DB:OverWr [] with TRUE
037E5:OverWr #loc with ->ob
037F2=Get array
037F2=Input: D1 = ->stk
037F2=Output: ST3=0 if normal, ST3=1 if linked. A.A = array element prolog
037F2=        (D1=->type, C.A=->stk, CC)
037F2=Uses: A.A, C.A, D1
037F2:C.A = ->arry
037F5:D1 = ->arry
037F8:Save ->stk
037FA:A.A = arryprolog
037FD:Set arry is normal (default)
03807:arry is normal?
0380A:Yep - continue
0380C:Set arry is linked
0380F:D1 = ->type
03812:A.A = type
03815:Restore ->stk
0381C=Counts how many (#) objects the list has
0381C=All pointers other than SEMI are considered to be # (pointer to one)
0381C=Input: A.A = ->list
0381C=Output: D.A = n (D0=->listsemi, CS)
0381C=Uses: D0 A.A C.A D.A
0381C:D0 = ->list
0381F:Skip DOLIST
03822:Init n
0382B:A.A = prolog
0382E:Not DOBINT?
03831:Nope - check if SEMI
03833:Skip #
03836:n++
03838:Continue
03842:Reached end?
03845:Yes - return CS
03847:Skip ptr
0384A:n++
0384C:Continue
0384F=Multiply n binaries in list
0384F=Input: A.A = ->list, D.A = n
0384F=Output: CS if result exceeds #FFFFF
0384F=        CC if ok, A.A = mul
0384F:D0 = ->list
03852:Init result
03854:n--
03856:Nothing to mul
03859:C.A = num, D0=->next-5
0385D:B.C = num
0385F:n--
03861:Done - get result to A.A
03864:C.A = num2, D0=->next-5
03868:A.A = num
0386A:B.A = num*num2
0386E:Overflow
03871:Continue
03874:A.A = result
03876:Result ok, CC
03878=D0=D0+5, Pops # from there to C (Uses A,C)
03878:Skip 5
0387B:A.A = prolog
03885:prolog = #?
03888:Yes - get number
0388A:D0 = ->#
03890:C.A = num
03893:Restore D0
03898:Skip # prolog
0389B:C.A = num
038A0=Get element location for normal/linked array
038A0=Input: C.A = ->arry, A.A = loc, ST3=linkedp, R2.A = element_type
038A0=Output: D0 = ->element, CS
038A0=Uses: A.A B.A C.A D.A D0
038A0:D0 = ->arry
038A3:D0 = ->dims
038A9:D.A = dims
038AD:No dims - continue
038B0:D0 = ->dimnext
038B3:Loop until D0 = ->lastdim
038B6:loc--
038B8:Cannot get 0-element
038BB:D0 = ->el
038BE:B.A = loc-1
038C0:Normal arry?
038C3:Yep - continue
038C5:Skip to element offset
038C9:B.A = 5(loc-1)
038CE:A.A = ->el
038D0:D0 = ->el
038D3:Return with CS
038D5:C.A = type
038D8:D.A = type
038DA:Special routines for ob types
038E1:whose size is fixed
038E4:Find # el
038F0:Find % el
038FC:Find %% el
03908:Find C% el
03914:Find C%% el
03920:Find chr el
0392C:Find normal el
0392E:Fetch romptr el
03930:B.B = 3(loc-1)
03932:Fetch chr el B.A = 2(loc-1)
03934:Fetch el
03937:Fetch C%% el, B.A = 2(loc-1)
03939:A.A = 2(loc-1)
0393B:Fetch %% el
0393D:B.A = 4(loc-1)
0393F:B.A = 5(loc-1)
03941:A.A = 16(loc-1)
03943:B.A = 21(loc-1) (*2 for C%%)
03945:Fetch el
03948:Fetch C% el, B.A = 2(loc-1)
0394A:Fetch % el, B.A = 16(loc-1)
0394C:Fetch element
0394F:A.A = ->el
03951:D0 = ->el
03956:Fetch normal el, loc--
03958:No need to skip anymore
0395B:C.A = type
0395D:A.A = type
0395F:Skip 1 element
03965:Skip loc elements
03968=Get element count of array
03968=Input: D1=->arry
03968=Output: A.A=elements (B.A=elements, C.A=dimn, D1=->el1, CS)
03968=Uses: A.A, B.A, C.A, D.A, D1
03968:Skip arry prolog, size, type
0396B:C.A = dims
0396E:D.A = dims
03970:Init els
03972:dims--
03974:Empty arry, return 0
03977:D1=->dim1
0397A:A.A=dim1
0397D:dims--
03982:D1=->dimn
03985:C.A=dimn
03988:B.A=A.A*C.A
0398C:A.A=els
0398E:Continue until done all dims
03991=Multiply two binary numbers
03991=Input: A.A = num1, C.A = num2
03991=Output: CS if result > #FFFFF. Else B.A = result
03991=Uses: A.A B.A C.A
03991:Init result
03998:A=0, result is 0
039BE=Reserve room for object from tempob area.
039BE=Input: C.A = nibbles
039BE=Output: D0=->ob, D1=->obend, CC  (GPMemErr if not enough room)
039BE:Clear sGARBAGE
039C1:Save size
039C3:D0 = ->ob, D1 = ->obend
039C9:Got room
039CC:If second time then out of mem
039D7:Set GC has been done
039DA:C.A = size
039DF:C.A = size
039E1:Return CC for ok
039EF=Shrink or expand variable.
039EF=Input: ST5 = sEXPAND, C.A = nibbles, A.A = D0 = ->ob
039EF=Output: B.A = ->ob' (D1=->ob' R2.A = ->ob R0.A = nibbles)
039EF=Not used: R3 R4
039EF:Expand?
039F2:Yes - check if enough mem
039F4:R2.A = ->ob
039F7:Fix offsets inside home
039FD:A.A = ->ob
03A00:C.A = nibbles
03A03:Move ->stk - ->ob up, exit
03A09:R2.A = ->ob
03A0F:Save ->ob to R1
03A12:Require space for C.A nibbles
03A16:Restore ->ob from R1
03A1C:Fix offsets inside home
03A22:A.A = ->ob
03A25:C.A = nibbles
03A28:Move ->stk - ->ob down, exit
03A2E=Check that there is room for C.A nibbles. If not then do GC and check
03A2E=again. If still not enough then GPDropMemErr
03A2E=Input: C.A = nibbles
03A2E=Output: C.A = nibbles, D.A = room
03A2E:Clear sGARBAGE
03A31:D.A = nibbles
03A33:C.A = room
03A3B:room>=nibbles?
03A3E:Yes - return
03A43:GC done - error
03A45:Save nibbles
03A4D:Set GC done
03A50:Restore nibbles
03A52:Try room again
03A5B:Drop stk1
03A60:Insufficient memory error
03A64=Clear INITEN, save old status to ST2
03A64=This needs to be called when objects in HOME etc are changed directly
03A64=so that ON-C etc will be disabled to prevent memroy-loss
03A6B:A.B = status
03A6E:Clr sINITEN by default
03A71:Wasn't set?
03A76:Set sINITEN
03A79:Unroot
03A86=Push A.A onto stack
03B2E=Equivalent if object adresses are the same
03B33:A.A = ->ob1
03B3B:C.A = ->ob2
03B3E:Same address?
03B97=Equivalent if object prologs & contents are the same
03B97=(ob1 ob2 --> T/F)
03B9C:A.A = ->ob2
03BA4:C.A = ->ob2
03BA6:A.A = ->ob1
03BA9:D1 = ->ob1
03BAC:R2 = ->stk
03BAF:A.A = prlg1
03BB2:D0 = ->ob2
03BB5:R0 = ->rpl
03BB8:C.A = prlg2
03BBB:B.A = prlg2
03BBD:R1 = ->rstk
03BC0:prlg1 = prlg2?
03BC3:Yes - compare bodies
03BCE:Restore ->stk
03BD4:Restore ->rstk
03BD9:Restore ->rpl
03BDF:Overwrite C.A
03BE2:Exit
03BEC:A.A = ->ob2
03BF2:B.A = ->ob2
03BF4:D0 = ->ob2end
03BFB:A.A = ->ob2
03BFD:D1 = ->ob2
03C00:R3 = ->ob1
03C03:D0 = ->ob1, A.A = ->ob2end
03C06:A.A = oblen2
03C08:B.A = oblen2
03C0A:D0 = ->ob1end
03C11:C.A = ->ob1
03C14:A.A = ->ob1
03C16:A.A = ->ob1end, D0 = ->ob1
03C19:C.A = ob1len
03C1B:Different sizes?
03C1E:Yes - exit with false
03C20:B.A = words to compare
03C22:P = extra nibbles to compare
03C26:words--
03C28:No words to compare
03C3C:Different words - exit false
03C3E:Next word
03C41:nibbles--
03C43:No nibbles to compare
03C51:EQUAL - exit true
03C53:Different nibbles - exit false
03C64=get object prolog (possible array elements,see list at 3F8B)
03C75=Pushes A as # (prolog list at 3F8B, #0 if no match)
03F0E=Pushes A.A and C.A as #, exits to rpl
03F14=Push R0 & R1 and continue rpl
03F24=A.A/C.A -> A.A C.A
03F5D=Pop stk2 and stk1 (#) into A.A and C.A
03F8B=<2933h> (% prolog)
03F95=<2977h> (C% prolog)
03F9F=<2A74h> (List prolog)
03FA9=<2948h> (ID prolog)
03FB3=<2D9Dh> (Program prolog)
03FBD=<2AB8h> (Algebraic prolog)
03FC7=<2A96h> (Directory prolog)
03FD1=<2E6Dh> (LAM prolog)
03FDB=<2955h> (%% prolog)
03FE5=<2ADAh> (Unit prolog)
041A7=Internal OFF.
041D4=OFF with no alarm or other warning checks
041ED=Internal OFF, ( --> T/F) (True if Invalid Card Data)
041F6:Disable interrupts
041F9:Scan annunciators
04206:Exit if alarm request
04209:Sleep
0426A=Flash warning "Invalid Card Data"
04274:"Warning:\n"
0427E:"Invalid Card Data"
04292:Save timer control
042A2:Restore timer control
042B8=Get TIMERCTRLs to RSTK1.B
042CC=Restore TIMERCTRLs from RSTK.B 
04546=#0=OK, #1=Alarm, #2=LowBat(S), #4=LowBat(P1), #8=LowBat(P2)
04546=Returns last system warning (-> 1:#) 
04552:Update annunciator data
04560:Push annunciator data as #
04577=(1:# -> 1:$) (#0:Alarm #1:Low(S) #2:Low(P1) #3:Low(P2))
04577=Gets last system warning msg 
0469F:Diasable keys
046AA:Clear key state
046B8:Clear buffer
046C9:Enable ON keys
046E1:Scan for next alarm
046EE:Execute FIRSTPROC
046FB:Note! FIRSTPROC should be secondary
04708=Returns, but doesn't pop next key from buffer ( --> #KeyCode T / F )
0470D:Clear sPOP
04714=Pop next key from key buffer ( --> #KeyCode T / F )
04719:Set sPOP
0471C:A.A = ->stk
0472A:A.S = num2
04731:C.S = num1
04735:Empty buffer?
04738:Yes - exit with false
0473A:P = num1
04741:No pop - don't update num1
04743:num1++
04746:Update num1
0474A:C.A = ->buffer
0474D:Skip to next key
04755:D1 = ->key
0475A:C.A = key
0475D:D1 = ->stk
04760:Exit by pushing #C.A and TRUE
0477E=Updates keybuffer if any keys are pressed
0477E:Set OUT mask to allkeys
04791:Disable KBD
047A6:Any key pressed?
047A9:Yes - enable keys
047AB:Flush KEYSTATE
047B7=Enables keyboard by clearing nibble at DISABLE_KBD
047C7=Key pressed? ( #KeyCode --> T/F )
047CF:Disable KBD
047E4:A.S = num1
047EB:C.S = num2
047EF:Buffer has keys?
047F2:Yes - then key cannot be repeated
047F4:D1 = ->stk
047F7:C.A = ->#
047FD:Save ->stk
04802:A.A = KeyCode
0480E:A.A = ->stk
04810:Key was pressed
04817:OverWr FALSE, exit
04822:Enable KBD
0482F:OverWr TRUE, exit
04840=Pop next key in keybuffer to C.B (Updates POPPEDKEY)
04840=Uses: A.S C.S C.A D1 P=0
04890=Scans annunciators, displays time if requested, enters LiteSlp
048A9=Displays time if requested
048F9=Clock req. & saved display on? (-> 1:T/F)
04912=Enter light sleep
04929=ML light sleep.
04930:Cleared to mark no interrupt calls
0496B:[ECDT]
04977:Interrupt has occurred?
0497F:[ECDT RCDT]
04988=Carry set if ATTNFLG <> 0.
04988=Uses: D1 C.A
04999=Carry set if keybuffer no empty
04999=Uses: D1 A.S C.S C.A
049B8=Carry set if AlarmSet? and alarms not disabled
049BA:IgnoreAlmMASK
049C6:Ignore alarms - CC
049FF:ServModeMASK
04A0B=Recall #menuitem contents ( #1-6 --> ob )
04A1E:R0.A = n
04A41=Recall #menuitem name (1:#1-#6 -> 1:ID/$)
04A4C=Sto #menuitem name (2:$ 1:#1-#6)
04A57=Set prg according to shifts (2:prg 1:#7 ->)
04B15=If P=4, get address, if P=8 get name (To D0)
04B1F:D0 = ->tab
04B22:C.S = num1
04B2B:C.A = num2
04B2E:B.A = num2
04B34:C.A = 5*num2
04B36:->items
04B39:A.A = ->items
04B3C:Want def?
04B3F:Yes - get it
04B41:C.S = 2*num1
04B47:A.A = ->items+5*num2
04CDC=Reference to message table for library 000 (XLIB 0) (<72000h>)
04CE6=Rcl last #error from ERRN (70673) (-> 1:#error)
04D0E=Store new #error into ERRN (70673) (1:#error)
04D33=Clear last #error in ERRN (70673)
04D64=If #70000 then DRGETEXITMSG, else JstGETTHEMESG (#msg -> $)
04D87=Fetches message from message table (1:# -> 1:$)
04D9B=Fetch message (2:#n 1:[$] -> 1:$) (TOTEMPOB, if out of range NULL$)
04DD7=Splits library message number (<54321h> -> <21h> <543h>)
04E07=replace stk1 with EXITMSG
04E37=Store $ as EXITMSG
04E5E=Set error trapping environment
04E8F:C.A = offset/counter
04E92:No env if zero
04E9A:C.A = protection
04E9D:protection++
04EA4=Clears last error, then does ERRJMP (:: ERRORCLR ERRJMP ;)
04EA4=Executed if ATTN key is pressed
04EB8=Cleans Errortrap, skips next
04ED1=Execute error
04FAA=Error: Power Lost
04FB6=Error: Insufficient Memory
04FC2=Error: Directory Recursion
04FCE=Error: Undefined LAM
04FDA=Error: Invalid Card Data
04FE6=Error: Object In Use
04FF2=Error: Port Not Available
04FFE=Error: No Room in Port
0500A=Error: Object Not in Port
05016=Error: Undefined XLIB Name
0501E=Invokes error code in C.P (General error table)
05023=Invoke error code in A.A
05040=Recall ATTN counter from ATTNFLG (--> #attns)
05068=Clear Attn counter in ATTNFLG (@70679.A = 0) (not from keybuffer!)
05089=Get first element of composite (Also UVAL) (1:comp -> 1:Ob)
0508E:C.A = ->ob
05094:Save ->stk
050A3:->ob is empty composite?
050A6:Yes - return
050AD:Save ->rpl
050B9:Prologed object?
050BC:Yes - push it
050BE:No - push ptr
050ED=Get first char of $ ($ --> Char | NULL$ --> NULL$)
05143=Restore D,B,D1,D0 (C=D0), clear carry and continue RPL
05153=Internal SUB 2 to end (comp --> comp')
0516C=internal SUB 2 to end ($ --> $ | NULL$ --> NULL$)
05176=#FFFFF
0518A=Appends HXS2 to HXS1 (HXS1 HXS2 --> HXS3)
05193=Internal + (2:$2 1:$1 -> 1:$)
0521F=Internal + for composites (comp2 comp1 --> comp)
0525B=Char to head of $ ($ chr -> $')
052C6=Obj to head of composite (comp ob --> comp')
052EE=Char to tail of $ ($ chr --> $')
052FA=Obj to tail of composite (comp ob --> comp')
05331=build composite object (N+2:Obj1...,2:#n 1:#prolog -> 1:comp)
05445=Internal ->PROGRAM (N+1:Obj1...1:#n -> 1:seco)
05459=Internal ->LIST (N+1:Obj1...1:#n -> 1:{})
0546D=Internal ->ALGEBRAIC (N+1:Obj1...1:#n -> 1:Symb)
05481=Internal ->UNIT (N+1:Obj1...1:#n -> 1:Unit)
054AF=Internal OBJ-> (1:comp -> N+1:Obj1...1:#n)
0554C=If ST=1 10 tehn GPMEMERR else GARBAGECOL, GETPTR
0556F=(1:$ -> 1:T/F)
055B7=(1:comp -> 1:T/F)
055D5=HXS template
055F3=Algebraic template (Sysevaling this crashes)
055FD=Unevaluated null program
05607=Evaluate NULL::, an end marker for secondaries in the debugger
05616=Internal SIZE (1:hxs -> 1:#nibbles)
05622=SIZE of level 2 $ (2:$ 1:Any -> 3:$ 2:Any 1:#bytes)
05636=Internal SIZE (1:$ -> 1:#bytes)
0567B=Internal SIZE (1:comp -> 1:#obs)
056B6=Internal GET (comp #i --> ob T / F)
05733=Internal SUB (bytes) (3:$ 2:#start 1:#end -> 1:$)
05815=Internal SUB (nibbles) (3:hxs 2:#start 1:#end -> 1:hxs)
05821=Internal SUB (3:comp 2:#start 1:#end -> 1:comp) (Does range checking)
05902=Internal BYTES (size only) (1:Any -> 1:#bytes)
05912=R0.A = OSIZE @D1
05944=Internal BYTES (1:RAM-Object -> 2:#nibbles 1:HXScrc)
05951:R1.A = CRC
05957:Push #osize
05965:A.A = CRC
0596B:Push HXS of lenght 4
0597E=Get CRC for ob at C.A, size A.A
0597E=Output: A.A = CRC (low 4 nibbles)
0597E=Uses: A.A C.W P D0
0597E:D0 = ->ob
0598A:Disable interrupts
0598D:Clear CRC
05991:C.A = size
05994:Store nibble counter to P
05998:A.A = word counter
0599A:nibbles--
0599C:Check words next
0599F:Access data, updates CRC
059A3:Skip nibbles
059AC:Only words to go now
059AE:words--
059B0:Done - get CRC
059B3:Access data, updates CRC
059B7:Skip word
059BA:words--
059BC:Loop all words
059C1:A.A = CRC
059C5:Enable interrupts
059CC=Convert # to HXS ( # --> hxs )
059D7:A.A = #
059DD:R1 = #
059E5:D0 = ->$body
059E9:C.A = #
059EC:Write
059F6:A.A = ->$
059F9:D1 = ->$
059FC:Set HXS prolog
05A03=Convert HXS to # ( hxs --> # )
05A08:A.A = ->hxs
05A0B:Drop hxs
05A16:D1 = ->hxs
05A1C:A.A = len
05A1F:D1 = ->body
05A29:A.A = bodylen
05A2D:bodylen >= 5?
05A30:Yes - get low 5 only
05A32:bodylen--
05A34:bodylen was 0, push 0
05A3A:P = bodylen-1
05A3E:Init hi nibbles to zero
05A40:Get nibbles
05A44:Push result
05A51=Convert CHR to # ( chr --> # )
05A56:A.A = ->chr
05A59:Drop chr
05A64:D1 = ->chr
05A67:D1 = ->chrbody
05A6C:A.A = chr
05A6F:Push #chr
05A75=Convert # to CHR ( # --> chr )
05A86:R0.A = #
05A89:Size fo char object
05A90:D0 = ->ob
05A99:D1 = ->ob
05A9C:Set chr prolog
05AA3:D1 = ->chr
05AA9:C.A = #
05AAC:Set chr body
05AB3=Create new copy of ob with a new prolog ( ob #prolog --> ob' )
05ACC=Change object prolog (ob #prolog --> ob')
05AD1:A.A = prolog
05AD7:C.A = ->ob
05ADA:D1 = ->ob
05ADD:Set new prolog
05AE0:D1 = ->stk
05AE3:Exit
05AED=Convert ID to LAM ( id --> lam )
05B01=Convert LAM to ID ( lam --> id )
05B15=Convert $ to ID ( $ --> id )
05B15=Note: Will not check that size($) < 256
05B20:A.A = ->$
05B26:D1 = ->$len
05B29:C.A = $len
05B2E:C.A = $len+2 = size of needed ID
05B30:D0 = ->ob
05B3D:A.A = ->stk
05B43:A.A = ->$
05B49:D0 = ->$body
05B4F:R0 = ->ob
05B52:A.A = $len+2
05B54:Set prolog
05B5E:D1 = ->idlen
05B61:Prolog size + idlen field size
05B68:A.A = idbodylen
05B6A:C.A = idbodylen = $bodylen
05B6C:A.A = idlen in chars
05B6F:Set idlen
05B72:D1 = ->idbody
05B75:Copy body, exit with R0.A on stk1
05B79=Allocate string (C.A bytes -> D0 = addr of body)
05B7D=Allocate string (C.A nibbles)
05BE9=ID/LAM to $ conversion (no quotes) (1:ID/LAM -> 1:$)
05C27=Internal R->C (2:%re 1:%im -> 1:C%)
05C8A=Internal LR->LC (2:%%re 1:%%im -> 1:C%%)
05D2C=Internal C->R (1:C% -> 2:%re 1:%im)
05DBC=Internal LC->LR (1:C%% -> 2:%%re 1:%%im)
05E81=Internal ->TAG (2:Any 1:$tag -> 1:Tagged) (Doesn't check LEN$<256)
05E9F=List to Tagged (1:{ID Any} -> 1: Tagged)
05EC7=Internal OBJ-> (1:Tagged -> 2:Obj 1:$tag)
05EEA=Change prolog of list element one to ID (1:{LAM Any..} -> 1:{ID Any..}
05F2E=Tag ob with name (2:Obj 1:ID/LAM -> 1:Tagged)
05F42=RPL Garbage Collect
05F61=Internal MEM (-> 1:#nibbles)
05F91=Set ST0 and Carry if object in B.A-D.A is referenced or in composite
05F91=Uses: A.A C.A D1 ST0
05F91:Assume referenced
05F9E:D1 = ->stk
05FA5:start > ->ob?
05FA8:Yes - not a reference
05FAA:end > ->ob?
05FAD:Yes - referenced
05FAF:Not referenced - next stk object
05FB2:C.A = ->obn
05FB5:Not end of stack?
05FB8:Yes - check ob
05FC4:D1 = ->rstk
05FCA:start > ->stream
05FCD:Yes - not referenced
05FCF:end > ->stream
05FD2:Yes - referenced
05FD7:D1 = ->streamn
05FDA:Not end of return stack?
05FDD:Yes - check stream
05FDF:Check RAM variables
05FEA:A.B = counter
05FED:C.A = ->ob
05FF0:start > ->ob
05FF3:Yes - not referenced
05FF5:end > ->ob
05FF8:Yes - referenced
05FFD:counter--
06000:Loop all variables
06003:Check tempenv for refs
0604A:Check menukeys for refs
06071:Not referenced
06076=If ob at C.A is in tempob area then mark it used
06076=Input: A.A = ->tempbot  B.A = ->temtop  C.A = ->ob
06076:D.A = ->ob
06078:C.A = RSTK1
0607A:C.A = ->ob, D.A = RSTK1
0607C:->temptop <= ->ob ?
0607F:Yes - ob not in temp
06081:->ob >= ->tempbot ?
06084:Yes - ob is in temp
06086:C.A = RSTK1
06088:Restore RSTK1
0608C:D0 = ->ob
0608F:D0 = ->obend
0609D:A.A = dat
060A0:ob not followed by SEMI?
060A3:Not followed - cont
060A5:Include SEMI
060A8:Include all SEMIs
060AD:C = #2xxxx
060B0:Set carry if possible marker
060B5:Not marker - keep skipping forward
060BA:C = #Fxxxx
060C2:Set F marker
060C5:Restore RSTK1
060C9:Restore ->tempbot to A.A
0613E=Machine language garbage collect. Assumes SAVPTR has been done
0613E=Input: SAVPTR done
0613E=Output: ??
0613E=Uses: A.W B.W C.W D.W P D0 D1 ST0
0613E:Save RSTK1
0614A:Save status of ST1 to ST0 because
0614D:SKIPOB will change it
06150:Trashes ST0 of course..
06155=First mark all objects as unreferenced (#E)
0615F:D1= ->temptop
06164:C.S = #E
06169:D1 = ->tempoff1
0616C:C=offset
0616F:End of tempobs?
06172:Yes - continue
06174:B=offset
06176:P = marker
0617A:C.4 = marker
0617E:C.5 = C.4
06184:Restore offset + marker
0618B:C.A = ->prev tempob offset
06193=Now start checking references by changing marker to #F if referenced
06193=During the loop A.A = ->tempbot  B.A = ->temptop
0619F:B = ->temptop
061A8:A = ->tempbot
061AB:Increase marker to #F
061AE:Store marker to B.S
061B1=Check stack
061BB:D1 = ->stk
061BE:Always done
061C1:Mark if tempob
061C5:Next stackob
061C8:C = ->ob
061CB:Not end of stack?
061CE:Yes - check ob
061D0=Check rpl return stack
061DA:D1 = ->rettop
061DD:Always jump
061E0:Mark stream if in tempob
061E4:D1 = -->prev stream
061E7:C = ->prev
061EA:0000x considered end of return stack
061EE:End of rpl return stack?
061F1:Yes - continue with RAM variables
061F3:Restore C.A
061FA=Check RAM variables RPLTOP .. KeyOb
061FA:Now check RAM pointers
06203:Set counters (37 ptrs from RPLTOP)
0620A:Low nibble counter to C.S
0620D:Hi nibble counter to D.S
06210:C=->ob
06213:Mark ob if in tempob
06217:Next RAM pointer
0621A:Decrement counter one
0621D:More to go
06220:Decrement counter two
06223:More to go
06226=Check lamda variables
06230:D1 = ->tempenv
06233:Always done
06236:Save offset counter
06240:C=->lamname
06243:Check name
06247:Skip lamname
0624A:C=->lamob
0624D:Check lamob
06251:Skip lamob
06254:Resume offset counter
0625E:10-1 = size(lamname,lanob)
06260:Sets carry if end of this env
06265:Jump if env continues
06268:C=offset to next env
0626B:Skip offset and protection
0626E:15-1 = size(offset,prot,?)
06270:Negate offset to get increasing cntr
06272:Offset <> 0 - check env
06275=Check menukeys
06281:D1 = ->touchtab
06284:skip counters
06287:Always jump
0628E:next menukey
06291:c=->menukey
06294:not end of menukeys?
06297:Nope - check it
06299=Now calculate how much will be removed
0629B:D0 = ->temptop
0629E:Init counter
062A2:C = #Exxxx
062A5:D = #Exxxx
062A8:D0 = ->offset 1 in tempob
062AB:Get offset+marker
062AF:End of tempobs?
062B2:End of mark checking
062B3:Weird
062B4:A = ->offset
062B7:D1 = ->offset
062C0:Marker = 0 if unused, 1 if used
062C3:Restore original offset
062C7:Marker to C.5
062CF:A = ->prev tempob
062D1:D0 = ->prev
062D6:To be deleted?
062D9:Yes - add offset to counter
062DB:Set new offset to be counter
062EE:Marker = #F
062F1:Set new mark
062F8:Increase counter with offset
06303:D0=tempbot
0630A:A=@tempbot
0630F:D1=stack
06326:C=stackob
06329:not end of stack?
064AE:Restore ST1
064B9:Fix free memory
064BD=( ob --> ob' ob )
064BD=Makes a standalone copy of ob to TEMPOB (ob'). ob will be unreferenced
064D6=Move all references to ob2 prolog to ob1 (except stk1)
064D6=( ob1 ob2 --> ob1 ob2 )
064DB:Set prolog references only
064E2=Move all references (but stk1) to ob2 to point to ob1
064E2=( ob1 ob2 --> ob1 ob2 )
064E7:Set object references
064EA:A.A = ->ob2
064ED:Done so that stk1 won't be updated
064F4:B.A = ->ob2
064F6:D0 = ->ob2
064F9:Skip prolog
064FC:Unref PTR only?
064FF:Yes - got end alread
06501:No - skip to find ob2 end
06504:D0 = ->ob2end
0650A:C.A = ->ob1
0650D:C.A = ob1-ob2 = diff
0650F:A.A = ->ob2end
06512:A.A = ->ob2 B.A = ->ob2end
06514:Move references
0651C:Now uncover stk1 which is the only
0651F:reference to ob2 now
06529=Push R0 and R1 as new #
06537=Push R0 as new #
06544:n is small?
06547:Yes - push pointer to ROM #n
06549:NO - create new object
065AA=Restore registers and Error: Insufficient Memory
065D9=( Ob --> Ob flag ) Is object (address) referenced?
065E5=Is object referenced (body checked too) (Ob --> Ob flag)
065ED:A.A = ->ob
065F0:Hide reference on stk1
065F7:B.A = ->ob
065F9:D0 = ->ob
065FC:A.A = prolog
065FF:D0 = ->body
06602:C.A = ->body
06605:PCO?
06608:Yes - check PTR only
0660A:Check only ptr?
0660D:Yes - continue
0660F:No - find ->obend
06612:D0 = ->obend
06618:C.A = ->obend
0661B:D.A = ->obend
0661D:Set ST0 if ->ob - ->obend is refd.
06625:Uncover ob
06628:Push flag ST0
06641=Pop stk1 (#) into A.A
06657=Internal NEWOB ( ob --> ob' )
066B9=Copy memory area
066B9=Input: D0 = ->src_end, D1 = ->dst_end, C.A = nibbles
066B9=Output: D0 = ->src, D1 = ->dst, CC, P=0
066B9=Uses: A.W C.W D0 D1 P
0670C=Copy memory area
0670C=Input: D0 = ->src, D1=->dst, C.A=nibbles
0670C=Output: D0 = ->srcend D1 = ->dstend, CC, P=0
0670C=Uses: A.W C.W D0 D1 P
0670E:Nothing to copy
06711:P = low counter
06715:C.A = word counter
06719:No words to copy
0671C:Copy word
0673E:Copy last nibbles
06746:Update D0 to end
0674F:Update D1 to end
06758:Reset P
0675C=Clears C.A nibbles from @D1
0679B=Saves D0 to RPLTOP, D1 to DSKTOP, B to RETTOP, D to FREETOP, clr carry
067D2=Restore D,B,D1,D0 (C=D0), clear carry
06806=Get amount of free memory
06806=Output: C.A = free  (CC, A.A = ->rettop D0=RETTOP)
06806=Uses: A.A C.A D0
0680D:C.A = ->stk
06817:A.A = ->rstk
0681A:C.A = free
0681E=Move reference if in specified area, stores fixed ref to DAT1.A
0681E=If ST2 is set then area 2 is also checked with it's own offset in D0
0681E=Input: A.A = lo, B.A = hi, D.A = signed offset, C.A = ->ob
0681E=       R0.A = lo2, R1.A = hi2, D0 = signed offset 2
0681E=Output: DAT1.A modified if in areas, CS
0681E=Uses: C.A
0681E:Ob is lower than lo?
06821:Yes - cont
06823:Ob is higher than hi?
06826:Yes - cont
06828:Fix address with offs
0682A:Set it into DAT1
0682D:Exit
0682F:Area check enough?
06834:A.A = hi2, R1.A = lo
06837:A.A = hi, B.A = hi2
06839:A.A = lo2, R0 = hi
0683C:ob < lo2?
0683F:Yes - no movement
06841:ob > hi2?
06844:Yes - no movement
06846:C.A = offs, D.A = ->ob
06848:C.A = offs2, D0 = offs1
0684B:C.A = ->ob, D.A = offs2
0684D:Fix ob with offs2
0684F:Set it into DAT1
06852:C.A = offs2
06854:C.A = offs, D0 = offs2
06857:D.A = offs
06859:A.A = hi, R0 = lo2
0685C:A.A = hi2, B.A = hi
0685E:A.A = lo, R1 = hi2
06861:Done
06863=Moves references ob (or memory area)
06863=Input: A.A = ->ob, B.A = ->obend, C.A = offset
06863=Output: D.A = offset
06863=Output: Fixed stack, return stack, tempenv, menukeys, ram varibles
06863=        (D.A = offset1)
06863=Uses: C.S P=0
06863:A.A=->ob B.A=->obend D.A=offs
06865:Save ST
06867:Set 1 check only
0686E=Checks 2 areas instead of one
0686E=Moves references ob (or memory area)
0686E=Input: A.A = ->ob, B.A = ->obend, C.A = offset1
0686E=       R0.A = ->ob2, R1.A = ->obend2, D0 = offset2 (signed)
0686E=Output: Fixed stack, return stack, tempenv, menukeys, ram varibles
0686E=        (D.A = offset1)
0686E=Uses: C.S P=0
0686E:A.A=->ob B.A = ->obend D.A=offs
06872:Set check R0.A-R1.A too (offset D0)
06875:Save status flags
06880:Save RSTK1
0688C:Save RSTK2
06894:Check stack
0689E:D1 = ->stk
068A5:Next stack level
068A8:C.A = ->stkn
068AB:End of stack?
068AE:Yes - continue with rstk
068B0:Move refs to stack object
068B4:Loop all stack objects
068B7:Check rpl return stack
068C1:D1 = ->rstk
068C4:Previous return stack level
068C7:C.A = ->rstkn
068CA:End of return stack?
068CD:Yes - continue with tempenv
068CF:Move refs to stream
068D3:Loop all rpl streams
068D6:Check lams
068E0:D1 = ->tempenv
068E7:Fix tempenv offset with 10
068EA:size(offset)+size(protection word)
068F0:Skip tempenv offset and protection
068F3:Save tempenv offset
068F5:Check lamname
068FC:Check lamob
06906:Skip to next lam
06909:Decrement offset
06914:Not end of this env?
06917:No - continue next lam
06919:C.A = offset (tempenv)
0691C:Not end of tempenvs?
0691F:Not, check tempenv
06921:Check menu keys
0692B:D1 = ->menu
0692E:Skip ???
06934:Check menukey
06938:Next menukey
0693B:C.A = ->key
0693E:Not end of keys?
06941:No - check this key
06943:Check RAM pointers
0694C:Number of RAM pointers to C.14.15
06950:locounter in P, hicounter in C.S
06954:C.A = ->ob
06957:Check ob
0695B:Next pointee
06969:Checking done, resume old status
06974:Now C.X = old ST
0698E:C.A = offset1
06990:Always return CC
06992=Moves area A.A - ->rstk downwards in memory updating references
06992=Input: A.A = ->lowmem, C.A = nibbles
06992=Uses: A.W C.W P
06992:B.A = nibs, A.A = ->lowmem
0699B:C.A = ->rstk
0699E:B.A = ->rstk
069A0:Negate nibs
069A2:Move refs to A.A-B.A with C.A
069A6:C.A = ->lowmem'
069A8:D1 = ->lowmem'
069AB:C.A = ->rstk, B.A = ->lowmem'
069AD:C.A = ->rstk'
069AF:Set new ->rstk
069B9:D0 = ->lowmem
069BC:C.A = ->rstk' - ->lowmem' = nibs
069BE:Move area
069C2:Update free memory
069C5=Moves area ->stk - A.A upwards in memory (updates refs)
069C5=Input: A.A = ->lowmem, C.A = nibbles
069C5=Uses: A.W C.W P D0 D1
069CC:B.A = ->lowmem
069CE:A.A = ->stk
069D1:A.A = ->stk+1
069D3:Move refs
069D7:A.A = ->stk
069D9:Set new ->stk
069E0:A.A = ->stk'
069E5:A.A = ->lowmem'
069E7:D1 = ->lowmem'
069EA:B.A = ->lowmem', C.A = ->lowmem
069EC:D0 = ->lowmem
069EF:A.A = nibs
069F1:C.A = nibs
069F3:Move area
069F7=Corrects FREETOP (D.A) after moving DSK/RETTOP
069F7=FREETOP=(DSKTOP-RETTOP)/5
069F7=Output: CC (C.A = free)
069FE:C.A = ->stk
06A08:A.A = ->rstk
06A0B:C.A = nibs
06A0D:C.A = free
06A11:Set new free
06A1D=Move area ->stk - A.A downwards in memory (updates references)
06A1D=Input: A.A = ->himem, C.A = nibbles
06A1D=Uses: A.W C.W P D0 D1
06A1D:D.A = nibs
06A1F:B.A = ->himem
06A21:C.A = room
06A25:C.A = nibs, D.A = room
06A27:A.A = ->himem
06A29:Not enough room?
06A2C:Nope -exit CS
06A35:A.A = ->stk
06A38:Negate to move down
06A3A:Move references
06A3E:D0 = ->stk
06A41:A.A = ->stk'
06A43:D1 = ->stk'
06A46:B.A = ->himem'
06A48:A.A = nibs
06A4A:C.A = nibs
06A4C:Move area
06A50:Fix free memory
06A53=Move area A.A - ->rstk downwards in memory (updates references)
06A53=Input: A.A = ->himem, C.A = nibbles
06A53=Uses: A.W C.W P D0 D1
06A8E=C.A=C.A/5  Uses:P,A,D
06AD8=Allocate memory without trying GC
06AD8=Input: C.A = nibbles
06AD8=Output: CS: not enough memory, need GC
06AD8=        CC: D0 = ->ob, D1 = ->obend  (B.A = C.A = nibbles+6)
06AD8=Uses: A.10 B.A C.10 D.10 P D0 D1
06B3E=Is obj in TEMPOB area, not in composite? (ob --> ob flag)
06B4E=Is obj in TEMPOB area, not in composite, not referenced? (ob --> ob flag)
06B5A=If stk1 is in tempob area execute rpl at C.A
06BC2=Object not referenced (body checked too)? (ob --> ob flag)
06DDE=Move free ob to top of TEMPOB area (ob --> ob')
06DEF:A=room
06DF4:We have atleast 16 nibbles?
06DF7:Yes - continue
06DF9:Nope - error
06E06:B.A=room
06E0F:C.S = initen
06E13:Save initen
06E1C:unroot
06E20:C=->ob
06E23:D0=->ob
06E26:D=->ob
06E28:D0=->obend
06E2F:C=->ob
06E31:C=->obend D0=->ob
06E34:C=oblen
06E36:D0=ob-1
06E39:C=oblen+6
06E3F:RSTK=oblen+6
06E4B:D1=->tempenv
06E4E:A=room
06E56:C=room'
06E5C:A=room'
06E65:C=->temptop
06E68:C=??  D1=->temptop
06E6B:D0=??
06E6E:C=oblen+6
06E7D:Restore initen
06E8E=No Operation (continue RPL)
06E97=Push next ob & advance interpreter pointer
06EEB=If ret pointee is SEMI, push NULL:: & do not advance ret pointer
06EEB=Push next object in previous stream & advance ret pointer
06F66='R then EVAL (Eval next ob from prev. stream & advance ret pointer)
06F8E=Internal EVAL (1:Not {} ALG or TAGGED)
06F9F=Push pointer to stack 1 (and add 5) to return stack
06FB7=Pop return stack (= skip remainder of prev. instr. stream)
06FD1=Execute the next object in this stream & return
07012=Example: :: :: R@ EVAL <foo> ; <bar> ;  =  :: <bar> <foo> <bar> ;
07012=Push remainder of prev. instr. stream (doesn't advance ret.pointer)
0701F=Example: :: :: R> EVAL <foo> ; <bar> ;  =  :: <bar> <foo> ;
0701F=Push & Skip remainder of prev. instr. stream
07035=Makes a program of return stack (address -> A)
070C3=Stack version of IF-THEN-ELSE (3:flag 2:Trueprg 1:Falseprg)
070FD=Stack version of IF-THEN (2:flag 2:Trueprg)
0712A=If pop stk1 = True, then SKIP
0714D=Skip next object
0715C=Skip next two objects
0716B=Set return to self ( BEGIN jumps here )
071A2=Start loop ( Copies interpreter pointer (I) onto return stack )
071AB=(BEGIN <loop clause> AGAIN)
071AB=Copies top of return stack to interpreter pointer
071C8=(BEGIN <loop clause> UNTIL)
071C8=If True, pop return stack, else copy it to interpreter pointer
071E5=(BEGIN <test clause> WHILE <loop clause> REPEAT)
071E5=Copies top of return stack to interpreter pointer
071EE=(BEGIN <test clause> WHILE <loop clause> REPEAT)
071EE=If False pop return stack & 2SKIP (over REPEAT)
07221=Push loop counter of topmost DoLoop environment as #
0722A=Gets @D0, sets D0=A, SAVPTR, Pushes @D0, exits to rpl
07249=Push loop stop value of topmost DoLoop environment as #
07258=Push loop counter of 2nd DoLoop environment (info+25) as #
07264=Push loop stop value of 2nd DoLoop environment (info+30) as #
07270=Store stk1 (#) into top loop counter
07295=Store stk1 (#) into top loop stop value
072AD=Store stk1 (#) into 2nd loop counter (info+25)
072C2=Store stk1 (#) into 2nd loop stop value (info+30)
072D7=--> @D0=INDEX, A.A=D0, C.A=@LOOPENV
072EC=--> @D0=JINDEX, A.A=D0, C.A=@LOOPENV
07321=Terminates topmost LOOP environment
07334=next (DO <loop clause> LOOP)
073A5=Internal STEP (DO <loop clause #step +LOOP)
073C3=for 0 to stk1-1 ( #end ZERO DO <loop clause> LOOP)
073CE=for 1 to stk1-1 ( #end ONE DO <loop clause> LOOP)
073DB=for 1 to stk1 ( #end+1 ONE DO <loop clause> LOOP)
073F7=for stk1 to stk2-1 ( #end #start DO <loop clause> LOOP)
07497=Purge topmost temporary environment
074D0=<< INNERCOMP DOBIND >>
074D0=Create new temporary environment (N:Any,..,1:{LAMs})
074E4=Create new temporary environment (2N+1:Any,...N+1:LAM,...1:#N)
075A5=Return obj in #nth temp var (1:#n -> 1:Obj)
075E9=Stores obj in #nth temp var (2:Obj 1:#n)
07638=Detach message table (1:#libnum) !! BUGGED !!
0764E=Attach message table (2:[$] of $ 1:#)
076AE=Internal DETACH from HOME directory (1:#libnum)
07709=Internal ATTACH to HOME directory (1:#)
077C2=Is #Libnum attached to home? (1:#libnum -> 1:T/F)
07819=Make empty dir (1:#libnum -> 1:emptydir)
07866=Carry set if not equal strings in D0 and D1
0791E=(1:LAM -> ob TRUE / FALSE) @LAM for lam environment 1 only
0792A=(2:LAM 1:#n -> ob TRUE / FALSE) @LAM for lam environment n only
07943=Recall LAM's contents (1:LAM -> 2:Obj 1:T/ 1:F)
0797B=Recall (1:LAM/ID) -> (2:contents 1:T / 1:F)
079D7=Changes current and last directories if STO requires it.
07A56:A.A = ->idlen
07A59:D1 = ->idlen
07A5E:A.A = ->idlen
07A61:Ignore nullid
07A66:Ignore trailing extra chars
07A6F:C.A = idlen'
07A72:RSTK = idlen'
07A74:Skip to ->idbody
07A77:C.W = 1st part
07A7B:D.W = 1st part
07A81:C.W = 2nd part
07A85:B.W = 2nd part
07A88:Assume not bint
07B5E=R2=LIBNUM R3=CMDNUM# -> A=addr
07B94=D0 = addr of ASCIC (length,body) -> A = addr of IDNT (Uses R2)
07BFD=Directories in current path are searched before libraries!!
07BFD=Recall variable/romptr (1:ID -> 2:ID/ROMPTR 1:T / 1:F)
07C12:R0.A = ->StrLen
07C1F:R1.A = ->Context
07C29:Found matching ID - exit with TRUE
07C49:->Context == ->Home ?
07C4C:Yes - no need to test in this dir
07C6D:Try updir
07C71:Loop if found one
07C74:None found - exit with FALSE
07C93:Back to previous lib
07C9F:Done with this directory?
07CA5:Yes - try updir
07CA7:Save ->libfield
07CAD:A.X = libnum
07CB0:R2.X = libnum
07CB6:A.A = ->hashtab
07CB9:No hash table
07CBC:None - loop to next
07CBE:D0 = ->hash table
07CC1:Find hashname
07CC5:No match - loop
07D1B=Store to LAM (2:Any 1:LAM)
07D27=Internal STO (2:Any 1:LAM/ID) (Especially LAMs???)
07E50=Internal ->XLIB (2:#libnum 1:#object -> 1:XLIB)
07E76=Internal RPL->XLIB (1:XLIB contents -> 1:XLIB)
07E99=Internal XLIB->RPL (1:XLIB Name -> 2:RPL 1:T / 1:F)
07EDE=A.A=address of ROMPTR -> A.A = address of RPL object
07F10=A.A = adr of A.X library's A.X object (set carry if none)
07F98=get attachments (1:Dir -> 2:{} 1:T/F) (1:XLIB -> 1:#Xlibno)
0807F=(1:#lib -> 2:#addr 1:TRUE / 1:FALSE)
0807F=Returns LIBs location + 10 (title location) 
0809E=Returns nibbles(LIB)-10 (1#libnum -> 2:#nybbles 1:T / 1:F)
080C9=(1:#libnum -> 2:#libnum 1:T / 2:#nextLIBno 1:T / 1:F)
080C9=Does LIB or one with bigger number exist?
08101=Get hash table (1:#libnum -> 2:HXS 1:T / 1:F)
0811C=Get message table location (1:#libnum -> 2:[] 1:T / 1:F)
08128=Get link table (1:#libnum -> 2:HXStable 1:T / 1:F)
08143=get config code (1:#libnum -> 2:config code 1:T / 1:F)
0814F=Get LIB number (1:LIB_ID -> 2:#libnum 1:T / 1:F)
081B9=Get library name (1:#libnum -> 1:ID 1:True / 1:False)
081D1=GETPTR, make IDNT of ASCIC in D0, overwrite obj on stk1
081D9=Get Backup name (1:BAK -> 2:ID 1:True / 1:False)
081EE=Get Library number (1:LIB -> 2:#libnum 1:True / 1:False)
08207=RPL to ID (1:seco -> 2:ID 1:True / 1:False) (seco is ROMPTR program)
0821F=ROMPTR Name to ID (1:XLIB -> 2:ID 1:True / 1:False)
082E3=Get object name -> (1:variable contents -> 1:ID)
08309=Recall parent directory (rrp --> rrp' T / FALSE )
0830E:A.A = ->dir
08317:A.A = ->updir
0831E:CS, no parent dir exists
08322:CC, push parent in A.A
08326=Recall first entry from DIR (rrp --> ob T / F)
0832B:A.A = ->rrp
0832E:D0 = ->rrp
08331:Save old D0
08334:D0 = ->last
08338:A.A = offset
0833B:offset <> 0?
0833E:Yes - continue
08340:Restore old D0
08346:Exit with FALSE
0835D:C.A = ->lastname
08362:Skip name
08366:A.A = ->lastob
08369:Write ob
0836C:Restore D0 , exit
08376=Recall next entry from DIR (variables are stored in reverse order) 
08376=(ob --> ob_next T / FALSE)
0837B:A.A = ->ob
0837E:D0 = ->ob
08381:Save old D0
08384:Skip ob name
08388:D0 = ->offset to prev
0838B:A.A = offset
0838E:No prev variable exists?
08391:Yes - exit with false
08396:C.A = ->ob_prev
08398:Overwrite ob_prev, TRUE
0839B=From ob fetch start of directory (pointer to the last object after prolog)
0839B=Input: A.A = ->ob
0839B=Output: CS: dir is home, A.A = C.A = ->home
0839B=        CC: D0 = ->offset_to_last_ob_in_same_dir
083A2:C.A = ->home
083A5:Is ob home?
083A8:Yes - exit
083AA:D0 = ->ob
083AD:Skip object name
083B4:B.A = ->obname
083B6:D0 = ->obname
083B9:D0 = ->offset to prev
083BC:C.A = offset to prev
083BF:No more variables?
083C2:Yes - exit
083C4:Skip to previous variable
083C9:Loop to previous variable
083CC:D0 = ->offset to last
083D1=Recall parent directory
083D1=Input: A.A = ->dir
083D1=Output: CS: no parent
083D1=        CC: A.A = ->updir
083D1:D0 = ->up
083E4:A.A = ->home
083E7:D0 = ->lastoffset
083EB:C.A = ->lastoffs
083EE:We're in home now?
083F1:Yep - exit
083F3:No - more to skip
083F5:D0 = ->up
083F8:Skip dir prolog and libnum
083FB:D0 = ->updir
08400=Skips nnNAMEnn in D0 (nn = length)
0841E=D0 = addr of object -> D0 = ASCIC (length, body)
0841E=Expects nnNAMEnn in front of object (nn=length)
0841E=Thus works for RAM objects but can be used for other purposes too
0843A=A=libnum -> C=D0=address found from ROMPTAB (Carry set if not found)
0843A=Address is address of library number (after title)
0846E=(A.A = LID, B.A = CMD -> A.A=D0=HASHLOC)
08471=If ST=0 11 Hash, else Mesg (Carry set if not found)
084DF=If ST=0 11 Link, else Config (Carry set if not found)
08503=Skip directory header data
08503=Input: A.A = ->dir
08503=Output: D0 = ->offset1
08503=Uses C.A D0
0850A:C.A = ->home
0850D:D0 = ->dir
08510:Skip ob prolog
08513:ob is not home?
08518:C.X = libs in home
0851B:libs--
08521:skip libnum, hash, mesg
08524:Loop to skip all lib data
08527:Skip libs (libnum for normal dirs)
0852C=Change offsets inside home for ECUSER
0852C=Does not check if there's room for expansion. Does not move stack
0852C=Input: C.A = nibbles D0 = ->ob
0852C=Uses: A.A B.A C.A D.A D0 D1 R0 R1 ST5 ST2
0852C:R0.A = nibs
0852F:D.A = nibs
08531:C.A = ->ob
08534:Unroot home, save old status to ST2
0853A:If no movement
0853D:then return
08546:A.A = ->home
08549:Trying to modify home?
0854C:Yes - no offsets to fix
0854E:B.A = ->ob
08550:D0 = ->offset1 in HOME
08554:A.A = ->ob
08556:A.A = ->offset1, D0 = ->ob
08559:R1.A = ->offset1 in HOME
0855C:A.A = ->ob
0855F:D0 = ->offset1 (in dir where ob is)
08563:A.A = offset1
08566:C.A = ->offset1
0856C:C.A = ->lastob
0856E:ob <> lastob?
08571:No - update offsets in this dir
08573:C.A = ->offset1
08576:D.A = ->offset1
08578:No need to update offsets inside dir
0857B:D.A = ->lastob
0857D:C.A = nibs
08580:Expand?
08583:Yes - increase offset
08585:No - offset = offset1-nibs
08587:Set new offset to last ob
0858A:offset = offset1+nibs
0858C:Set new offset1
0858F=Now just skip variables after ob
0858F:C.A = ->offset1
08592:C.A = ->lastob, D.A = ->offset1
08594:D0 = ->ob
08597:D0 = ->offset to prev var
0859A:A.A = offset
0859D:C.A = ->offset
085A3:C.A = ->offset - offset (->newloc)
085A5:->ob <> ->newloc?
085A8:Yes - loop until ->ob is found
085AA=Now start fixing offsets for variables before ob
085AA:A.A = offset
085AD:C.A = nibs
085B0:Expand?
085B3:Yes - increase offset
085B5:No - decrease offset
085BC:Set new offset
085BF:C.A = ->offset1 in HOME
085C2:All directories done?
085C5:Yes - exit
085C7:No - C.A = ->lastob
085C9:D0 = ->lastob
085CC:D0 = ->dir
085CF:Update updir offsets too
085D3=Replace variable contents with a new one (ob_new ob --> ob_new)
085D8:A.A=old
085DB:R4.A=old
085DE:Drop old
085E3:A.A=new
085EC:B.A=new
085EE:D0=new
085F1:Skip new
085F7:C.A=newend
085FA:A.A=old
085FD:Old is new?
08600:If so then quit
08602:old < new?
08605:Yes - continue
08607:newend <= old?
0860A:Yes - continue
0860C:Recursion error
08610:Exit without doing anything
08620:C.A=newlen
08622:C.A=old, R4.A=newlen
08625:D0=old
08628:B.A=old, C.A=new
0862A:D.A=new
0862C:Skip old
08632:C.A=oldend
08635:new >= oldend?
08638:Yes - continue
0863A:B.A=oldend C.A=old
0863C:new >= old?
0863F:Yes - recursion error
08641:B.A=old, C.A=oldend
08643:C.A=oldlen
08645:A.A=newlen
08648:Different sizes?
0864B:Yes - need ECUSER call
08653:Just copy
08657:oldlen>newlen?
0865A:Yes - shrink
0865C:Set expansion
0865F:C.A=nibbles
08664:Set shrinking
08667:C.A=nibbles
08669:A.A=old
0866B:D0=old
0866E:Do expand/shrink, B.A=->ob'
0867B:A.A=->stk
0867E:D0=->stk
08681:C.A=->new
08684:A.A=->ob'
08686:OverWr ob_new with ->ob'
08689:D0=->new
0868C:D1=->ob'
0868F:C.A=newlen
08692:Move new to target, exit
08696=STO to current dir (2:Ob 1:ID) (Ob not primitive code object)
089D8=PURGE (2:var contents 1:T/F) (True = ob is referenced)
089FA=PURGE (1:var contents)
08C27=Purge variable (1:ID) (Does no type check on contents)
08C4A=Makes checks too (1:var contents)
08C68=STO (2:Ob 1:ID) works if ID exists/doesn't exist
08C77=Replace var contents (3:New contents 2:Any 1:Old contents)
08CCC=Internal XLIB-> (1:XLIB Name -> 2:#library 1:#object)
08D08=Save to current Directory (1:DIR)
08D14=Pops stk1 to @C, returns to rpl
08D2F=Stores 00000 into @C.A, returns to rpl
08D35=Pushes TRUE if @C.A is 00000, Else FALSE, Loop
08D4A=Save Temp Directory
08D5A=Recall Current Directory
08D66=Push @C.A
08D75=Continues rpl at @C.A
08D82=Recall Temp Directory
08D92=Set home directory to @CONTEXTptr (Current Directory)
08DC4=Set home directory to @LCONTEXTptr
08DD4=== HOMEDIR ? (1:DIR -> 1:T/F)
08E0F=Deep internal CRDIR (1:ID -> ) (Doesn't check if ID is already used)
08E32=Return {} with all #libnums (internal & external)
08E50=(2:{Obj1 Obj2..} 1:#n -> 2:{Obj1 Obj2... #n} 1:#n+1
08E73=EQUAL (2:ID/#libnum 1:BAK/LIB -> 3:ID/# 2:BAK/LIB 1:T/F)
08F86=(3:LIB/BAK 2:#libnum/ID 1:#1/#2)
08FA9=(2:Any 1:#Port) If port Present,Writeable,Not Merged
08FA9=then (-> 4:#size 3:#addr 2:Any 1:#addr) else NOPORTERR
08FEA=(4:ID/#libnum 3:Any3 2:BAK/LIB 1:Any1 -> 2:ID/#libnum 1:Any1)
08FEA=Error (Ob in use) if BAK/LIB and ID/#libnum are the same Library
09107=STO (5:ID 4:Ob 3:#addr 2:#nibbles+5 1:#port (#1/#2) )
09269=(2:LIB/BAK 1:#libnum/ID)  (Checks there already isn't one)
09287=Recall LIB/BAK if allowed (2:ID/#libnum #1:port -> 2:LIB/BAK 1:T/1:F) 
092E1=(1:ID/#libnum -> 2:BAK/ID 1:T / 1:F )
092F5=Recalls end addr of HOME (= start of port0) ( -> 1:#addr)
09318=(2:ID/#libnum 1:#0/#1/#2 -> 2:LIB 1:T / 1:F)
09327=(1:Any -> 2:#port0addr 1:T)
09340=Recall port #addr and (!merged? & present?) (1:#port -> 2:#addr 1:T/F)
093D1=(2:ID/#libnum 1:#portaddr -> 2:BAK/LIB 1:T / 1:F)
093D1=Doesn't check write etc protections
09408=Purge (2:ID/#libnum 1:#1,#2) (Checks usage etc first)
0941C=If purgeable, nothing, else OBINUSEERR (1:LIB/BAK -> 1:LIB/BAK)
09453=Purge (1:ID/#libnum) (Checks usage etc first)
09471=(D1=addr of BAK -> A = addr of object (BAK name skipped)
0948E=(1:BAK -> 1:Contents)
094A4=Makes a BAK of HOME directory (which is purged) (1:ID -> 1:BAK)
09699=Restores HOMEDIR from BAK (1:BAK ->)
0970A=Done after BAK>HOME. Stores F to INITEN
09730=Clear ptrs to User Keys and Alarm List
09752=PGDIR (rrp --> ) Does not check SavedContext
09789=(1:Ob -> 3:NewOb 2:F 1:Ob)
097ED=PURGE DIRs contents (Empty dir remains) (rrp --> rrp')
09806=(ob --> ) If type(ob)==rrp then PGDIR else PURGEOB
0985B=(2:dir 1:{ID_DIR ... ID_VAR } -> 2:ob 1:T / 1:F)
09B73=c=Crc(X042c-X044d),d0=X0428
09CF5=Default CONFTAB
0AAB2=(1:#port -> 5:present? 4:writeable? 3:merged? 2:#size 1:#addr)
0AAB2=3Falses' 4ROLL GETPORTSTATUS
0AAD0=(4:F..2:F 1:#port -> 5:present? 4:writeable? 3:merged? 2:#size 1:addr)
0AB51=Returns end of (used?) port (1:#port -> 1:#addr)
0AB82=Returns BAK/LIB & nextaddr (1:#addr->3:BAK/LIB 2:#nextaddr 1:T / 1:F)
0AC2A=Store to port0 (1:LIB/BAK) Does NEWOB & memory check
0AC66=Minumum memory required for FREE to work (#36)
0AC70=Store to port0 (1:LIB/BAK) Does no NEWOB nor memory check
0AD15=Purges regardless of usage etc (1:LIB/BAK)
0AD1A=:: BEGIN DUP 0AF8B NOT UNTIL ; (1:LIB/BAK)
0AD47=(1:LIB/BAK) conditions ???
0ADEF=Purges regardless of usage etc (3:#portsize 2:#portaddr 1:LIB/BAK) 
0AE03=(3:#portsize 2:#portaddr 1:LIB/BAK) conditions???
0B037=(1:#port)
0B4A9=(#port Meta) If no mem in port for meta obs, error, else 0B599
0B52B=(Meta #0 -> ateM 1:#OSIZE(meta) )  (Meta obj is reversed exc. for#)
0B52B=Example: A B C x* + #5 #0  ->  + x* C B A #5 #20F
0B599=(Meta #port --> ) Does not check for sufficient mem
0B9D4=Recall hidden Dir (2:DIR 1:T / 1:F)
0B9E8=(1:T/F -> 2:DIR 1:T / 1:F)  (HiddenDir@ uses False, dunno others)
0BA7D=Stores NULLDIR as hidden directory
0BB40=Configuration code for library 000 (XLIB 0)
0BB40=NS:?MkNullHidden
0BB40=Store NULLDIR as Hidden DIR if it doesn't exist
0BB68=Some reference check for purging port objects (ob --> ob flag )
0BC15=(GNT data 2:Ob2 1:Ob1 -> GNT_Next_Data TrueTrue / GNT data False
0BC15=EQUAL test (GNT = GetNextToken)
0BC47=EQUAL test (2:Any2 1:Any1 -> (3:Any2 2:T 1:T)/(2:Any2 1:F)
0BC6F=False -> SKIP
0BC6F=False True -> False True SEMI
0BC6F=True True  -> COLA
0BCCF=False -> False True SEMI
0BCCF=False True -> False True SEMI
0BCCF=True True ->
0BCED=False Ob -> False Ob SEMI
0BCED=True Ob ->  
0BD31=False True -> False True SEMI
0BD31=True False -> True
0BD31=True True  ->
0BD54=(OVEREQ$case)
0BDF6=DROP GetNextToken COLA
0BF74:Set covered size (mask)
0BF7D:B = mask
0BF7F:Interrupts off
0BF86:C = mask
0BF88:RSTK = mask
0BF99:B.A = ram base address
0BF9E:D1 = RAMSIZE
0BFA4:Save old RAM addr and size
0BFB0:Store old settings
0BFBA:Check display address
0BFC6:No need to reconfigure display?
0BFCA:C = mask
0BFCC:C = ramsize
0BFCE:B = ramend
0BFD2:Check display end address
0BFDB:No need to reconfigure display?
0BFE0:C = mask
0BFE2:Save A.A
0BFEB:Save ST flag
0BFFA:A= ramsize
0BFFD:B = ramsize, A = ramend
0BFFF:Is ram larger than normal?
0C016:Resume A.A
0C01F:Resume ST
0C02A:C = mask
0C093:B = mask
0C0A0:C = rambase
0C0AB:Set base is 0
0C0AF:Unconfig RAM
0C0B2:Config new ram mask
0C0B7:Config same ram address
0C0BC:Reset ram base
0C0D1:Configed to normal loc?
0C0D6:Check mask size
0C0E4:Abnormal size, set root
0C0EA:Set new mask to RAMSIZE
0C1EF=(1:Char -> 1:%%) Example:(1:CHR_m -> 1:%%0.001) (Data at 74228)
0C288=Is Char a unit prefix? (1:Char -> 2:Char 1:T/F)
0C288=Prefixes D E G H K M P T a c d f h k m n p myy -> True
0C2CB=Is $ a SIUNIT (not kg) (1:$ -> 2:$ 1:T/F) 
0C2CB=True if :"m" "A" "s" "K" "cd" "mol" "?")
0C37A=(1:UNIT$ (no prefixes) -> 3:hxs_mask 2:%%factor 1:TRUE / 2:$ 1:FALSE)
0C37A=Example "N" (Newton) -> # FE000101 %%1 TRUE) (See 0FDE5 entry)
0C4EC=(#index #address_of_array --> ob TRUE / FALSE )
0C4EC=(#index [] --> ob TRUE / FALSE )
0C4EC=Get array element, (size, fixed, id, lam)
0C612=( #addr --> ob )
0C612=If #70000-#7FFFF fetches from hidden ROM
0C74D=If BASENIB<>7 then GOSUB:, else just jumps
0C783=Uncovers 8K, gosubs next 5 nibbles & resumes after that in normal mode
0C8DE=Takes 5 nibs from rstk and goes there (In hidden ROM)
0C8DE:Disable interrupts
0C8E5:Save C.A
0C8E7:C.A = D1
0C8EA:Save D1.0
0C8FC:C.0 = base
0C904:C.4 = base
0C90B:D1 = ->GOTOsave
0C911:Restore C.4 to D1
0C915:Save D1
0C91D:Save C.A
0C923:Save B.A
0C92F:Set F
0C935:Uncover
0C94F:D1 to B.A
0C953:Set addr
0C95B:Save RSTK1
0C960:Get back D1
0C963:Set return address
0C96C:Set addr
0C971:Restore saved regs
0CA60=Restores iram, checks ATTNFLG, exits via GETPTR & rpl ?ATTNQUIT if <>0
0CA88=ATTNchk without restoring iram. Uses: SETHEX, C.A D.A
0CB25=Stores NULL{} into ID_ALARMS
0CBAE=Error: Nonexistent Alarm
0CBEF=MC: P=0, SETHEX, restore registers, clear carry
0CBFA=Internal TIME (-> 1:%time)
0CC0E=Internal DATE (-> 1:%date)
0CC39=Internal DDAYS (%date2 %date1 -> %days) (%date1-%date2)
0CC5B=Internal DATE+ (%date %days -> %date') 
0CC79=Internal DATE+ (%date %days --> %date') %days must be integer
0CD2B=Internal ->DATE (Does CheckClock) (1:% ->)
0CD3F=Internal CLKADJ (Does CheckClock) (1:% ->)
0CD53=Internal ->TIME (Does CheckClock) (1:% ->)
0CD67=Internal ->DATE (1:%)
0CDA6=Internal ->TIME (1:%)
0CDD0=Internal A/PM (Doesn't do CheckClock)
0CE0F=Internal CLKADJ (1:%)
0CE80=Sets new time in clock, exits to rpl
0CEB9=If clock flag is set, 
0CF31="MONTUEWEDTHUFRISATSUN"
0CF5B=date to day-of-week (1:HXS -> 1:$)
0CFD9=date to $date (1:% -> 1:$)
0D06A=time to $time (1:% -> 1:$)
0D143=(hxs --> %time)
0D156=(hxs --> %date)
0D169=(hxs --> %rpt)
0D18A=Deep internal WSLOG (1:#1-#4 -> 1:$)
0D2A3=Internal WSLOG (WSLOG# with #1-#4 -> $ $ $ $)
0D2D5=if Clock Display active (-40) -> True/False
0D2E9=MC XFER: let C(13) = TICKS
0D2F0=date to day-of-week (%date -> $weekday)
0D304=Internal TSTR (2:%date 1:%time -> 1:$)
0D349=Internal TSTR (hxs --> $)
0D36C=Checks %date in C.W, clears carry if ok
0D46B=(A.A=0YYYY, B.B=MM, D.B=DD --> C=00000000YYYYMMDD, CC, P=7)
0D46B=Packs date to 1 register, see sasm.doc
0D485=(A.A=YYYY, DEC --> CS if YYYY is leap year, uses C.A, SB, Carry)
0D485=Determines if year is a leap year, see sasm.doc
0D4AD=Converts %date to days (A.W --> C.W)
0D5D2=Calculates C=48B+6B/16, B=6B/16
0D62F=Converts decimal to hxs
0D665=Converts ??? to YMD (Year in A, month in B, day in D)
0D6D8=Converts HXS in A.W to %. Uses P, returns carry cleared
0D6FD=Substracts 2 dates (-->A.W) Returns carry set if invalid dates
0D744=Converts day to %date (A.W --> A.W)
0D77E=Converts YMD to day-of-week (-->A.A)
0D7A1=Sets carry and ST1 according to flag -42
0D7BB=Sets carry and ST2 according to flag -41
0D7D5=Sets carry and ST3 according to flag -43
0D7EF=NS:alrmsaveon?
0D7EF=Sets carry and ST4 according to flag -44
0D809=Sets carry and ST4 according to flag -56 (Beep off?)
0D840=Sets carry and ST5 according to flag -57 (Alarm beep off?)
0D877=Sets carry and ST0 according to ClkOnNib
0D8AE=SETHEX, POP1%, 
0D92C=c=yyyymmdd (%date --> ) Errors if invalid date
0D948=a=b=c=ticks??? (%time --> )
0D9C7=Checks %time in C.W, clears carry if ok
0DA4E=Multiplies A.W by 96, uses C.A (=2*A)
0DA77=Divides A.W by 60 (-->A.W=B.W=C.W)
0DA87=Converts Ticks in C.13 to %Tod in A.W
0DB0B=Clears A except A.A field
0DB0B=Clears carry if 19890101 <= C.W < 20881231
0DB3A=Converts date to ticks (--> C.W)
0DB51=Converts ticks (C.W) to 
0DB7B=(Divides TICKS by 2A300000 = %8192*%24*%60*%60)
0DB7B=Converts ticks (C.W) to days (hxs) (A.W=C.W)
0DB87=Calls european? hours24? getClkOnNib rptoff? getALBOFF alrmsaveon?
0DB91=Converts hxs in C.W to real (only mantissa) (--> A.W=B.W=C.W )
0DB91=Uses SB, Sets decimal mode, clears carry
0DB9B=Multiplies A.W and C.W. (--> A.W=B.W=C.W)
0DBBC=Pops data for len P from D1, returns carry clear if 
0DBBC=crc following dat is ok
0DBF3=Pops data to A from D1 for lenght P, data being in front of D1
0DDA8=Internal ACKALL
0DDC1=Internal ACK (-> 1:T/F)
0DEAC=Put alarm in alarmlist ( {Alarms} {New} --> #n {NewAlarms})
0DECF=({} --> ) Stores internal alarms list, updating Alarms pointer
0DEF7=Store into 'Alarms' (1:Any)
0DF1E=recall 'Alarms' ->(2:contents,1:True/False)
0DF66=list element 2 is not a $ -> True/False
0E006=Displays time on HBUFF on row #8 (1:TICKS (HXS) )
0E029=Displays $ (coerced to 22) on HBUFF corner (1:$ )
0E047=Restore top 16 pixel rows (1:Grob)
0E047=Save top 16 pixel rows (-> 1:Grob)
0E0AB=Get HBUFF and SUBGROB coords for Statusarea
0E0D3=Get HBUFF and SUBGROB coords for Statusline1
0E0FB=Get HBUFF and SUBGROB coords for Statusline2
0E128=Get HBUFF and WINDOW coords (#0 #0 unless scrolled)
0E164=Called after adjusting clock
0E1D8=Convert internal alarm into external alarm (1:{} -> 1:{})
0E235=Recall internal 'Alarms' list 
0E248=( # --> )
0E302=Advances time if necessary (requires Rpt to exist)
0E3DF=Internal RCLALARM (1:%alarm number -> 1:{}) (Error if doesn't exist)
0E402=Recall N'th Alarm (1:#) -> (Alarm/True,False)
0E461=Insert object to lists nth position (3:{} 2:Ob 1:#n -> 1:{})
0E475={LAM_M LAM_N}
0E4DE=Remove nth object from list (2:{} 1:#n -> {} )
0E510=Internal STOALARM (1:% ->)
0E54D=Internal STOALARM (1:{} ->)
0E58E=(3:%date 2:%time 1:action)
0E5EF=(%date %time action %rpt --> )
0E630=Checks if stk1 is a valid date (Errors if not)
0E66A=Checks if stk1 is a valid time (Errors if not)
0E693=Checks if stk1 is a valid repeat factor (Errors if not)
0E6D4=ABS IP and check if TOS is valid repeat factor (Error if not) (1:%) 
0E6ED=(%date %time action %rpt --> )
0E724=%0 clears all alarms (CkDelAlarms)
0E724=Internal DELALARM ( %number --> ) (Error if doesn't exist)
0E76F=Internal DELALARM ( #alarm --> ) (Index not checked)
0E78D=Stores NULL{} in Alarms, Does RescanAlarms & CheckClock
0E925=Recall passed alarm (1:{alarms} -> 2:{alarm} 1:T / 1:F)
0E9B2=Recall next alarm (1:{alarms} -> 2:{alarm} 1:T / 1:F)
0EABE=Get alarm number (2:Alarm 1:{alarms} -> 1:#)
0EAD7=Internal FINDALARM (1:%alarm)
0EB31=Internal FINDALARM (1:{})
0EB81=Internal TICKS (->1:HXS)
0EB8B=Subroutine fo TICKS (1:HXS (len=13) -> 1:HXSTICKS)
0EBA8=Returns %alarm (%0 if alarms doesn't exist) (1:#alarm -> 1:%alarm)
0EBD5=(1:TICKS (HXS) -> 1:#alarm) (len{alarms} if not found)
0EBEE=if 'Alarms' list is not empty -> True/False
0EC07=(2:{alarms} 1:TICKS (HXS) -> 1:#alarm)
0EDA5=Create HXS 0 (16 nibbles)
0EDB9=create HXS 0 (13 nibbles)
0EDCD=create HXS 0 (24 nibbles)
0EDE1=allocate HXS (1:#nibbles -> 1:HXS 0)
0EDFA=If enough mem for 1 addr then nothing, else GARBAGECOL
0EDFA=NS:1GARBAGE
0EE26=(2:HXSdate 1:HXStime)
0EE50=date to ticks (%date --> hxs)
0EE83=time to ticks (1:% -> 1:HXS)
0EE92=Code: (2:HXS 0 (13 nibbles) 1:%date -> 1:HXS (ticks)
0EEB0=GETPTR, copies R0.13 to hxs body on stk1, Loop
0EED0=(1:% -> 1:HXS)
0EEDF=(2:HXS0(Ah) 1:% -> 1:HXS)
0EF45=(action %date %time %rpt --> {})
0EF72=(3:HXS0(18h) 2:%rpt 1:HXSdatetime)
0EFEE=8192		Ticks per second
0F003=491520		Ticks per minute
0F018=29491200	Ticks per hour
0F02D=707788800	Ticks per day
0F042=4954521600	Ticks per week
0F075=Allowed are all units with prefixes, no combinations otherwise
0F075=Is $ one Unit (1:$ -> 2:Unit 1:T / 1:F)
0F0ED=(2:% 1:$ -> 2:Un 1:True)
0F218=(1:Unit -> 1:$)
0F33A=Internal UNIT (2:% 1:Unit -> 1:Unit) (Replaces number part of Unit)
0F34E=Internal OBJ-> (1:Unit -> 2:% 1:Unit) (Unit is normalized)
0F371=(2:Unit1/% 1:Unit2/% -> 1:Unit)
0F371=Internal CONVERT Unit1 to units of Unit2 
0F3E4=Unit temperature^1 ? (1:HXS unitmask -> 1:T/F)
0F41B=Temperature conv (7:Dest unit 6-3:%%factors&%%values 2&1:TempMASK)
0F493=<< %%/ %%32 %%+ >>
0F4D4=<< SWAP %%32 %%- %%* >>
0F561=Convert and then strip units (Ex: 2:1_cm 1:1_m -> 2:100 1:1)
0F584=Internal == (2:%/Unit,1:%/Unit -> 1:%)
0F598=Internal <> (2:%/Unit,1:%/Unit)
0F5AC=Internal < (2:%/Unit,1:%/Unit)
0F5C0=Internal > (2:%/Unit,1:%/Unit)
0F5D4=Internal <= (2:%/Unit,1:%/Unit)
0F5E8=Internal >= (2:%/Unit,1:%/Unit)
0F5FC=Internal ABS (1:Unit -> 1:Unit)
0F615=Internal NEG (1:Unit)
0F62E=Internal SIN (1:Unit -> 1:Unit)
0F660=Internal COS (1:Unit -> 1:Unit)
0F674=Internal TAN (1:Unit -> 1:Unit)
0F6A2=Internal + (2:%/Unit 1:%/Unit)
0F774=Internal - (2:%/Unit 1:%/Unit -> 1:Unit)
0F792=Internal x* (2:%/Unit 1:%/Unit -> 1:Unit)
0F823=Internal / (2:%/Unit 1:%/Unit -> 1:Unit)
0F841=Internal INV (1:Unit -> 1:Unit)
0F878=Internal ^ (2:%/Unit 1:%/Unit -> 1:Unit)
0F8FA=Internal XROOT (2:%/Unit 1:%/Unit -> 1:Unit)
0F913=Internal SQ (1:Unit -> 1:Unit)
0F92C=Internal sqrt (1:Unit -> 1:Unit)
0F945=Internal UBASE (1:Unit -> 1:Unit)
0FA53={ 1_kg 1_m 1_A 1_s 1_K 1_cd 1_mol 1_? }
0FA62='k' 0x6B (Character)
0FB6F=Internal MAX (2:%/Unit 1:%/Unit -> 1:%/Unit)
0FB8D=Internal MIN (2:%/Unit 1:%/Unit -> 1:%/Unit)
0FBAB=Internal % (2:Unit 1:% -> 1:%)
0FC3C=Internal %CH (2:%/Unit 1:%/Unit -> 1:%)
0FCCD=Internal %T (2:%/Unit 1:%/Unit -> 1:%)
0FCE6=Internal SIGN (1:Unit -> 1:%)
0FCFA=Internal IP (1:Unit -> 1:Unit)
0FD0E=Internal FP (1:Unit -> 1:Unit)
0FD22=Internal FLOOR (1:Unit -> 1:Unit)
0FD36=Internal CEIL (1:Unit -> 1:Unit)
0FD4A=Does 'REVAL on units real part, then makes it a unit again (1:Unit)
0FD68=Internal RND (2:Unit 1:% -> 1:Unit)
0FD8B=Internal TRNC (2:Unit 1:% -> 1:Unit)
0FDE5=(1:Unit -> 4:Unit(same) 3:%%convfactor 2:%%sivalue 1:HXS unitmask)
0FE44=(1:Unit -> 3:%%n 2:%%cf 1:QHXS)
0FE44=Returns number,conversion factor and hex quantity string 
0FE53=U>NCQ for real numbers
0FF25=<< SWAPDROP %>%% HXS_0(16) >>
0FFAC=<< %>%% %%* HXS_0(16) >>
0FFF2=( ID --> ob TRUE / FALSE ) Works if ID is name of ROMPTR too
1003D=Dup, the U>nbr (UVAL)
10047=If Unit, then CARCOMP (UVAL), else nothing
10065=(2:%2_Unit 1:%1 -> 1:%1_Unit) else (SWAPDROP)
1008D=Explodes unit or % (without % )
100B5=Explodes unit (without %)
100D3=Meta unit to unit
104DB=(2:HXS(16) 1:# -> 1:HXS), pops # into low 2 nibbles, then << left
10ADB=(Ob Meta1 Meta2 -> Meta1 Meta2 Ob)
10AF9=(Meta1 Meta2 Ob -> Ob Meta1 Meta2)
10B5E=x* (unit operator)
10B68=/ (unit operator)
10B72=^ (unit operator)
10B7C=Character prefix (unit operator)
10B86=_ (unit operator)
10E34=HXS 0 (16 nybbles for Unit calculations)
10E4E=Temperature^1 mask (100000000h) (16 nybbles)
10E68=5/9 (C <-> F conversion)
10E82=1
10E9C=273.15		(0C in Kelvins)
10EB6=459.67		(0F in R)
10F54=Error: Can't Edit Null Char.
10F64=Error: Invalid User Function
10F74=Error: No Current Equation
10F80=Invoke error code in C.A
10F86=Error: Invalid Syntax
10F96=Error: Invalid PPAR
10FA6=Error: Non-Real Result
10FB6=Error: Unable to Isolate
10FC6=Error: HALT Not Allowed
10FD6=Internal KILL
10FE6=Error: LAST STACK Disabled
10FF6=Error: LAST CMD Disabled
11006=Error: Wrong Argument Count
11016=Error: Circular Reference
11026=Error: Directory Not Allowed
11036=Error: Non-Empty Directory
11046=Error: Invalid Definition
11056=Error: Missing Library
11066=Error: Name Conflict
11076=Internal CONT
11086=Configuration code for library 001 (XLIB 1)
110DB=Clear UserKeys and UserKeys.CRC
111AD=Fetches current char to B.B, D0=loc
111FD=Sets carry if B.B=10 (newline) or B.B=0
1121B=Sets carry if '0' <= B.B <= '9'. Uses C.B
112EC=Clear Last Arguments (Executed if LASTARG flag is cleared)
1137B=Sets annunciator data at 706C3 (OR with C.B)
113B0=Recalls annunciator data from 706C3 to A.B (D0=706C3)
113C2=get Stack Size (nibbles) as #
113F2=Gets first #line of the edit lines displayed ( -> 1:#)
11432=Gets position of first char shown
11481=Push @A.A as #, Loop
11501=Alpha lock on?
11511=if PRG mode -> True/False
1158F=Internal BLANK (2:#x 1:#y -> 1:Grob)
115B3=R0.A = x, R1.A = y -> D0 = grob body (true addr by - 20d)
11642=Compute grob y nibble
1165A=Compute grob nibble
11679=Store grob1 into grob2 (4:Grob1 3:Grob2 2:#col 1:#row -->)
116B5=R0,R1 = (row,col), D0 = grob1, D1 = grob2 -->
1192F=(5:Grob 4:#x1 3:#y1 2:#x2 1:#y2 -> 1:SubGrob)
11A58=Pops old stk1 into D1 (Uses C, D1)
11A6D=Clear a rectangular region (5:Grob 4:#x1 3:#y1 2:#x2 1:#y2 -> 1:Grob')
11BAA=Else x1,y1,dx,dy = R4,R2,R0,R1 and carry clear
11BAA=Pops x1,y1,x2,y2, SAVPTR. Returs carry set if x2<=x1 or y2<=y1
11BED=Sets carry if GROB in D1 is null (length <= 15)
11C06=Clears carry if x1,y1 (R4,R2) exceeds grob bounds (in D1)
11C29=Sets dx and dy so that grob bound are not exceeded
11C58=Computes grob nibble (D1 = grob, x1,y1 = R4,R2)
11CCC=Sets XM with RTNSXM
11CF3=Make grob in 5x9 font (1:$ -> 1:Grob)
11D00=Make grob in 5x7 font (1:$ -> 1:Grob)
11D8F=Writes string of length C.A (chars) to D0
11EFF=Skips back 1 row in grob (Medium/Big font according to XM)
11F1D=Sets char size (lines) to C.S according to XM
11F2E=A.B = chr --> C.A=addr (XM determines font)
11F2E=Gets address in character-rom 
11F80=Make grob in 3x7 font (1:$ -> 1:Grob)
1200C=Make grob of #n rightmost rows (height 6) (2:$ 1:#n -> 2:T/F 1:Grob)
1215E=#x is the max x that $ may reach in the grob
1215E=#y is ??
1215E=Place $ in grob (5:Grob 4:#x 3:#y 2:$ 1:#len -> 1:Grob)
1215E=len is the max lenght of $ taken to the grob.
122FF=Inverts grob (1:Grob -> 1:Grob')
123C8=Disp in 5x9 font at #row (2:$ 1:#row) (Truncates or fills to 22 chars)
123E5=Disp in 5x9 font at row 4 (1:$) (Truncates or fills to 22 chars)
123F5=Disp in 5x9 font at row 3 (1:$) (Truncates or fills to 22 chars)
12405=Disp in 5x9 font at row 2 (1:$) (Truncates or fills to 22 chars)
12415=Disp in 5x9 font at row 1 (1:$) (Truncates or fills to 22 chars)
12429=Disp in 5x7 font at #row (2:$ 1:#row) (Truncates or fills to 22 chars)
1245B=Disp in 5x7 font at row 1 (1:$) (Truncates or fills to 22 chars)
1246B=Disp in 5x7 font at row 2 (1:$) (Truncates or fills to 22 chars)
1247B=Disp in 5x7 font at row 3 (1:$) (Truncates or fills to 22 chars)
1248B=Disp in 5x7 font at row 4 (1:$) (Truncates or fills to 22 chars)
1249B=Disp in 5x7 font at row 5 (1:$) (Truncates or fills to 22 chars)
124AB=Disp in 5x7 font at row 6 (1:$) (Truncates or fills to 22 chars)
124BB=Disp in 5x7 font at row 7 (1:$) (Truncates or fills to 22 chars)
124CB=Disp in 5x7 font at row 8 (1:$) (Truncates or fills to 22 chars)
124CB=Requires menu off to be visible
12635=Get current display (-> 1:Grob)
12645=Get menu grob (-> 1:Grob)
12655=Get stack grob (-> 1:Grob)
12665=Get graphic grob (PICT) (-> 1:Grob)
12671=Push address at C.A, Loop
12690=Resets DISPSTARTADDR and both offsets for display
126DF=Clear #rows starting at #startrow in HARDBUFF (2:#startrow 1:#rows ->)
1270C=Display at status area lines (1:$ ->) (Only 1st newline changes line)
12725=Display at row1 in HARDBUFF window (1:$ ->)
12748=Display at row2 in HARDBUFF window (1:$ ->)
12770=If len($) > 22 chars, truncates it to 21 chars & "..." (1:$ -> 1:$')
127A7=Split $ at first <LF> (1:$ -> 2:$end 1:$start / 2:"" 1:$)
12815=Sto $ in grob2 (4:grob2 3:#row 2:#col 1:$ -> 2:grob2 1:grob')
12829=Sto grob1 in grob2 (4:grob2 3:#row 2:#col 1:grob1 -> 2:grob2 1:grob')
12847=Draws blank vertical lines to separate menu keys
128B0=Enlarges HARDBUFF if grob exceeds bounds
128B0=Stores grob into HARDBUFF (3:#row 2:#col 1:Grob ->) 
128BA=(3:Grob 2:#row 1:#col -> 3:Grob 2:#row 1:#col)
128BA=Enlarges HARDBUFF ydim if storing grob would exceed bounds
128E3=(3:Grob 2:#row 1:#col -> 3:Grob 2:#row 1:#col)
128E3=Enlarges HARDBUFF xdim if storing grob would exceed bounds
12964=Heightens HARDBUFF with #rows (1:#rows ->)
1297D=Broadens HARDBUFF with #cols (1:#cols ->)
12996=#1-#3 are safe to try directly. Bigger requires bigger HARDBUFF too
12996=(1:#n ->) Moves #n Stack levels up one line (not status area)
129D1=D.1 has some factor (Font size negated?)
129D1=Moves A.A lines (normal size dims!) from D1 to D0
12A0D=(No args) Moves stack lines in HARDBUFF up ~ 1/2 lines
12A4A=(1:#n ->) Moves #n Stack levels down one line (not status area)
12B58=Get HARDBUFF width (-> 1:#width)
12B6C=Get HARDBUFF height (-> 1:#height)
12B85=Flashes message on status area (1:$ ->) (Doesn't beep)
12BB7=Broadens graphic or text GROB with #columns (2:GDISP or ABUFF 1:#col)
12DD1=Heigtens graphic or text GROB with #rows (2:GDISP or ABUFF 1:rows)
12E89=Stores grob in GBUFF (1:grob ->) (GDISP is current)
12F0A=Stores grob in GBUFF (1:grob ->) (GDISP not current)
12F94=Stores grob to GBUFF (1:grob ->)
13075=Purges grob at address @R0.A
130AC=Choose TEXT grob, clear text display, default size (131 56)
130CA=Resize VDISP to std size (131x56)
13135=Choose graphic display (GBUFF)
1314D=Choose text display (ABUFF)
13167=Is GDISP current display? (-> 1:T/F)
13197=Carry set @GDISP = @VDISP. If not @GDISP=@PDISP either then Warmstart
133AB=Update VDISPSTART and VDISPEND
133B6:D1=->LINEOFFSg
133C3:Force even address
133E1:C.B = linecount
133E4:Clear M32
133E9:Clear DA19
134AE=Clears HARDBUFF
13679=JUMP GROB to (2:#x 1:#y)
13695=Put window at #0 #0 coords
136AA=Sets scrolling coordinates to A.A and C.A
137B6=Push window coords (-> 2:#x 1:#y) , zeros if not scrolled
1380F=Clear pixel in graph grob (2:#x 1:#y ->)
13825=Set pixel in graph grob (2:#x 1:#y ->)
1383B=Clear pixel in text grob (2:#x 1:#y ->)
1384A=Set pixel in text grob (2:#x 1:#y ->)
138CA=If ST 0 is set, pixoff, else pixon
138EF=pixloc for ADISP
138F2=--> A.P contains nibble, D0 = addr, B.P = ornibble
138F2=Calculates location of pixel (x,y = A.A, R0.A) (No boundary checks)
138F2=If ST 1 is set ADISP is used, else GDISP
13986=Is graph grob pixel on? (2:#x 1:#y -> 1:T/F)
13992=Is text grob pixel on? (2:#x 1:#y -> 1:T/F)
139E7=(#y #x #lenght)  Inverts area in VDISP (medium chars, stack lines)
13B51=Also updates CursorX and CursorY (char #row --> )
13B51=Updates current character to CurChar and CharGrob
13BB5=Stores current character to CurChar
13BF1=( #yloc --> ) Update CharGrob, CursorX and CursorY
13BF1=(#row --> )
13CE2=If BlinkOk? then BlinkCrs 
13CFB=If BlinkOk? then BlinkChr
13D28=Draws insert/normal cursor according to InsMode? Toggles CursorStatus
13D8C=insert cursor (Graphic 6 x 10)
13DB4=overstrike cursor (Graphic 6 x 10)
13DCC=(--> D1=@VDISP, R0=CursorY, C=R1=CursorX) (Input for grob!)
13DD5=Draws character over cursor (stored to CharGrob). Toggles CursorStatus
13E05=Sets Blink=8
13E22=Sets CursorStatus (Char is drawn at cursor)
13E2E=Cleard CursorStatus (Cursor is drawn)
13EF1=Gets the number of the char on cmdline (-> 1#) (70704)
13F47=Get position (line) of the cursor in the command-line (-> 1:#)
13FB0=Sets CursorLine=EditParts+1
13FE5=Saves last Error code (ERRN to LASTERRN)
1400E=Internal ERR0 (Clears LASTERRN and EXITMSG)
14039=ERRN (Returns LASTERRN) ( -> 1:#error)
1404C=Internal ERRN (Returns LASTERRN) ( -> 1:HXS)
14065=Internal ERRM (Returns LASTERRN message) ( -> 1:$)
14088=:: ZERO !DcompWidth DTYPECSTR? ?SEMI >STR ;
14088=Internal ->STR (Topmost) (1:Any -> 1:$)
140AB=Internal DISP (2:Any 1:%)
140F1=Internal CHR (1:% -> 1:$)
1410F=Internal NUM (1:$ -> %) (Takes first char of $, then NUM)
14137=:: palparse case EVAL 2DROP SETSyntaxERR ;
14137=Internal STR-> (Topmost) (1:$) (Errors if parsing failed, else EVALs)
1415A=Internal BEEP (2:%msec 1:%Hz)
141B2=Internal BEEP (2:#msec 1:#Hz) (#Hz is 1000*%Hz in DOBEEP)
1420A=Internal > (2:$ 1:$ -> 1:1/0)
142A6=Internal < (2:$ 1:$ -> 1:1/0)
142BA=Internal >= (2:$ 1:$ -> 1:1/0)
142E2=Internal <= (2:$ 1:$ -> 1:1/0)
142FB=Internal FREEZE (1:%) (Does SetDA?Temp's)
14378=Internal HALT (If NOT haltOK? then error) (DBUGs ob in return stack)
143BB=Forces halt, no error protection, saves stack if LastStkOn? 
1444C=Resumes & stores LastStkOn flag from LAM_'halt & ABND
1446F=Checks if halt is allowed (AppSuspOK? and LAM_'nohalt) (-> 1:T/F)
144AC=The program executed when NEXT is pressed in PRGDBUG menu
144DE=The program executed when SSTdown is pressed
14506=The program executed when SST is pressed
14533=#2 = NEXT, #1 = SSTdown, #0 = DOSST (1:#n)
14565=Removes until 143DE (Halt errtrap), overwrites it with next
14565=Thus ticR will give the next command of the prg debugged
14565=which is the program debugged
145BA=Returns True if end of whole program reached
14843=(Ob -> "XLIBNAME" / Ob)
148C0=Recalls next from prev. converts to string and adds to tail (with
148C0=space) (1:$ -> 2:Ob 1:$+" "+$Ob)
149C4=(Ob -> #1 "XLIBNAME" / #1 Ob)
14C17=Displays $ in status area (" " added in front) and freezes st. area
14CA8=Does a seco of next 2 obs, returns & does GsstFIN
14D8C=Adds space in front of $, displays it in status area and freezes it
14DFA=Displays and evals stk1, then continues DBUG
14E1D=End marker for debugger (:: NOP ;)
14E1D=Note that >R advances 5, thus compared address is 14E22
14E2C=DROP, display and eval next in return stack, continue DBUG
14E54=If 1st LAM is SAVELAM (Saved stack) ABND 
14E6D=If 1st LAM is SAVELAM, True, else False
14EA5=DUPs return stack
14ED6=        GONC   NoGarbage
14ED6=        GONC   Sub1
14ED6=        GOSBVL Garbage1	* does ST=1 10
14ED6=        ST=0   10
14ED6=Garbage collect (Does SAVPTR) Usage:
14ED6=NoGarbage [Anything]
14ED6=Sub1    D=D-1  A
14EEC=Gives the return stack depth after starting DBUG
14F2A=Example: :: :: :: :: ##3 RROLL ; %1 ; %2 ; %3 ; -> %3 %2 %1
14F2A=Rolls nth return stack level to top ( ##1 -> do nothing )
14F8C=Drops halt error trap and top level duplicate from return stack
14FC3=Creates loop if debugging START etc
15007=Internal DOERR (1:%) (Does AtUserStack)
1501B=Internal DOERR (1:HXS) (Does AtUserStack)
1502F=Internal DOERR (1:#) (Does AtUserStack)
15048=Internal DOERR (1:$) (Does AtUserStack)
1506B=if ''halt' (LAM) exists -> True/False
1508E=The program executed when DBUG is pressed
150C0=Starts debugger for a secondary (If in hardrom, error)
150E3=Starts debugger for a secondary (No hardrom checks)
15106=:: RSWAP RSKIP RSWAP ;
1515B=If stk1 not seco then Ob>Seco (1:Any) (Supported entry at 63FCE)
15174=Decompiles stk1 into a $. Max length is one line.
1518D=Jumps to rpl at 146DB, ie drops traps and creates start mark
151A6=(Sets SolvMenuNSprg,..LSprg,..RSprg,..LabelDefprg,..ReviewKeyprg)
151A6=Sets keypress programs, labeldef and review programs & calls 3BB19
15232=Checks for { Ob { Anything } } (-> Error or { Anything }
152D2=Add #n times NullMenuKey to tail of composite (2:Comp 1:#n)
152FF=Accepts: { Any NOT{} Any Any....} and { Any }
152FF=Is {} a valid EQ ? (1:{} -> T/F)
15366=Does CKIDValidForSolv for CARCOMP (1:{ID ...} -> 1:contents / Error)
15389=(1:ID -> 1:contents if valid for solve, 1:ID & error if not valid)
15389=Other than ID does nothing
153C0=Displays current dir page ids & contents (CAT style)
153D9=Displays current dir page (CAT style, but no EQ nor blanking)
153FC=If ID then display it & contents at row INDEX@+#1, else drop
15424=Example (2:ID_CDE 1:"ABC" -> "CDE: ABC")
15424=Tags $ with ID/LAM (8 first chars only) as string (2:NAME 1:$ -> $)
1548C=For ID & NULL$: MakeInvLabel Grob>Menu,  Else: >Menu
154CD=Handles pressed (no shift) SOLVE menu key (1:Ob)
154FA=Prg to handle ID in SOLVE menu
1552C=Recall ID contents, then KeepUnit (If no contents, DROP) (1:ID)
1553B=(3:% 2:Any 1:Unit -> 2:%_Unit 1:Ob) else DROP
1559A=Does StdMenuKeyRS or DoNameKeyRS depending on stk1 (other/ID)
155EF={ LAM 'nohalt }
1568F=Is stk1 an equation? (1:SYMB -> 1:T/F) 
15694=Only symb gives true. BUG (?)
15717=Internal STEQ (1:Any) (Doesn't strip tags like xSTEQ)
1572B=Internal RCEQ (Error if not present) (-> 1:EQ contents)
15744=Internal RCEQ -> Contents,True/False
15758=unevaluated 'EQ' (ID)
15777=unevaluated '' (ID)
1578D=Internal ->NUM ( :: CK1 STRIPTAGS CRUNCH ; )
157B0=Doesn't set NumFlag before ->NUM, but clears it after
157E2=Doesn't set NumFlag before ->NUM, but sets it after
1583C=EVAL & if depth <> 0 then CRUNCH
1587D=Does the same as pressing EXPR= (-> 1:EXPR:.. / 2:LEFT:.....)
1589B=Divides ALG into left & right parts & tags (1:ALG)
1592D=:: 0LASTOWDOB! CK1NOLASTWD ;
1592D=Clear current command and verify DEPTH >= 1
15941=== :: EVALCRUNCH CK1NoBlame ;
15955=(2:#linenumber 1:Ob -> 1:$)
1596E=(3:#linenumber 2:Ob 1:#decompilewidth -> 1:$)
15978=Decompile into $ in print format (1:Obj -> 1:$)
159FA=Sets 19 as DcompWidth (1 line)
15A0E=Decompile obj for editing (1:Obj -> 1:$)
15A40=Handles error if edit decompiling failed ( :: rstfmt1 ERRJMP ; )
15B13=Decompile obj for stack display (1:Any -> 1:$)
15B31=Deep internal ->STR (1:Any -> 1:$)
15B3D=Deep internal ->STR (1:Any -> 1:$) (Edit format)
15C5F=Converts stk1 to a string using dispatch data in RSTK
15C5F=Last pointer must be 00000 (Which leads to Type$)
15C5F=See >STR and >STREDIT for examples of how to use
15CBB=Get object type description (1:Any-> 1:$) (Ex.1:%1 -> 1:"Real Number")
15CBB=Gives "Complex Array", if array type isn't real (feature)
15CCF=Get object type and concatenate (1:$ 1:Any -> 1:$)
15D06=(1:# -> 1:$) For stack display & editing
15D38=(1:LIB -> 1:$) For stack display & editing
15D79=(2:$ 1:#msgno -> 1:$mesg+" "+$)
15D97=(1:BAK -> 1:$) For stack display & editing
15DBF=Add grob dims to string (2:Grob 1:$ -> "ydim$xdim" )
15DF1=(1:GROB -> 1:$) For stack display
15E1F=(1:GROB -> 1:$) For editing (Uses GROB>DISP$ if Stack$?)
15E83=Makes a nibble string of a sized object (1:HXS/$... -> 1:$)
15EAB=(2:$2 1:$1 -> 1:"$1len($2) $2") (Ex. 2:"ABC" 1:"CDE" -> 1:"CDE3 ABC")
15ED8=(1:$ -> 1:$) (For editing. If Stack$? then uses $>DISP$)
15F3D=(1:$ -> 1:$) (For stack display)
15F83=(1:HXS -> 1:$) (For editing. If Stack$? then HXS>$)
15F83=DeBinary and Binary are not compatible. "C# " is not recoginized
15F83=by palparse (feature)
15FCF=$ Lenght not checked
15FCF=Copies body of a sized object into a string (Ob $ --> $ )
1605F=(1:$ -> 1:"'$'")
1606C=(1:$ -> 1:""$"")
16075=Puts C.p2 (Char) around $ (1:$ -> 1:$) & continues RPL
160D1=Differs from ID>$ by adding quotes too (1:ID/LAM -> 1:$)
160E5=(1:ID/LAM -> 1:$) If ST.4 clear ID>$ else ID>DISP$ (quotes too)
16103=(1:Unit/Symb -> 1:$) For stack display
1613F=Null $ "" (RAM based)
16153=(Ob -> "XLIBNAME" / "Type")
1616C=Returns XLIB name or "XLIB % %" (1:XLIB -> 1:$)
161D0=(1:DIR/seco/TAGGED/[]/{}/Unit/SYMB -> 1:$) (For editing)
1622A=(1:DIR/seco/TAGGED/[]/{} -> 1:$) (Like what's on stack)
162AC=Convert % to $ using current display mode with no commas (FIX mode)
162B8=Convert % to $ using current display mode (1:% -> 1:$)
1633D=if ST=1 10 then GPMEMERR, else ST=1 10 and GARBAGECOL
16671=Shrink string which is topmost in tempob area
16671=(If not topmost then everything after it will be lost)
16671=Input: R0.A = ->String  D0 = ->stringend (the shrinked one)
16671:A.A = ->strend
16677:C.A = ->String
1667A:C.A = ->StrLen
16680:R1.A = ->StrLen
16686:C.A = ->StrLen
16689:D1 = ->StrLen
1668C:C.A = ->strend - ->StrLen
1668E:Set len lenght
16691:C.A = ->String
16694:A.A = ->strend - ->String = size
16696:size += 6 (tempob offset + mark)
1669C:Set new offset in tempob
1669F:Skip to mark (new temptop)
166A2:C.A = ->mark
166A5:D.A = ->mark
166B5:A.A = ->temptop
166B8:Set new temptop
166BB:D0 = ->temptop
166BE:C.A = ->temptop - ->newtemp
166C0:B.A = movesize
166C2:C.A = ->rettop
166E3=Internal FIX (1:# ->)
166EF=Internal SCI (1:# ->)
166FB=Internal ENG (1:# ->)
16707=Internal STD
167BF=Flag -51 clear? (-> 1:T/F)
167D8=# to decimal $ & ": " (1:# -> $)
167E4=# to decimal $ (1:# -> 1:$)
16837=Makes a digit string of length C.A from R1 (hex to decimal)
1685C=(2:$ 1:#line -> 1:"N: $") Sets 19 as DCompWidth first
1686A=(2:$ 1:#line -> 1:"N: $") (DCompWidth is obeyed)
16969=DcompWidth of one display line (#13)
16973=Is stk1 1D 2 or 3 element real vector? (1:[] -> 2:#dim 1:T / 1:F)
169E1=(2:COMP 1:{start data} -> 2:$ 1:LeftData{})
169E1=Parses composite for 1 line. start data = { #loc hxs?? } or { }
169FA=Stores # as decompile width, doesn't do ClrPrint$
16A0E=Stores 19 as decompile width first
16CA7=Error: Bad Argument Value
170B8=(2:#n 1:$ -> 2:#n if #n=0 then 1:$+"[" else 1:$+" " )
1746E=(1:C% -> 1:$) (Display & edit versions are the same)
17518=(2:C% 1:{} -> 2:$ 1:{})
177B6="  " EQ (1:$ -> 1:T/F)
177CA=(2:$1 1:$2 -> 2:$1&$2 1:TRUE / 2:$1 1:FALSE)
177CA=If !append$ would give LEN($) > DcompWidth, don't !append$
1782E=(2:$2 1:$1 -> 3:$2 2:$1 1:#len1+#len2)
178E2=Actually adds 2
17914=If parsing for stack display (Stack$?), don't indent
1792D=!insert$ @Indent (7074F) spaces (1:$ -> 1:$)
1795A=Store maximum string compile length into DcompWidth (70770)
17980=Recall maximum string compile lengthfrom DcompWidth (70770)
179AC=Is GROB #xdim == #1 ? (1:Grob -> 1:T/F)
179D0=Get variable contents (2:DIR 1:# ) ???
17B86=Systems ERRORTRAP program
17C6A=Routine started in Memory Out situations (Asks whether to purge stuff)
17D46=ABND, CACHE 0 args to SAVELAM
17EBB=:: IT 2DROP 2RDROP 2RDROP ;
180D8=:: IT DROP 2RDROP 2RDROP ;
181FA=If #1, TRUETRUE, If #6 FALSETRUE else FALSE
18242=Returns TRUE if LastCmd = 0 (-> 1:T/F)
18308=Do GC and recalculate stack (Handles DSKBOT STACKMARK)
18338=If D>50 after GARBAGECOL then TRUE, else FALSE
18397=(1:contents -> 1:$Name / NULL$) ("0:" put in front of LIB/BAK names)
183C4=Returns "0:" + $name (1:LIB/BAK -> 1:$)
183EB=Returns name as $ (1:LIB/BAK -> 1:$)
18404=(1:contents (not LIB/BAK) -> 1:$name / NULL$) 
1848C=Internal PATH (-> 1:{})
184E1=Internal CRDIR (Purges original if there is one) (1:ID ->)
184FA=If DIR then Error: Directory Not Allowed (1:Any ->)
18513=Internal STO (2:Any,1:ID)
18536=(1:ID -> 3:ID 2:contents 1:True | 2:ID 1:False)
18536=Search is restricted to current directory
1853B=Internal RCL (1:LAM/ID -> 2:contents 1:T / 1:F)
1853B=Search is restricted to current directory
1854F=Internal PURGE (1:ID ->) (Doesn't error if ID not used)
1856D=Checks if rrp can be purged with xPURGE
18595=Internal PGDIR (1:ID ->) Checks references etc too.
185C7=Saves CONTEXT, Evals next, resumes CONTEXT (even if 'REVAL errors)
18608=Errors if DIR is not empty (1:DIR ->)
18621=Returns LASTRAM-WORD, if TRUE then CkNonNull, else FALSE
1863A=Returns PREVRAM-WORD, if TRUE then CkNonNull, else FALSE
18653=(ob --> ob TRUE / FALSE )
1867F=               or   pred id_contents {} ob FALSE
1867F=( any pred --> {} )
1867F=At pred evaluation: pred id_contents {} id 
1867F=Example: DOVARS uses does TrueTrue before DODIRPRG
1867F=Executes a program on all current directory variables
1867F=If TRUE then ob is added with >TCOMP, else DROP
1867F=To be returned:     pred id_contents {} ob TRUE
186E8=Internal TVARS (1:%)
18706=Internal TVARS (1:List)
18742=Program passed by TVARS to DODIRPRG (with { %type .. } on stk 2)
18779=Internal VARS (-> 1:{})  ( :: TrueTrue DODIRPRG ; )
187AB=Returns TRUE if 2 last character of ID are 'EQ' (id --> id flag)
18802=(Ex: :: 1 2 + LASTCMD@ ; <EVAL> ->  2:3 1:+)
18802=Returns last command saved (-> 1:Cmd) (-> 1:#0 if last cmd cleared)
1884D=Clears the command save done by the last CK<n>
18873=Internal AND (2:$,1:$)
18887=Internal OR (2:$,1:$)
1889B=Internal XOR (2:$,1:$)
188AF=If copy len($1) = len($2), then NEWOB/SWAP, else Bad Argument Value
188D2=Internal NOT (1:$)
188E6=Deep internal AND (2:$,1:$) (Doesn't NEWOB)
188F5=Deep internal OR (2:$,1:$) (Doesn't NEWOB)
18904=Deep internal XOR (2:$,1:$) (Doesn't NEWOB)
18961=Deep internal NOT (1:$ -> 1:$) (Doesn't NEWOB)
18A01=Configuration code for library 002 (XLIB 2) (:: #2 HOMEATTACH ;)
18A15=Save stack size and clear CKARGNM
18A1E=Save current command, stack size, clear CKARGNUM
18A5B=Save current command and verify DEPTH >= 3
18A68=Verify DEPTH >= 3
18A80=Save current command and verify DEPTH >= 2
18A8D=Verify DEPTH >= 2
18AA5=Save current command and verify DEPTH >= 1
18AB2=Verify DEPTH >= 1
18AC6=MC: verify DEPTH >= C.S, expect P = 2*C.S - 1
18B6D=Save current command and verify DEPTH >= 5
18B7A=Verify DEPTH >= 5
18B92=Save current command and verify DEPTH >= 4
18B9F=Verify DEPTH >= 4
18C34=Save current command, check args, R->SB and verify stk1 < DEPTH-1
18C4A=Check args, R->SB and verify stk1 < DEPTH-1
18C77=Saves current command (pointer to it)
18CD7=(1:% -> 1:#)
18CEA=Internal R->SB (1:% -> 1:#)
18DBF=Internal SB->R (1:# -> 1:%)
18E18=(Other args do nothing, ATTN works) (Doesn't check NumFlag!!!)
18E18=Do COMPEVAL to ALG until it isn't ALG anymore 
18E45=If level1 not algebraic, SEMI
18E7E=Maybe slightly faster than DUPTYPESYMB? dunno
18EBA=Internal EVAL (1:Composite)
18ECE=Save current command, verify DEPTH >= 1 and check args.
18EDF=Save current command, verify DEPTH >= 2 and check args.
18EF0=Save current command, verify DEPTH >= 3 and check args.
18F01=Save current command, verify DEPTH >= 4 and check args.
18F12=Save current command, verify DEPTH >= 5 and check args.
18F23=      CK&DISPATCH1 is started, else 1st command is skipped
18F23=Evaluate composite (command) without saving as current command
18F23=Example: :: ' x+ EvalNoCK ; doesn't save + command, but EVALs it
18F23=NOTE: If the first command in stk1 is CK<n>&Dispatch then
18F23=NOTE: Stk1 must be a composite since prolog is ignored
18F6A=Evaluate next command without saving as current command
18F6A=Example: :: EvalNoCK x+ ; doesn't save + command, but EVALs it
18F9D=Check arguments for type (doesn't strip tags if no match)
18FA9=Same as CK&DISPATCH1 (??)
18FB2=Check arguments for type (strip tags if no match)
191B9=(2:# 1:# -> 1:#) Multiplication with #FFFFF as max result
19207=(1:#n 2:Any 3:%/C%...N+3:%/C% -> 1:%0 or C%0 2:Any....)
19207=Check stack for #n %/C% , Error if not
19294=->ARRY (1:[%/C%] 2:#n 3:%/C%...N+3:%/C% -> 1:[%/C%])
19294=Stk3 will go to the last element. #n can be < #elements
19350=Stk1 not in HP48SX ROM ? (addr>70000) (ob --> ob flag)
1936C=(id --> id ob)
1936C=Recall ID, error if not found (id --> id ob)
19385=Recall ID contents, error if not found (id ob1 --> id ob1 ob)
193A3=Recall ID contents, error if not found (id ob2 ob1 --> id ob2 ob1 ob )
193C1=If not array, then SETTYPEERR (ob --> ob)
193DA=Errors if not above argument, or if either real coerced is 0
193DA=List of 1 or 2 % to list of # (1:{ % (%) } -> 1:{ # (#) }
19402=(1:% -> 1:{ # } )  #0 causes SIZEERR
19443=If not list, then SETTYPEERR (ob --> ob)
1945C=(2:Comp 1:#prolog -> 1:Comp)
1945C=Error if list elements not #prolog types or if NULLCOMP
19489=(3:#prolog 2:#n 1:Ob (of prolog type) -> 2:#prolog 1:#n+1)
19489=If not of prolog type then Error (Ob replaced with True) 
194BB=Verify Real Array (ob --> ob), error if not
194D9=Verify complex Array (ob --> ob) error if not
194F7=(2:%2 1:%1 -> 2:#2 1:#1)
1950B=(2:#2 1:#1 -> 2:%2 1:%1)
19529=List of # to List of % (1 or 2 elements) (1:{#1 (#2)} -> 1:{%1 (%2)})
19538=(1:# -> 1:{ % })
1957B=ASR (XLIB 2 0)
1959B=RL (XLIB 2 1)
195BB=RLB (XLIB 2 2)
195DB=RR (XLIB 2 3)
195FB=RRB (XLIB 2 4)
1961B=SL (XLIB 2 5)
1963B=SLB (XLIB 2 6)
1965B=SR (XLIB 2 7)
1967B=SRB (XLIB 2 8)
1969B=R->B (XLIB 2 9)
196BB=B->R (XLIB 2 10)
196DB=CONVERT (XLIB 2 11)
1971B=UVAL (XLIB 2 12) H:000
1974F=UNIT (XLIB 2 13)
19771=UBASE (XLIB 2 14) H:000
197A5=UFACT (XLIB 2 15)
197C8=Internal UFACT (2:Unit 1:Unit -> 1:Unit)
197F7=TIME (XLIB 2 16)
19812=DATE (XLIB 2 17)
1982D=TICKS (XLIB 2 18)
19848=WSLOG (XLIB 2 19)
19863=ACKALL (XLIB 2 20)
1987E=ACK (XLIB 2 21)
1989E=->DATE (XLIB 2 22)
198BE=->TIME (XLIB 2 23)
198DE=CLKADJ (XLIB 2 24)
198FE=STOALARM (XLIB 2 25)
19928=RCLALARM (XLIB 2 26)
19948=FINDALARM (XLIB 2 27)
19972=DELALARM (XLIB 2 28)
19992=TSTR (XLIB 2 29)
199B2=DDAYS (XLIB 2 30)
199D2=DATE+ (XLIB 2 31)
199EB=Toggles Clock display flag (-40), calls P0CEB9
19A04=Toggles date format flag (-42)
19A18=Toggles 24 hour clock flag (-41)
19A2C=Advances default alarm 12 hours and prompts for alarm
19A54=Internal A/PM (Does CheckClock)
19A68=Recalls ID_ALARMDAT or gives { %date %0 "" %0 }
19A91={ %0 "" %0 } date must be added to head
19ADE=Toggles AM/PM hour (1:% -> 1:%+12 MOD24) 
19B06=Sets default alarm & starts time menu
19BE8=Checks for real, valid time, & starts alarm prompt with that time
19C06=Checks for valid time, & starts alarm prompt with that time
19C56=Checks for %, multiplies with %TICKSweek, takes ABS IP, checks if
19C56=is a vaild rpt factor, stores it & starts alarm menu (1:%rpt)
19C74=Doesn't check for rpt being real
19D50=Multiplies % with %rptfactor, checks it & starts alrm menu with it
19D73=Stores ALARM message (1:$ ->)
19D8C=Gets stored ALARM message string (-> 1:$)
19DAA=Stores Ob to nth (max 4) position in DefaultAlarm and prompts 
19DAA=for alarm (2:Ob 1:#1-4 -> 1:Inputted stuff)
19DE2=Displays next alarm if MSGNOTOK? is false, else SetDA2NoCh
19DF6=Displays next alarm
19E0F=Displays a passed alarm (1:{alarm})
19E9B=Displays alarm & message (2:{alarm} 1:$message ->)
19EFA={ %TICKSweek ... %TICKSsec %1 }
19F6B={ " weeks(s)" ... " ticks" }
1A031=If MSGOK? asks for alarm (-> 1:inputted)
1A040=Asks for alarm (-> 1:inputted)
1A0E0=Flashes "Acknowledged" message
1A105=CRDIR (XLIB 2 32)
1A125=PATH (XLIB 2 33)
1A140=HOME (XLIB 2 34)
1A15B=UPDIR (XLIB 2 35)
1A16F=Internal UPDIR ( :: CONTEXT@ GETUPDIR NOT?SEMI CONTEXT! ; )
1A194=VARS (XLIB 2 36)
1A1AF=TVARS (XLIB 2 37)
1A1D9=BYTES (XLIB 2 38)
1A1FC=Internal BYTES (1:Any except ID)
1A20B=Internal BYTES (1:HARDROM object -> 2:HXS0000 1:%2.5)
1A23D=BYTES (1:ram-object -> 2:HXScrc 1:%size)
1A265=Internal BYTES (1:ID ->2:HXScrc 1:%size)
1A2BC=NEWOB (XLIB 2 39) (:: CK1 INHARDROM? ?SEMI TOTEMPOB ;)
1A2DA=Obj in HARDROM? (addr<70000) (1:Ob -> 2:Ob 1:T/F)
1A303=KILL (XLIB 2 40)
1A31E=OFF (XLIB 2 41)
1A339=DOERR (XLIB 2 42)
1A36D=ERR0 (XLIB 2 43)
1A388=ERRN (XLIB 2 44)
1A3A3=ERRM (XLIB 2 45)
1A3BE=EVAL (XLIB 2 46)
1A3FE=IFTE (XLIB 2 47) H:3A1
1A471=HXS A 0140626250
1A4A3=Internal IFTE (% ob1 ob2 --> symf )
1A4CD=IFT (XLIB 2 48)
1A4F0=Internal IFT (% ob --> ? )
1A513=Internal IFT (sym ob --> ? )
1A52E=SYSEVAL (XLIB 2 49)
1A547=Internal SYSEVAL (1:HXS)
1A556=Internal SYSEVAL (1:#)
1A584=DISP (XLIB 2 50)
1A5A4=FREEZE (XLIB 2 51)
1A5C4=BEEP (XLIB 2 52)
1A5E4=->NUM (XLIB 2 53)
1A604=LASTARG (XLIB 2 54)
1A631=Internal LASTARG (Doesn't check LASTARG flag)
1A71F=WAIT (XLIB 2 55)
1A738=Internal WAIT (1:%any)
1A7B5=Internal WAIT (timed) (1:%positive) (Does ?ATTNQUITNOLASTWD after)
1A7C9=Deep internal WAIT (timed) (1:%positive)
1A7ED=Deep internal WAIT (timed) (1:HXS) (HXS = 8192 * real value)
1A858=CLLCD (XLIB 2 56)
1A873=KEY (XLIB 2 57)
1A8BB=CONT (XLIB 2 58)
1A8D8== (XLIB 2 59) H:5C8
1A995=NEG (XLIB 2 60) H:5C8
1A9F9=HXS 4 0108
1AA1F=ABS (XLIB 2 61) H:080
1AA6E=CONJ (XLIB 2 62) H:0C8
1AABD=pi (XLIB 2 63) H:080
1AADF=MAXR (XLIB 2 64) H:080
1AB01=MINR (XLIB 2 65) H:080
1AB23=e (XLIB 2 66) H:080
1AB45=i (XLIB 2 67) H:080
1AB67=+ (XLIB 2 68) H:5C8
1AC75=HXS 5 70107
1AC93=Internal + (ob comp --> comp')
1ACA7=Internal + (2:$ 1:Any -> 1:$)
1ACBB=Internal + (2:Any 1:$ -> 1:$)
1ACDD=+ (no operation) (XLIB 2 69) H:500
1AD09=- (XLIB 2 70) H:5C8
1ADEE=* (XLIB 2 71) H:5C8
1AEDE=HXS 5 80108
1AF05=/ (XLIB 2 72) H:5C8
1AFF5=If EqwrParser? then hex_8014050 else hex_80108
1B013=HXS 7 8014050
1B02D=^ (XLIB 2 73) H:5CC
1B0E6=If EqwrParser? then hex_9014050 else hex_90109
1B104=HXS 5 90109
1B113=HXS 7 9014050
1B124=Internal ^ (2:% 1:% -> 1:% /C%)
1B185=XROOT (XLIB 2 74) H:A
1B1CA=XROOT (XLIB 2 75) H:401
1B23D=(1:%/C%/Unit 2:%/C%/Unit -> 1:Unit)
1B251=Internal XROOT (1:% 2:% -> 1:%)
1B278=INV (XLIB 2 76) H:0CC
1B2DB=ARG (XLIB 2 77) H:080
1B30D=Internal ARG (1:% -> 1:%angle)
1B32A=SIGN (XLIB 2 78) H:004
1B374=SQRT (XLIB 2 79) H:5C4
1B3C9=If EqwrParser? then DISPARGS1 else DISPSQRTNORM
1B3E7=HXS 4 010C
1B3F5=Internal sqrt (1:% (<0 too))
1B426=SQ (XLIB 2 80) H:0C4
1B47B=Internal SQ (1:% -> 1:%)
1B48F=Internal SQ (1:C% -> 1:C%)
1B4AC=SIN (XLIB 2 81) H:0CC
1B505=COS (XLIB 2 82) H:0CC
1B55E=TAN (XLIB 2 83) H:0CC
1B5B7=SINH (XLIB 2 84) H:0CC
1B606=COSH (XLIB 2 85) H:0CC
1B655=TANH (XLIB 2 86) H:0CC
1B6A4=ASIN (XLIB 2 87) H:0CC
1B6EA=Internal ASIN (1:%any -> 1:%/C%)
1B6EF=If %ABS(%)>1 then SKIP else COLA (1:% -> 1:%)
1B72F=ACOS (XLIB 2 88) H:0CC
1B775=Internal ACOS (1:%any -> 1:%/C%)
1B79C=ATAN (XLIB 2 89) H:0CC
1B7EB=ASINH (XLIB 2 90) H:0C8
1B830=ACOSH (XLIB 2 91) H:0C8
1B86C=Internal ACOSH (1:%any -> 1:%/C%)
1B8A2=ATANH (XLIB 2 92) H:0C8
1B8DE=Internal ATANH (1:%any -> 1:%/C%)
1B905=EXP (XLIB 2 93) H:0CC
1B94F=LN (XLIB 2 94) H:0CC
1B995=Internal LN (1:%any -> 1:%/C%)
1B9C6=LOG (XLIB 2 95) H:0CC
1BA0C=Internal LOG (1:%any -> 1:%/C%)
1BA3D=ALOG (XLIB 2 96) H:0CC
1BA8C=LNP1 (XLIB 2 97) H:0C0
1BAC2=EXPM1 (XLIB 2 98) H:0C4
1BB02=! (XLIB 2 99) H:500
1BB2A=HXS 4 A010
1BB41=FACT (XLIB 2 100) (Same prg as x!) H:000
1BB6D=IP (XLIB 2 101) H:000
1BBA3=FP (XLIB 2 102) H:000
1BBD9=FLOOR (XLIB 2 103) H:000
1BC0F=CEIL (XLIB 2 104) H:000
1BC45=XPON (XLIB 2 105) H:000
1BC71=MAX (XLIB 2 106) H:000
1BCE3=MIN (XLIB 2 107) H:000
1BD55=RND (XLIB 2 108) H:000
1BDD1=TRNC (XLIB 2 109) H:000
1BE4D=MOD (XLIB 2 110) H:100
1BE84=HXS 5 80108
1BE9C=MANT (XLIB 2 111) H:000
1BEC8=D->R (XLIB 2 112) H:000
1BEF4=R->D (XLIB 2 113) H:000
1BF1E=->HMS (XLIB 2 114)
1BF3E=HMS-> (XLIB 2 115)
1BF5E=HMS+ (XLIB 2 116)
1BF7E=HMS- (XLIB 2 117)
1BF9E=RNRM (XLIB 2 118)
1BFBE=CNRM (XLIB 2 119)
1BFDE=DET (XLIB 2 120)
1BFFE=DOT (XLIB 2 121)
1C01E=CROSS (XLIB 2 122)
1C03E=RSD (XLIB 2 123)
1C060=% (XLIB 2 124) H:000
1C0B5=Internal % (2:% 1:Unit -> 1:%)
1C0D7=%T (XLIB 2 125) H:000
1C149=%CH (XLIB 2 126) H:000
1C1B9=RAND (XLIB 2 127)
1C1D4=RDZ (XLIB 2 128)
1C1F6=COMB (XLIB 2 129) H:000
1C236=PERM (XLIB 2 130) H:000
1C274=SF (XLIB 2 131)
1C28D=Internal SF (1:% ->)
1C2B0=Abscoerces % & checks if %>0 (1:% -> 2:# 1:T/F )
1C2D5=CF (XLIB 2 132)
1C2EE=Internal CF (1:% ->)
1C313=FS? (XLIB 2 133)
1C32C=Internal FS? (1:% -> 1:%)
1C331=Internal FS? (1:% -> 1:T/F)
1C360=FC? (XLIB 2 134)
1C379=Internal FC? (1:% -> 1:%)
1C399=DEG (XLIB 2 135)
1C3B4=RAD (XLIB 2 136)
1C3CF=GRAD (XLIB 2 137)
1C3EA=FIX (XLIB 2 138)
1C403=Internal FIX (1:% ->)
1C41E=SCI (XLIB 2 139)
1C437=Internal SCI (1:% ->)
1C452=ENG (XLIB 2 140)
1C46B=Internal ENG (1:% ->)
1C486=STD (XLIB 2 141)
1C4A1=FS?C (XLIB 2 142)
1C4BA=Internal FS?C (1:% -> 1:%)
1C4BF=Internal FS?C (1:% -> 1:T/F)
1C4CE=User flag set? and clear (1:# -> 1:T/F)
1C4EC=System flag set? and clear (1:# -> 1:T/F)
1C520=FC?C (XLIB 2 143)
1C539=Internal FC?C (1:% -> 1:%)
1C559=BIN (XLIB 2 144)
1C574=DEC (XLIB 2 145)
1C58F=HEX (XLIB 2 146)
1C5AA=OCT (XLIB 2 147)
1C5C5=STWS (XLIB 2 148)
1C5DE=Internal STWS (1:HXS ->)
1C5FE=RCWS (XLIB 2 149)
1C619=RCLF (XLIB 2 150)
1C637=Recall System Flags (-> 1:HXS)
1C64E=Recall User Flags (-> 1:HXS)
1C67F=STOF (XLIB 2 151)
1C6A2=Internal STOF (1:{} ->)
1C6CF=Internal STOF (2:HXSsystem 1:HXSuser ->)
1C6E3=Internal STOF (system) (1:HXS ->)
1C6F7=Store user flags (1:HXS ->)
1C731=Store system flags (1:HXS ->) (Doesn't check changes in LASTARG flag)
1C783=->LIST (XLIB 2 152)
1C79E=R->C (XLIB 2 153)
1C7CA=RE (XLIB 2 154) H:008
1C819=IM (XLIB 2 155) H:008
1C85C=SUB (XLIB 2 156)
1C8BB=Internal SUB (3:$ 2:% 1:% -> 1:$)
1C8CF=Internal SUB (3:{} 2:% 1:% -> 1:{})
1C8EA=REPL (XLIB 2 157)
1C95A=LIST-> (XLIB 2 158)
1C973=INNERCOMP & UNCOERCE (1:Comp -> N+1:...1:%n)
1C98E=C->R (XLIB 2 159)
1C9B8=SIZE (XLIB 2 160)
1CA0D=Internal DROP and 1
1CA26=Internal SIZE (bytes) (1:$ -> 1:%)
1CA3A=Internal SIZE (1:comp -> 1:%)
1CA4E=Internal SIZE (1:[] -> 1:{% (%)})
1CA62=Internal SIZE (1:Grob -> 2:HXS 1:HXS)
1CA85=Internal SIZE (1:Program/PICT -> 1: %1 / 2:HXS 1:HXS)
1CAB4=POS (XLIB 2 161)
1CAD7=Internal POS (2:$ 1:$ -> 1:%)
1CAF0=Internal POS (2:Comp 1:Any -> 1:%)
1CB0B=->STR (XLIB 2 162)
1CB26=STR-> (XLIB 2 163)
1CB46=NUM (XLIB 2 164)
1CB66=CHR (XLIB 2 165)
1CB86=TYPE (XLIB 2 166)
1CB90=Internal TYPE (1:Any -> 2:Any 1:%type)
1CDB1=Internal TYPE (1:[] -> 2:[] 1:%3 or %4)
1CDD4=Internal TYPE (1:seco -> 1:%8, %18 or %19)
1CE28=VTYPE (XLIB 2 167)
1CE55=Internal VTYPE (1:ID/LAM -> 1:%)
1CE5F=If True then (2:Ob 1:T -> 1:%type) else (2:Ob 1:F -> 2:Ob 1:%-1)
1CE82=Internal VTYPE (1:Tagged -> 1:%)
1CEE3=EQ-> (XLIB 2 168)
1CF2E=Internal EQ-> (symb --> arg1 arg2 )
1CF42=(Meta2&Meta1<op> -> ALG_Meta2 ALG_Meta1)
1CF42=Example: A B + C D + * #7 -> 'A+B' 'C+D'
1CF7B=OBJ-> (XLIB 2 169)
1CFD0=Internal OBJ-> (symb --> arg1 ... argn %n ob )
1D009=->ARRY (XLIB 2 170)
1D02C=Internal ->ARRY (N+1...floats...1:%n -> 1:[])
1D040=Internal ->ARRY (...floats...1:{dims} -> 1:[])
1D054=Faster than {}>ARRY (Drops some tests)
1D054=Internal ->ARRY (...floats...1:{dims} -> 1:[])
1D092=ARRY-> (XLIB 2 171)
1D0AB=( :: ONE_DO_ARRAY INDEX@ PULLEL SWAP LOOP DIMLIMITS UNCOERCE{}2 ;)
1D0AB=Internal ARRY-> (1:[] -> ...1:{dims})
1D0DF=RDM (XLIB 2 172)
1D10C=Internal RDM (2:[] 1:{} -> 1:[])
1D125=Internal RDM (2:ID 1:{})
1D152=Internal RDM (2:LAM 1:{})
1D186=CON (XLIB 2 173)
1D1EA=Internal CON (2:{%dims} 1:%/C% -> 1:[])
1D221=Internal CON (2:[] 1:C% -> 1:[])
1D23F=Internal CON (2:ID 1:%)
1D262=Internal CON (2:ID 1:C%)
1D28A=Internal CON (2:LAM 1:%)
1D2AD=Internal CON (2:LAM 1:C%)
1D2DC=IDN (XLIB 2 174)
1D313=Internal IDN (1:% -> 1:[])
1D34A=Internal IDN (1:ID)
1D36D=Internal IDN (1:LAM)
1D392=TRN (XLIB 2 175)
1D3BF=Internal TRN (1:ID)
1D3E2=Internal TRN (1:LAM)
1D407=PUT (XLIB 2 176)
1D484=Internal PUT (3:ID 2:%/{} 1:Any)
1D4DE=Internal PUT (3:[] 2:%/{} 1:%/C%)
1D501=(4:ID 3:[] 2:{}/% 1:%/C%)
1D524=Internal PUT (3:{} 2:%/{} 1:Any)
1D54C=(4:ID 3:{} 2:{}/% 1:Any)
1D565=Internal PUT (3:LAM 2:%/{} 1:Any)
1D5DF=PUTI (XLIB 2 177)
1D65C=Internal PUTI (3:ID 2:%/{} 1:Any)
1D6B6=Internal PUTI (3:[] 2:%/{} 1:%/C%)
1D701=Internal PUTI (3:{} 2:%/{} 1:Any)
1D747=Internal PUTI (3:LAM,2:%/List,1:Any)
1D7C6=GET (XLIB 2 178)
1D825=Internal GET (2:ID/LAM, 1:%/{})
1D86B=Internal GET (2:[] 1:%/{})
1D898=Internal GET (2:{} 1:%/{})
1D8C7=GETI (XLIB 2 179)
1D926=Internal GETI (2:ID/LAM,1:%/List)
1D96C=Internal GETI (2:Array,1:%/List)
1D9BC=Internal GETI (2:List,1:%/List)
1DB6F=INNERCOMP, if size <> #1 then SIZEERR
1DC00=PUTI (3:Ob 2:#n 1:{} -> 1:{} )
1DC00=Works for other composites too, if you change the prolog afterwards
1DC6E=([] { % (%) } / % --> [] #loc )
1DCC3=Checks that (3:[] 2:Any 1:%/C%) stk1 is of right type to put in [] 
1DD06=V-> (XLIB 2 180)
1DD29=Internal V-> (1:C%)
1DD3D=Internal V-> (1:[])
1DDEC=:: 2@REVAL SWAP 2@REVAL SWAP ;
1DE66=->V2 (XLIB 2 181)
1DE7F=Internal ->V2 (2:% 1:%)
1DEC2=->V3 (XLIB 2 182)
1DEDB=Internal ->V3 (3:%,2:%,1:%)
1DEEF=If spherical flag on then %SPH>%REC, else %3DPOL>%REC
1DEEF=Internal (3:% 2:% 1:% -> 3:% 2:% 1:%) 
1DF03=Polar coords to rectangular (3D) (3:% 2:% 1:% -> 3:% 2:% 1:%)
1DF71=CRUNCH, then does C%>Re, U>Nbr or NOP (%) (else error) & DUP2PUTLAM
1E00C=(3:Any 2:%/{} 1:Any -> 3:Any 2:%/{} 1:Any)
1E00C=Converts all entries (CRUNCH C%>Re etc) in {} to reals (Error if..)
1E04A=INDEP (XLIB 2 183)
1E07E=PMIN (XLIB 2 184)
1E09E=PMAX (XLIB 2 185)
1E0BE=AXES (XLIB 2 186)
1E0E8=CENTR (XLIB 2 187)
1E101=Internal CENTR (1:%)
1E126=RES (XLIB 2 188)
1E150=*H (XLIB 2 189)
1E170=*W (XLIB 2 190)
1E190=DRAW (XLIB 2 191)
1E1AB=AUTO (XLIB 2 192)
1E1C6=DRAX (XLIB 2 193)
1E1E1=SCALE (XLIB 2 194)
1E201=PDIM (XLIB 2 195)
1E22B=DEPND (XLIB 2 196)
1E25F=ERASE (XLIB 2 197)
1E27A=PX->C (XLIB 2 198)
1E29A=C->PX (XLIB 2 199)
1E2BA=GRAPH (XLIB 2 200)
1E2D5=LABEL (XLIB 2 201)
1E2F0=PVIEW (XLIB 2 202)
1E31A=PIXON (XLIB 2 203)
1E344=PIXOFF (XLIB 2 204)
1E36E=PIX? (XLIB 2 205)
1E398=LINE (XLIB 2 206)
1E3C2=TLINE (XLIB 2 207)
1E3EC=BOX (XLIB 2 208)
1E416=BLANK (XLIB 2 209)
1E436=PICT (XLIB 2 210) (:: CK0 ' xPICT ;)
1E456=GOR (XLIB 2 211)
1E46A=Internal GOR (3:Grob 2:{} 1:Grob)
1E488=Internal GOR (3:Grob 2:C% 1:Grob)
1E4A6=Internal GOR (3:PICT 2:{} 1:Grob)
1E4C4=Internal GOR (3:PICT 2:C% 1:Grob)
1E4E4=GXOR (XLIB 2 212)
1E572=LCD-> (XLIB 2 213)
1E58D=->LCD (XLIB 2 214)
1E5AD=->GROB (XLIB 2 215)
1E5D2=ARC (XLIB 2 216)
1E606=TEXT (XLIB 2 217)
1E621=XRNG (XLIB 2 218)
1E641=YRNG (XLIB 2 219)
1E661=FUNCTION (XLIB 2 220)
1E681=CONIC (XLIB 2 221)
1E6A1=POLAR (XLIB 2 222)
1E6C1=PARAMETRIC (XLIB 2 223)
1E6E1=TRUTH (XLIB 2 224)
1E701=SCATTER (XLIB 2 225)
1E721=HISTOGRAM (XLIB 2 226)
1E741=BAR (XLIB 2 227)
1E761=SAME (XLIB 2 228) (:: EQUAL COERCEFLAG ;)
1E783=AND (XLIB 2 229) H:100
1E7CE=HXS 5 50105
1E7DD=Internal AND (2:% 1:% -> 1:%)
1E809=OR (XLIB 2 230) H:100
1E854=HXS 5 40104
1E863=Internal OR (2:%,1:%)
1E88F=NOT (XLIB 2 231) H:500
1E8CB=HXS 4 0105
1E8D9=Internal NOT (1:%)
1E8F6=XOR (XLIB 2 232) H:100
1E946=Internal XOR (2:%,1:%)
1E972=== (XLIB 2 233) (Last default is EQUAL>%) H:100
1EA21=HXS 5 60106
1EA30=Internal == (2:Any 1:Any -> 1:%)
1EA44=Internal == (2:Tagged/Any,1:Tagged/Any)
1EA6C=Internal == (2:%,1:C% -> 1:%)
1EA76=Internal == (2:C%,1:% -> 1:%)
1EA9D=<> (XLIB 2 234) H:100
1EB51=Internal <> (2:Any,1:Any -> 1:%)
1EB65=Internal <> (2:Tagged/Any,1:Tagged/Any)
1EB8D=Internal <> (2:%,1:C% -> 1:%)
1EB97=Internal <> (2:C%,1:% -> 1:%)
1EBBE=< (XLIB 2 235) H:100
1EC40=Internal < (2:%,1:% -> 1:%)
1EC5D=> (XLIB 2 236) H:100
1ECDF=Internal > (2:%,1:% -> 1:%)
1ECFC=<= (XLIB 2 237) H:100
1ED7E=Internal <= (2:%,1:%)
1ED9B=>= (XLIB 2 238) H:100
1EE1D=Internal >= (2:%,1:%)
1EE38=OLDPRT (XLIB 2 239)
1EE53=PR1 (XLIB 2 240)
1EE6E=PRSTC (XLIB 2 241)
1EE89=PRST (XLIB 2 242)
1EEA4=CR (XLIB 2 243)
1EEBF=PRVAR (XLIB 2 244)
1EEEC=Internal PRVAR (1:Tagged)
1EF1E=Internal PRVAR (1:List)
1EF43=DELAY (XLIB 2 245)
1EF63=PRLCD (XLIB 2 246)
1EF7E=delta (complete derivative) (XLIB 2 247) H:E
1EFD2=delta (stepwise derivative) (XLIB 2 248) H:5A7
1F00E=HXS 7 0134250
1F047=Internal DROP2 and push 0
1F05B=A 1 element (ID/LAM) Algebraic? (Like ALG_X) (1:Any -> 1:Any)
1F0F5=Internal stepwise der (QN sym --> symf )
1F113=Derivative of constant (QN %/C%/Unit --> %0 )
1F133=RCEQ (XLIB 2 249)
1F14E=STEQ (XLIB 2 250)
1F16E=ROOT (XLIB 2 251)
1F1D4=integral (stack syntax) (XLIB 2 252) H:E
1F201=Internal integral (stack syntax) (1:ID/LAM)
1F223=integral (algebraic syntax) (XLIB 2 253) H:5A7
1F241=HXS C 014060626350
1F27A=Internal integral (algebraic syntax) (1:ALG)
1F2C9=Sigma (XLIB 2 254) H:5A3
1F319=HXS C 014370606250
1F354=| (stack syntax) (XLIB 2 255) H:E
1F38B=Internal | (stack syntax) (2:sym 1:{ID newID ID newID...})
1F3F3=| (algebraic syntax) (XLIB 2 256) H:5A3 (Also COLCTWHERE !!)
1F40C=HXS A 2214370B50
1F439=Changes sym to ALG, IDs to ALG_IDs & Checks they're valid
1F439=Internal | (N+2:sym..3:ID 2:newID 1:#n) (#n is changes*2+1)
1F4CA=(Meta Ob -> Ob&Meta) where Ob prolog is changed to ALG
1F500=QUOTE (XLIB 2 257) H:121
1F523=HXS 6 014250
1F542=Internal QUOTE (1:ALG -> 1:ALG) (Explodes & puts back again)
1F55D=APPLY (stack syntax) (XLIB 2 258) H:A
1F585=Internal APPLY (stack syntax) (2:{} 1:ID/LAM -> 1:ALG_ID(args) )
1F5C5=APPLY (algebraic syntax) (XLIB 2 259) H:181
1F5D9=HXS 9 014360950
1F5F6=(N+1:ALG_name N:arg 1st...2:arg last 1:#n -> 1:ALG_ID(args))
1F640=..args 2:ALG_ID 1:#args -> 1:ALG_ID(args)
1F640=XLIB 2 260 (Won't show on screen ("")) H:4A2
1F6E0=(..args 1:ID/LAM -> 1:ALG_name(args) (#Args in 1LAM & Name not used)
1F8CF=Internal STO (2:Any 1:ALG)
1F996=XLIB 2 261 ( :: CK2&Dispatch ; ) H:000
1F9AE=XLIB 2 262 ( :: CK2&Dispatch ; ) H:000
1F9C4=->Q (XLIB 2 263)
1F9E9=->QPI (XLIB 2 264)
1FA07=(2:Any 1:flag) True: ->QPI False: ->Q 
1FA59=^MATCH (XLIB 2 265)
1FA8D=vMATCH (XLIB 2 266)
1FABA=Internal ^MATCH (2:%/C%/sym 1:{} -> 2:Ob 1:%)
1FACE=Internal vMATCH (2:%/C%/sym 1:{} -> 2:Ob 1:%)
1FAEB=_ (XLIB 2 267) H:501
1FB1D=HXS 5 90127
1FB31=Internal _ (1:%/Unit)
1FB5D=RATIO (XLIB 2 268) (Same as x/) H:500
1FB87=DUP (XLIB 2 269)
1FBA2=DUP2 (XLIB 2 270)
1FBBD=SWAP (XLIB 2 271)
1FBD8=DROP (XLIB 2 272)
1FBF3=DROP2 (XLIB 2 273)
1FC0E=ROT (XLIB 2 274)
1FC29=OVER (XLIB 2 275)
1FC44=DEPTH (XLIB 2 276)
1FC64=DROPN (XLIB 2 277)
1FC7F=DUPN (XLIB 2 278)
1FC9A=PICK (XLIB 2 279)
1FCB5=ROLL (XLIB 2 280)
1FCD0=ROLLD (XLIB 2 281)
1FCEB=CLEAR (XLIB 2 282)
1FD0B=STOSigma (XLIB 2 283)
1FD2B=CLsigma (XLIB 2 284)
1FD46=RCLSigma (XLIB 2 285)
1FD61=Sigma+ (XLIB 2 286)
1FD8B=Sigma- (XLIB 2 287)
1FDA6=NSigma (XLIB 2 288)
1FDC1=CORR (XLIB 2 289)
1FDDC=COV (XLIB 2 290)
1FDF7=SigmaX (XLIB 2 291)
1FE12=SigmaY (XLIB 2 292)
1FE2D=SigmaX^2 (XLIB 2 293)
1FE48=SigmaY^2 (XLIB 2 294)
1FE63=SigmaX*Y (XLIB 2 295)
1FE7E=MAXSigma (XLIB 2 296)
1FE99=MEAN (XLIB 2 297)
1FEB4=MINSigma (XLIB 2 298)
1FECF=SDEV (XLIB 2 299)
1FEEA=TOT (XLIB 2 300)
1FF05=VAR (XLIB 2 301)
1FF20=LR (XLIB 2 302)
1FF7A=PREDV (XLIB 2 303)
1FF9A=PREDY (XLIB 2 304)
1FFBA=PREDX (XLIB 2 305)
1FFDA=XCOL (XLIB 2 306)
1FFFA=YCOL (XLIB 2 307)
2001A=UTPC (XLIB 2 308)
2003A=UTPN (XLIB 2 309)
2005A=UTPF (XLIB 2 310)
2007A=UTPT (XLIB 2 311)
2009A=COLSigma (XLIB 2 312)
200C4=SCLSigma (XLIB 2 313)
200F3=SigmaLINE (XLIB 2 314)
2010E=BINS (XLIB 3 315)
20133=BARPLOT (XLIB 2 316)
20167=HISTPLOT (XLIB 2 317)
2018C=SCATRPLOT (XLIB 2 318)
201B1=LINFIT (XLIB 2 319)
201D6=LOGFIT (XLIB 2 320)
201FB=EXPFIT (XLIB 2 321)
20220=PWRFIT (XLIB 2 322)OB
20234=set curve-fitting model in 'SigmaPAR' (1:model)
2025E=BESTFIT (XLIB 2 323)
202CE=SINV (XLIB 2 324)
202F1=Internal SINV (1:ID)
20314=Internal SINV (1:LAM)
2034D=SNEG (XLIB 2 325)
20370=Internal SNEG (1:ID)
20393=Internal SNEG (1:LAM)
203CC=SCONJ (XLIB 2 326)
203EF=Internal SCONJ (1:ID)
20412=Internal SCONJ (1:LAM)
2044B=STO+ (XLIB 2 327)
20482=Internal STO+ (2:Any,1:ID/LAM)
204AA=(3:ID 2:contents 1:Any)
204C3=Internal STO+ (2:ID/LAM,1:Any)
204FF=Used by SINV etc (2:ID 1:Ob ->) (Operation fetched with 'R)
20538=STO- (XLIB 2 328)
20583=Internal STO- (2:Any,1:ID/LAM)
205A1=Internal STO- (2:ID/LAM,1:Any)
205BF=Internal STO- (2:Array,1:ID)
205E2=Internal STO- (2:ID,1:Array)
2060C=STO/ (XLIB 2 329)
2066B=Internal STO/ (2:Any,1:ID/LAM)
20689=Internal STO/ (2:ID/LAM,1:Any)
206A7=Internal STO/ (2:ID,1:%/C%)
206E8=Internal STO/ (2:Array,1:ID)
20729=Internal STO/ (2:ID,1:Array)
20753=STO* (XLIB 2 330)
207C6=Internal STO* (2:Any,1:ID/LAM)
207E4=Internal STO* (2:ID/LAM,1:Any)
20802=Internal STO* (2:%/C%,1:ID)
2082A=Internal STO* (2:ID,1:%/C%)
2086B=Internal STO* (2:Array,1:ID)
208AC=Internal STO* (2:ID,1:Array)
208F4=INCR (XLIB 2 331)
20917=Internal INCR (1:ID)
20980=Internal INCR (1:LAM)
209AA=DECR (XLIB 2 332)
209CD=Internal DECR (1:ID)
209EB=Internal DECR (1:LAM)
20A15=COLCT (XLIB 2 333)
20A49=EXPAN (XLIB 2 334)
20A7D=RULES (XLIB 2 335) (:: DoBadKey ;)
20A93=ISOL (XLIB 2 336)
20AB3=QUAD (XLIB 2 337)
20AD3=SHOW (XLIB 2 338)
20B00=Internal SHOW (2:sym 1:{})
20B20=TAYLR (XLIB 2 339)
20B40=RCL (XLIB 2 340)
20B81=Internal RCL (1:ID/LAM)
20B9A=Internal RCL (1:{} (path/object))
20BE0=Cheks that {} has only ID/LAMs (1:{}) (TYPEERR if not)
20BE5=If {} has only ID(LAMs then SKIP
20C4E=(2:{ID_DIR ID_VAR} 1:DIR -> 1:ob) (Or error if not found)
20C71=Internal RCL starting from HOME (1:{HOME path object})
20CAD=Internal RCL (1:PICT) (Does TOTEMPOB)
20CCD=STO (XLIB 2 341)
20CE6=( ob id --> ) Strips tags from ob first
20CFF=( ob id/lam --> ) Strips tags from ob first
20D65=DEFINE (XLIB 2 342)
20D7E=Internal DEFINE (1:symb ->)
20DBF=Internal DEFINE (2:Ob 1:ID/LAM)
20ECA=DUP & If not ID/LAM then INVDEFERR
20EFE=PURGE (XLIB 2 343)
20F35=Internal PURGE (1:{})
20F44=(At execution time: 2:comp 1:ob  1LAM:The stored program)
20F44=Ex: :: { A B C } LSEvalNoCK: xPURGE ; Purges variables A,B,C
20F44=Executes next on all composite elements & DROP (INDEX@ is usable)
20F8A=Internal PURGE (1:PICT)
20FAA=MEM (XLIB 2 344)
20FD9=ORDER (XLIB 2 345)
20FF2=Internal ORDER (1:{})
210FC=CLVAR (XLIB 2 346)
2115D=TMENU (XLIB 2 347)
21176=(1:{}/ID/LAM)
21196=MENU (XLIB 2 348)
211E1=RCLMENU (XLIB 2 349)
211FC=PVARS (XLIB 2 350)
2120B=Internal PVARS (1:%) (Checks port number is in range)
2123A=PGDIR (XLIB 2 351)
2125A=ARCHIVE (XLIB 2 352)
21273=Internal ARCHIVE (1:Tagged with $port or "IO")
212C7=Internal ARCHIVE to port (2:ID 1:$port)
212CC=Checks stk2 is ID/LAM and stk1 is "0","1" or "2"
212D1=Type error if stk2 not ID/LAM (2:Any 1:Any -> 2:Any 1:Any)
2133C=RESTORE (XLIB 2 353)
2134B=Internal RESTORE (1:Tagged)
2137F=MERGE (XLIB 3 354)
21398=Internal MERGE (1:%)
213D1=FREE (XLIB 2 355)
21408=Internal FREE (2:%/ID/LAM 1:%port)
2142D=LIBS (XLIB 2 356)
21448=ATTACH (XLIB 2 357)
21461=Internal ATTACH (1:%libnum)
2147C=DETACH (XLIB 2 358)
21495=Internal DETACH (1:%)
214A9=COERCE & verify #libnum is in free range (#libnum>#100 & <> #700)
214F4=Internal STO (ob tagged --> )
21530=Internal STO (do arg/type checks) (:: ' xSTO COLA EvalNoCK ; )
215A1=(ob #/id #port --> )
215BF=Internal STO (2:LIB/BAK 1:%port)
215D9=(1:BAK/LIB -> 2:BAK/LIB 1:ID/#libnum)
215E8=(1:LIB -> 1:#libnum)
21624=(2:ID/LAM 1:Any -> 2:BAK 1:True)
21638=<< DUPTYPEREAL? COLAcase >>
2164C=Internal SWAP and False
21660=drop level two object and True
21674=(2:ID/LAM 1:Any -> 1:BAK)
216D8=(1:{ ID/LAM Ob Any5nib} -> 1:BAK)
216D8=Internally this is used: { ID NAMEspc Ob TRUE } 
216D8=ie space is appended to the name and TRUE is 5 nibs long
21761=Internal RCL (1:Tagged ID -> 1:contents)
2178B=Example: :: SKIP'COLAEvalNoCK <foo> x+ <rest> ; == :: x+ ;
2178B=SKIP, then EvalNoCK next & return
217A9=:: 'RRDROP 'R RSKIP COLA_EVAL ;
217A9=Push next, push 1st from prev, skip in prev & COLA_EVAL
217C7=Internal EVAL (1:Tagged)
217F1=Internal PURGE (1:Tagged)
21839=Internal PVARS (1:#port)
21922=Rcl libs in port (1:#port -> #port...2:LIB 1:#no.of.libs)
21931=(-> Ob1 Ob2..1:#n) (Recalls port 0 objects)
21972=(1:#portaddr -> Ob1 Ob2...1:#n) (Makes no checks)
2198B=(3:#n 2:Any 1:Ob -> 3:Any 2:#n+1 1:Ob)
219A9=(#port LIBs/BAKs 1:#n -> Taggeds #n) 
219A9=(LIB-> #port:%libnum, BAK->#port:ID)
219C2=(1:# -> 1:$) (#0->"0" #1->"1" other->"2")
219F4=Gets %libnum or ID (1:LIB/BAK -> 1:%/ID) (Must exists)
219FE=Get library number (LIB must exist) (1:LIB -> 1:%)
21A49=Archive to port (2:ID/LAM 1:#port)
21AB7=Archive to port0 (1:ID/LAM)
21AF8=Internal RESTORE (2:ID 1:#port -> )
21AFD=(2:ID/#libnum 1:#0/#1/#2 -> 2:BAK/LIB 1:T / 1:F)
21B2F=Internal RESTORE (1:Backup)
21B4E=Jumps to HP:Warmstart in 01FBD
21B5A=Archive to IO (1:$/ID/LAM)
21B74=Internal FREE (2:{} 1:%port)
21C47=Example: 1:#0 -> 1:#3ff9  (Which is address for #1)
21C47=Skips stk1 in memory, then gives address as #
21C6F=Internal ATTACH (1:#libnum)
21C88=(if not yet attached then attach to homedir) (1:#libnum)
21CBA=Internal ATTACH to non-HOME directory (2:Dir 1:#libnum)
21CE5=Internal DETACH (1:#libnum)
21D2B=Internal DETACH from non-HOME directory (2:DIR 1:#libnum)
21D54=Internal LIBS
21D5E=(1:DIR -> $NAME1 %LIBNUM1 #ADDR1 $NAME2 ... #n)
21D5E=Rcl info ($Name %Id #Addr) on libs attached 
21DB0=(1:#port -> 3:#startaddr 2:#endaddr 1:Present and not merged?)
21DE7=# 70000
21DF1=DUP & if {} has only LAM/IDs then COLA else SKIP
21E41=:: DROPRDROP COLASKIP ; (DROP, return & SKIP)
21E75=XMIT (XLIB 2 359)
21E95=SRECV (XLIB 2 360)
21EB5=OPENIO (XLIB 2 361)
21ED5=CLOSEIO (XLIB 2 362)
21EF0=SEND (XLIB 2 363)
21F24=KGET (XLIB 2 364)
21F62=RECN (XLIB 2 365)
21F96=RECV (XLIB 2 366)
21FB6=FINISH (XLIB 2 367)
21FD1=SERVER (XLIB 2 368)
21FEC=CKSM (XLIB 2 369)
2200C=BAUD (XLIB 2 370)
2202C=PARITY (XLIB 2 371)
2204C=TRANSIO (XLIB 2 372)
2206C=KERRM (XLIB 2 373)
22087=BUFLEN (XLIB 2 374)
220A2=STIME (XLIB 2 375)
220C2=SBRK (XLIB 2 376)
220DD=PKT (XLIB 2 377)
220F6=If MSGOK? then display IO setup screen
22307=Toggles ASCII/binary flag & redraws IOSETUP display
22325=Toggles IR/wire flag & redraws IOSETUP display
2234D={ %1200 %2400 %4800 %9600 }
223C9={ %1 %2 %3 }
224CA=INPUT (XLIB 2 378)
224F4=ASN (XLIB 2 379)
22514=STOKEYS (XLIB 2 380)
22548=DELKEYS (XLIB 2 381)
22586=RCLKEYS (XLIB 2 382)
225BE=->TAG (XLIB 2 383)
225F5=Internal ->TAG (2:Any 1:$)
22618=Internal ->TAG (2:Any 1:%)
22633=DTAG (XLIB 2 384)
22647=Reference to hash table for library 002 (XLIB 2) (#7448A)
22651=Link table for library 002 (XLIB 2)
22DFE=Reference to hash table for library 700 (XLIB 1792) (#7427C)
22E08=Link table for library 700 (XLIB 1792)
22EA3=Configuration code for library 700 (XLIB 1792) (#700 HOMEATTACH)
22EC3=IF (XLIB 1792 0) ( :: CK0ATTNABORT ; ) H:5
22EFA=THEN (XLIB 1792 1) H:A
22F22=Internal THEN (1:%)
22F3B=:: RSKIP COLASKIP ;     :: 2SKIP <no> <no> <rest> ;
22F4F=Internal THEN (1:sym)
22F68=ID: XEQRCL CRUNCH else CRUNCH (1:sym -> 1:Evaluated)
22F86=(2:sym 1:Any -> 2:Evaluated 1:Any)
22FB5=ELSE (XLIB 1792 2) ( :: CK0 COLASKIP ; ) H:A
22FD5=END (XLIB 1792 3) H:3
22FEB=-> (for Algebraics) (XLIB 1792 4) H:8
23033=WHILE (XLIB 1792 5) H:9
2305D=REPEAT (XLIB 1792 6) H:A
23085=Internal REPEAT (1:%)
230A3=Internal REPEAT (1:sym)
230C3=DO (XLIB 1792 7) H:9
230ED=UNTIL (XLIB 1792 8) H:2 (NONE)
23103=START (XLIB 1792 9) H:9
23144=Internal START (2:% 1:%)
23167=Internal START (2:%/sym 1:sym)
23180=Internal START (2:sym 1:%)
231A0=FOR (XLIB 1792 10) H:9
231E1=Internal FOR (2:%,1:%)
23213=Internal FOR (2:%/sym 1:sym)
2322C=Internal FOR (2:sym 1:%)
2324C=NEXT (XLIB 1792 11) H:B
2326A=Internal NEXT
23380=STEP (XLIB 1792 12) H:B
233A8=Internal STEP (1:sym)
233C1=Internal STEP (1:%)
233DF=IFERR (XLIB 1792 13) H:9
23472=HALT (XLIB 1792 14) H:8
2349C=(XLIB 1792 15) (Doesn't store ' as new command) H:8
234C1=-> (for Programs) (XLIB 1792 16) H:8
23502=In programs???? ( -> ..LAMs 1:#count)
235FE=>> (end local scope) (XLIB 1792 17) H:B
2361E=<< (XLIB 1792 18) H:1
23639=>> (XLIB 1792 19) H:B
23654=' (XLIB 1792 20) H:8
23679=' (XLIB 1792 21) H:0
23694=END (XLIB 1792 22) H:B
236B9=END (XLIB 1792 23) H:B
2371F=THEN (XLIB 1792 24) H:2 (NONE)
23754={LAM_'noname LAM_'stop}
23768=:: 'RSAVEWORD CK0NOLASTWD COLA ?ATTNQUIT ;
2378D=CASE (XLIB 1792 25) H:1
237A8=THEN (for CASE) (XLIB 1792 26) H:9
23813=(A null program, hashes DIR, C$, GROB and XLIB)
23813=DIR (XLIB 1792 27) H:2 (NONE)
23824=PROMPT (XLIB 1792 28) H:8
238A4=($ --> ob TRUE / $ #offset $errtoken FALSE)
238B8=Doesn't BIND FALSE to LAM_'ioinprogress first
238CC=Uses MainMask to resolve tokens, no ERRTRAP
23903=LAM{st_ofs_tok}
23989=End marker for the parser
23A06=(Meta Hxs $ #next $token) Parses $ to stack obs
24E83=DROP, append "(", $>ID append it to meta, TrueTrue
24EA6=( {} -> DIR )
24EA6={} = { HXS 000 ID Ob1 ID Ob2 ... } Last char in ID is lost
251EC=(Meta hxsmask $ #next token$ token$ -> Meta' hxsmask $ #next token$)
251EC=:: 6UNROLL 5ROLL #1+ 5UNROLL ;
2520A=:: 'R apndit ;
25223=:: DUP apndit DROP GetNextToken TrueTrue ;
25246=(Meta1 Meta2 -> Meta2 meta1 True True) (meta1 has no count)
2525A=parses stack objects to 1 object
25322=(Meta1 Ob4 Ob3 Ob2 Ob1 -> Meta2 Meta1) (Meta2 = Ob4..Ob1 #4)
25452=(hxs-mask $ #loc "tok" -> hxs-mask $ #next "tokDatatok")
25452=Example: 4:MainMask 3:""123 456"" 2:#2 1:""" -> ... 2:#A 1:"123 456"
254F7=GetNextToken where mask is temporarily changed to HexMask
25501=GetNextToken where mask on stk1 is used once
255BD=If $ length is 0 or > 16 then COLA else SKIP (Valid ROMPTR ID LEN)
25632=Example: "ABCDh" -> "ABCD" #10 (ie 16 is base)
25699={ #2 #8 #A #10 } 
256E4=(4:HXS$ 3:HXS(LEN) 2:#Len 1:#Base -> 3:HXS 2:flag 1:flag)
25B0B=Internal + with #FFFFF as maximum result (2:# 1:# -> 1:#)
25C41=(4:$ 3:HXS 2:#(5=prolog_only) 1:#prolog) ??????????
25D03=Parses "." "," & "E"
25D3A=Parse mask used generally by palparse (argument to GetNextToken)
25E44=Hex strings?
25F4E=Parse mask for algebraics
26058=Parse mask for units
26162=#next points the next word. Gives "" if at the end
26162=(3:HxsMask 2:$ 1:#start -> 4:Hxsmask 3:$ 2:#next 1:$token)
26162=Gets the word starting at #nth char, strips spaces
26342=Pops stk1 flag to ST 2
265ED=( $real $tokE $tok. -->
265FB:A.B = chr_radix
26600:A.B1 = chr_radix
26611:A.B = chr_exp
26627:A = ".E-+09"
26634:R0 = ".E-+09"
26639:Drop separators
2663B:Leave $real on the stack
26642:A.A = ->$r
2664B:C.A = $len+5
26651:D0 = $len
26654:D1 = ->$body
26657:Init real = 0
2665A:Decimal mode!!
2665E:D.A = 99999
26660:B.A = 00000
26674:Get 1st char
2667A:Got char
2667D:Not real - return false
26695:Invalid?
26698:Yes - invalid real
2669A:"E"?
2669D:Yes - invalid real
2669F:"+"?
266A2:Yes - continue
266A4:Not "-"?
266A7:Yes - continue later
266A9:Set sNEGMANTISSA
266AC:Get next digit
266B2:Got one - continue
266B9:"0" ?
266BC:Yes - add zero digit
266BE:"1" - "9" ?
266C1:Yes - add digit
266C3:"." ?
266C6:Yes - add radix
266C8:"E" ?
266CB:Yes - add exponent
266D1:Add "0"
266D3:sLEADOK?
266D6:Yes - ignore the zero
266D8:numcounter++
266DA:No radix yet?
266DD:Not yet - continue
266DF:numcounter--
266E1:Set number exists
266EC:Add "1" - "9" - Set sLEADOK
266EF:Add digit
266F3:Add "."
266F6:No radix yet - continue
266F8:No second radix allowed - fail
266FC:Set radix exists
266FF:Continue
26703:Add "E"
26708:Set no number exists
2670B:And start assembling exponent
2670F:"E"
26716:Roll digit
26719:Roll mantissa
2671C:Not too many digits yet?
2671F:Not yet - continue normal loop
26721:Too many digits - drop low ones
26725=Start assembling the exponent
26725:Get 1st chr in exponent
26729:Got chr - continue
26730:sEXPSIGN exists?
26733:Yes - ignore sign tests
26735:"+" ?
26738:Yes - add "+"
2673A:Not "-" ?
2673D:Not "-", continue
2673F:Set sNEGEXP
26742:Set sEXPSIGN exists
26749:zero digit?
2674C:Yes - add it
2674E:nonzero digit?
26751:Yes - add it
26753:Not digit - failed
26757:Already 3 digit exponent?
2675A:Yes - fail
2675C:Shift exponent
26761:Add new digit to exponent
26764:Set expnum exists
26767:Set sEXPSIGN exists
2676A:Loop again
2676E=Got mantissa only
2676E:Lead ok?
26771:Yes - ass number
26773:Got no number?
26776:No number - check which error
26778:Set 0 result
2677B:Push %0
2677F:Got radix?
26782:Yes - failed
26784:Fail
26788=Got mantissa and exponent
26788:Received exponent?
2678B:Yes - continue
2678D:No - failed
26791:Clear mantissa sign
26794:Clear insign nibbles
26797:mantissa = 0?
2679A:Yes - push %0
2679C:Nonzero 1st digit?
267A1:Yes - continue
267A3:No - shift next digit up
267A9:Loop until nonzero 1st digit
267AD:C.A = mantsize
267AF:Positive exponent?
267B2:Yes - continue
267B4:No - negate exponent
267B6:Add mantsize to exponent
267B8:D.A = exponent
267BC:MaxExp+1
267C3:C.A = exponent D.A = #500
267C5:exponent < #500 ?
267C8:Yes - continue
267CA:No - negate #500
267CC:-#500 < exponent?
267CF:Yes - continue
267E9:Copy exponent to A.X
267EC:set sign = +
267EF:Positive mantissa?
267F2:Yes - continue
267F4:No - negate mantissa
2681A=chr meanings:
2681A=P=0: invalid
2681A=P=1: zero digit
2681A=P=2: nonzero digit
2681A=P=12: "+"
2681A=P=13: "-"
2681A=P=14: "E"
2681A=P=15: "."
2681A=CC if end of string
2681C:Init P=0 : Invalid chr
2681E:$len -= 2
26821:More to go
26824:Done - CC
26828:A.B = chr
2682B:Skip to next
2682E:C.W = separators
26831:chr > "9" ?
26834:Yes - check separators
2683C:chr < "0" ?
2683F:Yes - check separators
26841:P=1 : zero_digit
26843:A.B = 0-9
26846:zero digit?
26849:Yes - return
2684B:P=2: nozero_digit
2684F:Shift away "9"
26855:Shift away "0"
2685B:chr = "+" ?
2685E:Yes - return P=12: "+"
26860:Loop next chars
26862:P=13: "-" P=14: "E" P=15: "."
26867:Too many digits in mantissa
26886=(romp --> #)
268A4=(ROMPTR --> #)
268C2=(romptr --> #) #0 = standalone, #1=begin, #2=middle, #3=end
26906=Recall parser property (romp --> ob TRUE / FALSE )
2699F=Is ob romp with libnum >= #700? (ob --> flag)
26A2D=Is ob allowed in algebraics? (ob --> ob flag)
26B40=Is romptr command prop cleared? (romptr --> romptr flag )
26B73=Recall AKA property (romptr --> ob TRUE / romptr FALSE )
26BBD=Recall DISP property (ob --> ob' TRUE / ob FALSE )
26C47=(seco -> seco hex_display #args TRUE / seco hex #FFFFF TRUE)
26C65=(seco --> seco #args hxs )
26DD2=HXS 7 0140950
26DE3=HXS 6 014050
26DF3=HXS 8 01406050
26E05=HXS A 0140606050
26E19=HXS C 014060606050
26E2F=HXS E 01406060606050
26E47=HXS 5 00700
26E56=(hxs --> NameNot1st? #Priority1 #Priority2 Parentheses?)
26E56:A=stk D1=hxs
26E58:D1=len
26E62:A=hxs
26E6B:C=len
26E6E:B=len
26E70:A=len D1=stk
26E73:B=hxsend
26E75:A=stk D1=len
26E78:B=hxsend-1
26E7A:D1=body
26E7D:C=0
26E7F:C=prio1
26E83:R0=prio1
26E89:D1=dsp2
26E8C:C=FALSE
26E93:C.S=body2
26E97:body2-=2
26E9D:body2 is name?
26EA0:C=TRUE
26EA7:Skip name nibble
26EAA:A=dsp D1=stk
26EAD:stk1=NameNot1st?
26EB0:D1=dsp
26EB3:D1=dsp+1
26EBD:A=dsp+1 D1=dsp
26EC0:D1=dsp+1
26EC3:At end?
26EC8:Check if parentheses
26EDE:Yes parentheses
26EE5:R3=Parentheses?
26EEB:A=hxslast
26EED:D1=hxslast
26EF2:A=lastnib
26EF6:R1=lastnib
26F0D=(ob --> ob ob_der TRUE / ob FALSE )
270AF=(ob --> ob' TRUE / ob FALSE )
270AF=Libnum is checked to see what should be recalled
271B9=(ob --> ob' TRUE / ob FALSE )
27270=If copy type(stk1) <> C.A , then COLA else SKIP
2729B=          --> 'A+B' #1 SolverMask "A+B" #4 NULL$ TRUE TRUE )
2729B=(#0 SolverMask $ #loc $token --> 
2729B=Example: (#0 SolverMask "A+B" #2 "A"
27D32=0=normal arg, 2=symbolic, 3=quoted name
27D32=:: #n ARGDISPATCHIf ARG/SYMB QN <Other> ;
27D43:Normal arg?
27D4F:Symb arg?
27D57:'Skip'
27D5A:quoted name?
27D62:'Skip'
27D65:Drop
27D9A=:: #n DISPDSPTCH ( ? ? ? ) ? ? ? , ? ? ? = ? ? ? NAME <Other> ;
27DAB:Left parens?
27DBD:Right parens?
27DCB:Comma?
27DD9:Equal mark?
27DE7:Cmd name?
27E68=(2:Ob 1:$ -> 2:Ob 1:TRUE / 1:FALSE) True if $ is ";" or current radix
28296=(Meta #n -> #n-1-size(Meta) Meta)
283C4=:: :: :: COLAskipcola <Never> ; <Never> <This> <Never> ; <Rest> ;
28585=:: DROP COLACOLA ;
28A38=Internal _ (1:sym)
28BB4={ {} }
28D08=:: MARKDISPATCH ARG/SYMB/QN ( ) = , <Other> ;
2970A="Invalid Expression"
29A51=Gets NEG's display hex number's last nibble as # (-> #8)
29E21=Convert %% to % (A/B to A).
29E21=If Sticky bit is clear rounding direction is determined by
29E21=the last nibble in % mantissa.
29E23:%mantissa <> 0?
29E26:Yes - pack
29E28:No - return %0
29E2D:Determine rouding direction
29E30:No roundup - pack
29E36:%round =  %.000...1
29E39:Was low <> 500 ?
29E3C:Yes - SB determines rounding
29E3E:Round according to %lownum?
29E41:Yes - use %lownum
29E43:No - use roundup
29E46=Convert %% to % (A/B to A). Uses roundup
29E46=Obeys/sets over/underflow flags/indicators
29E48:%mantissa <> 0?
29E4B:Yes - continue
29E4D:No - return %0
29E52:Determine rounding direction
29E55:No roundup - pack
29E5B:%round = %.000...1
29E5E:Always jump
29E61:%round = %lownum
29E65:Add %round
29E68:No change in exponent
29E6B:Increase most significant num
29E72:Increase %%exponent
29E74:C.A = %%exponent
29E76:Determine exponent sign
29E78:Check negative exponent
29E82:%%exponent too big?
29E85:yes - error
29E8C:Max allowed negative exponent
29E93:%%exponent not too low?
29E96:Ok - continue
29E98:[Rad Grad 2D Underflow]
29EA2:Underflow not enabled?
29EA7:Not enabled - set indicators only
29EA9:"Positive Underflow"
29EB0:%% is positive?
29EB5:"Negative Undeflow"
29EBE:%% is negative?
29EC3:[Overflow Infinite Neg_ind Pos_ind]
29ECD:Set Pos_under_ind
29ED2:Always jump
29ED5:[Overflow Infinite Neg_ind Pos_ind]
29EDF:Set Neg_under_ind
29EE7:Return %0 because of underflow
29EEC:[Overflow Infinite Neg_ind Pos_ind]
29EF6:Overflow disabled?
29EFB:Yes - set indicators only
29EFD:"Overflow"
29F07:[Overflow_ind Infinite_ind NA NA]
29F11:Set Overflow_ind
29F19:%exponent = 499
29F24:%mantissa = 999999..
29F29=Does not obey under/overflow flags but sets indicators
29F29=Same as PACK, uses roundup
29F2B:%mantissa <> 0?
29F2E:Yes - continue
29F30:No - return %0
29F35:Determine rounding direction
29F38:No roundup
29F3B:Roundup
29F3E:No change in exponent
29F43:Increase significant digit
29F48:Increase exponent
29F4C:Determine exponent sign
29F4E:Negative exponent
29F58:Exponent too big?
29F5B:Yes - set indicators
29F5D:A = %number
29F69:Exponent not too small?
29F6C:No - continue
29F76=PACK, uses roundup
29F76=Does not obey under/overflow flags nor set indicators
29F78:%mantissa <> 0?
29F7B:Yes - continue
29F7D:No - return %0
29F82:Roundup?
29F85:No - continue
29F88:Increase mantissa
29F8B:Exponent ok
29F90:Increase significant digit
29F95:Increase exponent
29F99:Negative exponent?
29F9B:Yes - check it
29FA5:Exponent too big?
29FA8:Yes - return %MAXR
29FAA:A = %number
29FB6:Exponent not too small?
29FB9:Yes - return number
29FBB:No - return %0
29FC0:Return %MAXR
29FD0=Pop stk1 (%) cvt'd to %% into A.A/A.S/B.W, save regs
29FD0:A.W = %
29FD4:A & B = %%
29FDA=Pop stk1 (%) into A.W, save regs
29FF8=Pop stk2 and stk1 (%) into A/B and C/D as %%, save regs
2A002=Pop stk2 and stk1 (%) into A.W and C.W. save regs
2A060=Pop stk1 (%%) into A.A/A.S/B.W, save regs
2A0B1=Pop stk2 and stk1 (%%) into A.A/A.S/B.W and C.A/C.S/D.W, save regs
2A12A=If XM=0 nothing
2A12A=Else if P#3 then "Undefined Result" error
2A12A=Else if Infinite error is allowed then "Infinite Result"
2A12A=Else set Infinite Result indicator and return %%MAXR
2A12A:No error happened?
2A12D:Yes - return
2A12F:Check indicators?
2A136:"Undefined Result"
2A141=If Infinite error is allowed then "Infinite Result"
2A141=Else set Infinite Result indicator and return %%MAXR
2A141:[Overflow Infininite Neg_ind Pos_ind]
2A14D:Infinite error disabled?
2A152:Yes - set indicators only
2A154:"Infinite Result"
2A15E:[Overflow_ind Infinite_ind NA NA]
2A168:Set Infinite_ind
2A170:Set number to %%MAXR
2A188=Push A.W as %, restore regs
2A188=Output: R0.W = %number
2A18D:%mantissa <> 0?
2A190:Yes - continue
2A192:No - set %0
2A195:Save number to R0
2A235=Push A.A/A.S/B.W as %%, restore regs and continue RPL
2A23D=Push A.W as %, restore regs and continue RPL
2A24B=Push A.A/A.S/B.W as %%, restore regs
2A5B0=Internal LR->R (1:%% -> 1:%)
2A5C1=Internal R->LR (1:% -> 1:%%)
2A5D2=Internal DEG
2A5F0=Internal RAD
2A604=Internal GRAD
2A622=Internal D->R (1:% -> 1:%)
2A655=Internal R->D (1:% -> 1:%)
2A673=Internal ->HMS (1:% -> 1:%)
2A68C=Internal HMS-> (1:% -> 1:%)
2A6A0=Internal HMS+ (2:% 1:% -> 1:%)
2A6C8=Internal HMS- (2:% 1:% -> 1:%)
2A6DC=Internal MAX (2:%% 1:%% -> 1:%%)
2A6F5=Internal MAX (2:% 1:% -> 1:%max)
2A70E=Internal MIN (2:% 1:% -> 1:%min)
2A72F:D1 = ->num
2A732:Skip prolog, exponent
2A740:D1 = ->num
2A743:Skip prolog
2A746:Get sign to A.S
2A74A:D1 = ->stk
2A824:Set < test
2A876:Set < test
2A884:Set > test
2A88F:Set > test
2A89A:Set > and = test
2A8A5:Set > and = test
2A8B0:Set < and = test
2A8BB:Set < and = test
2A8C6:Set = test
2A8D1:Set ? and > and < test
2A8D7=Internal SIGN (1:% -> 1:%)
2A95B=Internal - (2:% 1:% -> 1:%%)
2A9A6=Internal * (2:% 1:% -> 1:%%)
2A9C9=Internal % (2:% 1:% -> 1:%)
2A9CE:x,y
2A9D2:x=0?
2A9D5:Yes - return x
2A9D9:x=x/100
2A9DE:x=x*y/100
2A9E4:Push x
2AA10:x,y
2AA14:swap x,y
2AA1A:A:B = y*100
2AA1E:push y*100/x
2AA25=Multiply A:B with 100
2AA25:x=0?
2AA28:Yes - CS
2AA2A:x=x*100
2AA39:R0:R1=x
2AA3F:A:B=-x
2AA45:A:B=y-x
2AA4B:C:D=y
2AA51:A:B=100(y-x)
2AA55:A:B=100(y-x)/y
2AA70=Internal ^ (2:% 1:% -> 1:%)  (Errors if not real result)
2AA9E=Internal INV (1:% -> 1:%%)
2AAAF=Internal INV (1:% -> 1:%)
2AB09=Internal SQRT (1:% (not <0)
2AB6E=Internal LN (1:% -> 1:%) (% >= 0)
2AB81=Internal LOG (1:% -> 1:%) (% >= 0)
2ACC1=Internal ASIN (1:% -> 1:%) (abs(arg)<=1)
2ACF1=Internal ACOS (1:% -> 1:%) (abs(arg)<=1)
2AD21=Internal ATAN (1:% -> 1:%)
2AE13=Internal ACOSH (1:% -> 1:%) (% >= 1)
2AE26=Internal ATANH (1:% -> 1:%) (-1 < % < 1)
2AEF6=If Radians ST=0 4, ST=1 9. Else ST=0 9 and If Degrees ST=1 4
2AF27=Internal ->HMS (1:%%)
2AF3A=Internal HMS-> (1:% -> 1:%%)
2B044=Internal RDZ (1:% ->)
2B07B=Deep internal RDZ (1:%)
2B0C4=Internal ! (1:% -> 1:%)
2B171=(1:%integer)
2B45C=(2:% 1:% -> 2:%% 1:%%)
2B470=(2:%% 1:%% -> 2:% 1:%)
2B529=Internal RND (2:% 1:% -> 1:%)
2B53D=Internal TRNC (2:% 1:% -> 1:%)
2B551=RND (2:Ob 1:#parter -> 1:Ob)
2B55D=TRNC (2:Ob 1:#parter -> 1:Ob)
2B590=Used by RND etc (1:% -> 1:#parter) Example: (1:%8 -> 1:<81h>)
2B716=Needs HS=0 3
2B731=SINH in R0,R1 ; COSH in A.W,B.W
2B789=INV of %%
2B789:[XM, SB]
2B794:C:D = 1
2B7A0:A:B = 1, C:D = num
2B7A3:Divide
2B7AA:Set negative
2B7B0:Set positive
2B7B8:C:D = 1 (+/-)
2B7C4:Do RADDF
2B7CA=A:B = A:B + C:D
2B7CA=Input: [XM,SB]=0
2B7CA=Uses: A.W B.W C.W D.W P D0
2B7CA:Set RADDF
2B7D3:[XM,SB]=0
2B7D6:Do ADDF
2B7DC:Set ADDF
2B7DE:A=exp1,s1 B=mant1 C=exp2,s2 D=mant2
2B7E1:B=exp2,sign2  C=mant1
2B7E4:Save P to C.S
2B7E8:Save C.A to D0
2B7ED:C.4 = 5
2B7F0:Unsign exponents
2B7F8:Restore C.A from D0
2B7FB:Clear meaningles nib in mant2
2B7FE:Restore P from C.S
2B802:mant2=0?
2B805:Yes - nothing to add
2B807:mant1<>0?
2B80A:Yes - continue
2B80C:A=exp2,sign2 B=exp1,sign1
2B80F:C=mant2 D=mant1
2B812=now C:D is zero
2B812:RADDF?
2B815:Yes - handle RADDF x+0
2B817:No - handle ADDF x+0
2B823:exp1>exp2?
2B826:Yes - add big1
2B828:exp1<exp2?
2B82B:Yes - add big2
2B82D:mant2<=mant1 ?
2B830:Yes - add mantissas
2B832:No exchange mantissas
2B838:Add mantissas
2B83B:Get bigger number to A
2B841:Same signs?
2B844:Yes - continue
2B846:No - correct A
2B84B=Equal exponents, bigger mantissa in C, add mantissas
2B84D:B.A = exp1-exp2
2B84F:Save C.A
2B854:ADDF?
2B859=RADDF add
2B861:num1 >> num2
2B87C:Restore C.A
2B884:Set SB to mark num1 >> num2
2B889:Save lost digit to P
2B88D:Shift mant2
2B892:until exponents match
2B895:Get mant2 back
2B898=RADDF x+y, equal exponent in A.A
2B898:Save C.S
2B89C:Set carry if need rounding
2B89F:Restore C.S
2B8A3:no rounding
2B8A6:Increase mant2 for rounding
2B8A9:Same signs?
2B8AC:Yes - add
2B8AE:No -substract mantissas
2B8B1:Done
2B8B4:Add mantissas
2B8B7:Done
2B8BB=ADDF add
2B8C6:Common significant digits
2B8C9:num1 >> num2, nothing to add
2B8CE:Set SB to mark num1 >> num2
2B8D3:Shift num2 to match exp1
2B8DB=ADDF x+y, equal exponent in A.A
2B8DB:Same signs?
2B8DE:Yes - add
2B8E0:No -substract. was num1 ~= num2?
2B8E3:Yes - continue
2B8E5:No - increase num2 by 1
2B8E8:mant=mant1-mant2
2B8EB:Nonzero result?
2B8EE:Yes - continue
2B8F0:No - clear sign
2B8F6:If ST10 and ST11 are clr then
2B8F8:return +0
2B8FD:Else return -0
2B903:mant=mant1+mant2
2B906:set mantissa
2B909:Get back signed exponent
2B918:Do MULTF
2B91E:mantissas to C and D
2B921:Clr extra nibbles
2B927:exp = exp1+exp2
2B929:sign = sign1*sign2
2B932:Init result to 0
2B935:mant1=0?
2B938:Yes - normalize result
2B93A:mant2=0?
2B93D:Yes - normalize result
2B94A:Add plane
2B94D:signif digit--
2B950:non zero - add plane
2B956:Loop all digits
2B95E:No need to shift back?
2B961:Yes - normalize
2B963:No - shift back one place
2B968:Normalize result
2B971:Do DIVF
2B977:mantissas to C and D
2B97A:Clr extra nibs
2B980:Divider <> 0?
2B983:Yes - continue
2B985:Denominator<>0?
2B988:No - do x/0
2B98C:0/0
2B994:sign = sign1*sign2
2B9A5:error = 8
2B9A8:Set inf
2B9AD:A=s0000..00F00
2B9B2:B=09999..9000
2B9B5:Check indicators
2B9B7:Return XM
2B9B9:exp = exp1-exp2
2B9BB:sign = sign1*sign2
2B9F3=SQRT of A:B
2B9F3=Uses A.W B.W C.W P
2B9F3:[XM,SB]
2B9F6:Check if A:B is uinf
2BA00:No uinf, continue
2BA03:Is x unf?
2BA06:Yes - sqrt(unf)=unf
2BA08:Negative?
2BA0B:Yes - do sqrt(-inf)
2BA0D:No - return sqrt(inf)=inf
2BA0F:Clr extra nib
2BA12:C=mant
2BA15:Mant=0?
2BA1A:Positive?
2BA1D:Yes - continue
2BA21:sqrt(-x)
2BA8E:sqrt(0)
2BA91:mant=0?
2BA94:Yes - ok
2BA96:No - set inf result
2BAA1=If P=0 then ADDF	x=x+y
2BAA1=If P=1 then MULTF	x=x*y
2BAA1=If P=2 then DIVF	x=x/y
2BAA1=If P=3 then RADDF	x=x+y
2BAA1=unf+y=unf inf+y=inf  unf+inf=unf inf+unf=unf inf+inf=inf    inf-inf=unf.0F 
2BAA1=unf*y=unf inf*y=yinf unf*inf=unf inf*unf=unf inf*inf=inf    inf*0=unf.16
2BAA1=unf/y=unf inf/y=yinf unf/inf=unf inf/unf=unf inf/inf=unf.0E
2BAA1=unf+y=unf inf+y=inf  unf+inf=unf inf+unf=unf inf+inf=inf    inf-inf=unf.0F
2BAA1:Clear extra nib in mant1
2BAA4:Clear extra nib in mat2
2BAA7:Check if C:D is inf
2BAAF:Yes - dispatch
2BAB2:Check if A:B is uinf
2BABA:Yes - dispatch
2BABD:No - dispatch what to do
2BADC=A:B is uinf, C:D is ok, dispatch
2BADC:If unf then return unf
2BAE1:DIVF?
2BAE6:ADDF?
2BAE9:Yes - return A:B
2BAEB:RADDF?
2BAEE:Yes - return A:B
2BAF7:inf*0
2BAFF=C:D is uinf, dispatch
2BB01:If A:D uinf too?
2BB06:C:D is unf?
2BB09:Yes - return unf
2BB0B:DIVF?
2BB0E:Yes - return signed 0
2BB10:ADDF?
2BB13:Yes - return inf
2BB15:RADDF?
2BB18:Yes - return inf
2BB1A:mant1 = 0?
2BB1F:Return inf with sign s1*s2
2BB24:Return signed zero, sign = s1*s2
2BB29:sign = s1*s2
2BB34=Both A:B and C:D uinf
2BB34:C:D is unf?
2BB37:Yes - check A:C
2BB39:C:D is inf, A:B is unf?
2BB3C:Yes - return unf
2BB3E:ADDF?
2BB41:Yes - inf+inf
2BB43:RADDF?
2BB46:Yes - inf+inf
2BB48:MULTF?
2BB4F:inf/inf
2BB5F:Different signs?
2BB62:Yes - error inf-inf
2BB64:No - return inf as inf+inf
2BB66=A:B is uinf, C:D is unf
2BB66:A:B unf too?
2BB69:Yes - check
2BB6B:No - return unf
2BB72=Both A:B and C:D are unf
2BB84:Restore mantissa2
2BB8C=Set undefined result to C.B
2BB8C=Output: A.W = 0, A.X = #F01
2BB8C=        B.W = 0, B.XS = F, B.12.11 = reason
2BB8C:mant1=0
2BB92:sign1=0 exp1=0
2BB97:Set inf
2BB9C:exp1=#F01
2BBA3:mant1>>1
2BBA9:Loop until P=5
2BBAE:Clear SB
2BBB1:Set undefined result error
2BBB3:Set XM to mark error
2BBB5=Divide A:B with 2
2BBB5=Uses: A.W B.W C.W
2BBB7:mantissa = 0?
2BBBA:Yes - return
2BBBC=Divide A:B with 2. Doesn't check if mantissa is zero.
2BBBC=Uses A.W B.W C.W
2BBBC:Clear extra nibble
2BBBF:10/
2BBC1:Copy mantissa
2BBC4:2*
2BBC7:4*
2BBCA:5*
2BBCD:No need to scroll exponent?
2BBD2:Scroll mantissa down
2BBD5:Increase exponent
2BBD9=A:B = A:B * 2
2BBD9=Uses: A.W B.W
2BBD9:Clear extra nib
2BBDC:Double mantissa
2BBDF:Always jump
2BBE2=%%IP of A:B
2BBE2=Uses: C.A P
2BBE2:Get digits to clear
2BBE6:Number ok as is?
2BBE9:Yes - return
2BBEB:Mantissa 0?
2BBEE:Yes - return as is
2BBF0:Clear extra numbers
2BBF3:Done if P <=13
2BBF6:Done
2BBF8:Clear exponent
2BBFC=Return number of fractional digits in A:B in P
2BBFC=If 15 then none, if 14 then exp should be cleared.
2BBFC:Check if uinf
2BC06:Yes - return uinf
2BC0D:Mantissa <> 0?
2BC10:Yes - continue
2BC12:No - clear exponent
2BC18:C = accuracy
2BC1C:C = digits in IP
2BC1E:Too big number
2BC23:Number of digits < 10?
2BC26:Yes - return digits
2BC28:Add 10
2BC2D:P = digits to erase
2BC33:digits++
2BC35:Number ok as is
2BC41:Too big exponent?
2BC44:Yes - return 14
2BC46:Number ok as is, return 15
2BC4A=Convert % to %% (A to A:B) CS if uinf
2BC62:Check if uinf
2BC6C:Not uinf, continue
2BC6F:Return uinf
2BC77=Normalize %% in A:B so that mantissa starts with nonzero digit
2BC80:Mantissa 0?
2BC83:Yes - return 0
2BC85:1st digit nonzero?
2BC88:Yes - done
2BC8A:No - exp--
2BC8C:mant<<1
2BC8F:loop until 1st digit nonzero
2BC93:0 mantissa - clear exp
2BC9B:B.S=0
2BCA0=Convert % to %% (A to A:B and C to C:D)
2BCA0:Trickery to save 1 RSTK level
2BCA2:No problem since D.A will be
2BCA4:part of the result
2BCAC=Convert % to %% (C to C:D)  CS if uinf
2BCC4:Check if uinf
2BCCE:Not uinf - continue
2BCD1:Return uinf
2BD02=Return carry set if A:B is uinf
2BD0E=Return carry set if C:D is uinf
2BD1A=Adds 5 to A.XS and C.XS. This gives you unsigned exponents to compare
2BD1A:Get C.XS to B.XS
2BD1F:Save C.XS to P, C.XS=5
2BD23:Add 5 to A.XS
2BD26:Add 5 to C.XS
2BD29:Resume old settings
2BD32=Set carry if A.W <= C.W (%)
2BD32:Different signs?
2BD35:Yes - if A is negative then A<C
2BD37:No - test mantissa
2BD39:If A=0 then A<=C
2BD3E:A>0, is C>0?
2BD41:Yes - test numbers
2BD43:No - A>C, return CC
2BD45:Different exponents?
2BD48:Yes - test exponents
2BD4A:No is mant2 < mant1?
2BD4D:Yes - is A negative?
2BD4F:No - is mant1==mant2?
2BD52:Yes - return CS
2BD54:No - is A nonnegative?
2BD57:Make exponent unsigned
2BD5B:If exp C < exp A then
2BD5E: If A<0 then A<C
2BD60: Else if A>=0 then A<C
2BD64=Set carry if %% in A:B >=0 or % in A >=0
2BD6F=Set carry if %% in A:B or % in A is negative
2BD76=If P=1, AB < CD? (P=4 >, P=6 >=, P=3 <=, P=2 =, P=13 <>)
2BD76:D.S = sign2
2BD79:P=sign2, C.S = test
2BD7D:C.S = sign2, D.S = test
2BD80:Reverse exp sign in A:B
2BD84:Reverse exp sign in C:D
2BD93:B.S=sign2 B.A=exp2 C.W=mant1
2BDAF:Set < is true
2BDB1:C.S = result
2BDB5:D.S = result&test
2BDB9:B.W = mant1 C.S=sign2 C.A=exp2
2BDBC:Get old exp1 sign
2BDC0:Get old exp2 sign
2BDC4:B.S = result&test
2BDC7:P = result&test
2BDCB:Clr meaningles nib
2BDCE:C.S = sign2
2BDD1:Test succesfull?
2BDD4:Yes - set carry
2BDD6:Clr meaningless nib
2BDD9:Return
2BDE1:B.S=sign2 B.A=exp2 C.W=mant1
2BDF1:Set > is true
2BDF9:mant1=0?
2BDFE:mant2<>0?
2BE06:mant2<>0?
2BE0B:Set = is true
2BE53=AB <--> CD
2BE61=Store A.W to R0, B.W to R1
2BE6F=Store A.W to R2, B.W to R3
2BE7D=Store C.W to R0, D.W to R1
2BE8B=Store C.W to R2, D.W to R3
2BE99=Exchange A.W with R0, B.W with R1
2BEA7=Exchange A.W with R2, B.W with R3
2BEB5=Recall R0 to A.W, R1 to B.W
2BEC0=Recall R2 to A.W, R3 to B.W
2BECB=Recall R0 to C.W, R1 to D.W
2BED6=Recall R2 to C.W, R3 to D.W
2BFE3=Get %% to A and B from D1
2BFE3:A.A=exp
2BFE9:B.A=exp
2BFEB:A.W=mantissa+sign
2BFF2:B.S=sign
2BFF5:Clr meaningles nibble
2BFF8:A.S=sign A.A=exp B.W=mant
2C04B=Puts %% from A and B to D0
2C09F=Internal UTPN (3:% 2:% 1:% -> 1:%)
2C149=Internal UTPC (2:% 1:% -> 1:%) (SWAP%0 UTPCin)
2C174=Internal UTPF (3:% 2:% 1:% -> 1:%) (UNROT UTPFin)
2C19A=Internal UTPT (2:% 1:% -> 1:%) (SWAP%0 UTPTin)
2C1F3=Internal STOSigma (1:Any)
2C22F=Internal CLSigma
2C293=Internal RCLSigma -> Contents True/False
2C2AC=Internal RCLSigma
2C2C5=Recalls sigmaDAT & checks it is a real array
2C2D9=Internal Sigma+ (1:%)
2C2E8=Stores [%] in ID_sigmaDAT (1:%)
2C32E=Internal Sigma+ (1:Array)
2C423=Internal Sigma-
2C4B4=(1:#dim -> 2:#dim 1:[%0 %0 ... %0])
2C4D7=3:[[]] 2:[] 1:#dim -> 2:[[]] 1:[])
2C4D7=Copies last row from 2D array on stk3 to 1D array on stk2
2C535=Internal NSigma
2C558=Internal MAXSigma
2C571=Internal MEAN
2C58A=Internal MINSigma
2C5A3=Internal SDEV
2C5BC=Internal TOT
2C5D5=Internal VAR
2C684=Internal COLSigma (2:%/Array,1:%)
2C6A2=Store levels 1-5 into 'SigmaPAR'
2C6C5=Internal XCOL (1:%)
2C6DE=Internal YCOL (1:%)
2C72E=Recalls & explodes sigmaPAR (makes one if necessary)
2C751=Makes & stores default sigmaPAR
2C84B=Internal CORR
2C8F5=Internal COV
2C94F=Internal SigmaX
2C963=Internal SigmaY
2C977=Internal SigmaX^2
2C99A=Internal SigmaY^2
2C9BD=Internal SigmaX*Y
2CA30=Internal LR (Doesn't ->TAG with "Intercept" and "Slope")
2CB02=Internal PREDY (1:% -> 1:%)
2CB75=Internal PREDX (1:% -> 1:%)
2CCBA=(1:[[]] -> 1:%rows)
2CCDF=(2:#column 1:[[]] -> 1:%)
2CCF8=(2:#column 1:[[]] -> 1:%)
2CEC0=X*Y (7:#colx 6:#coly 5:[[%]] 4:%%0 3:%%0 2:False 1:False -> 1:%%)
2CF5F=(3:#col1 2:#col2 1:[[]] -> same) Errors is columns do not exist
2D271=Checks that stk1 is a valid array for stat operations
2D396=##A
2D441=Stores stk1 to LAM_'KP
2D730=If IO message flag clear, display $ with DISPROW2
2D74E=If IO message flag clear, display $ with DISPSTATUS2
2D76C=(4:#m 3:Ob1 2:#n 1:#ob2 -> (3:#m 2:Ob1 1:T/F)
2D76C=True if Ob1 and Ob2 and Ob2 are EQUAL AND #n is #m (#=)
2D816=Internal RECN (1:$/ID/LAM) (If NULL$TEMP then this is RECV)
2D9F5=Internal SERVER
2DA4A=SKIP if flag -39 is set
2DC39=(1:$ -> 1:$) Appends VARS names, types, sizes and checksums to $
2DC39=Just try with "" on stk1
2DC52=(3:$ 2:{} 1:#len -> 1:$) Appends VARS names, types...
2DDEC=:: TOADISP REDISPABUFF ClrDAsOK ;
2E4A5=If #A03= then ABORT
2E5AB=Internal SEND (1:ID/LAM)
2E6EB=Internal SEND (1:{})
2E7A4=If Ob other than LAM/ID? (1:Ob -> 2:Ob 1:T/F)
2E7C2=(1:ID/LAM) Errors undefined LAM/ID
2E7EF=Internal KGET (1:$/ID/LAM)
2E835=Internal KGET (1:{})
2E876=Internal FINISH
2E8D1=Internal PKT (2:$ 1:$)
2E99E={ 9600 0 0 0 3 1 }	(default iopar)
2EA4F=Recalls IOPAR
2EA6A=(1:ID)
2EB19=:: TOADISP REDISPABUFF ;
2EB37=User OPENIO does P324C8 too ??
2EC11=ABS(IP(%)) -> #
2EC52=(1:#baud -> 2:#baud 1:T/F)
2EC84=Internal BAUD (1:%)
2ECCA=Internal PARITY (1:%)
2ED10=Internal TRANSIO (1:%)
2ED4C=Internal CKSM (1:%)
2EDA6=Internal KERRM
2EDB0=Overwrites stk1 with last kermit error message (@705F6)
2EDE1=Internal BUFLEN
2EDF5=Internal STIME (1:%)
2EE18=Internal SBRK
2EE31=Saves # as SavedErr
2EE6F=Internal XMIT (1:$)
2EE97=Internal SRECV (1:%)
2EFA0=If #0 then #A03 GETTHEMESG, else GETTHEMESG
2FEA1=Sends CHR_Y with SENDPKT
2FFBA=D1=addr of $ -> C.A = length in bytes, D1 = address of body
3017A=(2:$ 1:#mode -> 1:$)
3017A=Does character translations in string
30370=(-> #) Fetches translate code (and checks validity) from IOPAR
303AC=Makes tranfer header string (-> 1:$)
303B6=(1:#translatecode -> 1:$) (->1:FALSE if illegal code)
30477=(1:$TRANSSTRING ->)
305ED=B.A = strlen in bytes, D1 = strbody -> B.A=lenght left, D1='true' body
305ED=Carry set if no 'true' chars in string
305ED=SkipSepChars
305ED=Skips separator chars in string (code <= 32 = space)
3073A=(1:$ -> 2:$ 1:TRUE/FALSE) Returns true if $ starts with VERSTRING
30771=Checks flag -35
30794=Binary file header (HPHP48-E for me) (-> 1:$)
30805=Nth char of string as # (2:$ 1:# -> 1:#)
30E7D=Initialize UART
30E7D=Sets BAU bitsto 9600, clears IOC, IRC, RECVHEAD
30E7F:BAU bits to 9600
30E82=Initialize UART.
30E82=Input: C.0 = BAU bits
30E82:Clear [SON ETBE ERBF ERBZ]
30E90:Clear [EIRU EIRI IRE]
30E98:Set BAU bits now that SON is off
30EAD:D0 = ->RECVHEAD
30EB3:Clear receiver header
30EBC=Initialize UART for receiving
30EBC=(Enable interrupts on receive buzy and receive buffer full)
30EBC=Input: C.0 = BAU bits
30EBC:Init UART to C.0 BAU
30EC9:[SON ERBF ERBZ]
315C6=Internal CLOSEIO
31868=Internal CR
318A4=Internal PRSTC
318FE=Internal PR1
3194E=Prints object (Not Grob)
31A25=Internal PRST
31D56=Internal PRVAR (1:ID/LAM)
31D7E=Prints object (1:Any) ??
31DAB=Internal OLDPRT
31EE2=Internal PRLCD
31FFD=Internal DELAY (1:%)
3259D=Exits to rpl via executing rpl at C.A (after GETPTR)
32B74=Prints Grob ??
32F77=Internal ROOT (3:sym/seco 2:ID 1:%/C%/{}/Unit)
32F9F={ LAM_'nohalt }
32FC2=:: ERRORSTO CK0NOLASTWD ERRORJMP ;
3304E={ <Eh> }
34D3C=(3:EXT/SYMB 2:#length / {#start #stop} 1:null$ -> 2:$new 1:TRUE / ?)
34D3C=(length is max length, use #FFFFF for all)
34DBB=Hidden Variable Name for algebraic being decompiled
35236=(% --> flag ) Returns FALSE if % is integer in -1000 < n < 1000
35491=:: OVER matchob? ?SKIP >TCOMP ;
35491=Adds obj to a {} if not already there (2:{} 1:Ob -> 1:{})
354AF=(1:Ob -> 1:TRUE/FALSE) True if Not INHARDROM? && TYPESYMB/COL
3558E=Get element (2:[%] / [C%] 1:#element -> 2:[%] / [C%] 1:%)
355B8=Get element (2:[%] 1:#element -> 2:[%] 1:%)
355C8=Get element (2:[C%] 1:#element -> 2:[C%] 1:C%)
355D8=(2:[] 1:#element -> 2:[] 1:%% or C%%
355D8=Get element % or C%, convert to long
35602=Get element (2:[%%] 1:#element -> 2:[%%] 1:%%) (% too)
35619=Get element (2:[C%%] 1:#element -> 2:[C%%] 1:C%%) (C% too)
35628=Put element (3:[%] 2:% 1:#element -> 1:[%]) (%% C% and C%% too)
3566F=Put element (3:[%] 2:% 1:#element -> 1:[%] )
356B3=Pop # to A.A, % to R0.W (--> D1 in C.A, D1 = body of %)
356F3=Put element (3:[C%] 2:C% 1:#element -> 1:[C%] )
357A8=Get [] dims (1:1D[] -> 2:#m 1:False / 1:2D[] -> 3:#m 2:#m 1:True)
35804=Addition in long format (% % --> %) No errors generated
3581E=Substract in long format (% % --> % ) No errors generated
35A7A=If % in @D0 <> 0 then store long(A*B)+R0:R1 to R0:R1, else CS
35AF6=Dispatch order: rr, cr, rc, cc
35B4F=Example: :: SWITCHFLOATS %CHS C%CHS %%CHS C%%CHS ; negates all
35C2C=(2:prg 1:[]) 
35C2C=Example: !MATNEG = :: ' B%NEG SWAP DOARRYPRG1 ;
35C2C=Operate on elements (%, %%, C% or C%%)
35C63=(3:prg 2:[% or %% orig] 1:[C% or C%% new] -> 1:[same type as 1:]
35C63=Operate on matrix elements on same location
35CAE=Internal CON (2:[%] 1:% -> 1:% / 2:[C%] 1:C% -> 1:[C%])
35CC2=CON (2:% 1:[])   (Makes [] a user object if needed)
35CCC=CON (2:% 1:[]) Doesn't do CKREF (might change variable contents)
35CEA=%>C% on stack level 2 (% ob --> C% ob)
35D35=Internal IDN (1:[]) (Does NEWOB if necessary)
35D53=Internal IDN (1:[]) (Does User Obj if necessary)
35D71=Internal IDN (1:[]) (Doesn't NEWOB, might change variables)
35DEB=Internal NEG (1:[] -> 1:[]) (Does NEWOB if necessary)
35DFF=Internal NEG (1:Array)
35E09=:: ' B%NEG SWAP DOARRYPRG1 ;
35E09=Internal NEG (1:Array) (Doesn't NEWOB)
35E2C=:: ' DORND DOARRYPART ;
35E2C=Internal RND (2:[] 1:% -> 1:[])
35E3B=(2:[] 1:%parter -> 1:[])
35E3B=Execute rounding program :: %element1 #parter prg %element2.. ;
35EA9=:: ' DOTRNC DOARRYPART ;
35EA9=Internal TRNC (2:[] 1:%)
35EC2=:: ' DORND DOCMPPART ;
35EC2=Internal RND (2:C% 1:% -> 1:C%) 
35ED1=(3:C% 2:#parter 1:prg)
35ED1=Execute rounding program :: %re #parter prg %im #parter prg ;
35F17=:: ' DOTRNC DOCMPPART ;
35F17=Internal TRNC (2:C% 1:% -> 1:C%)
35F30=Internal CONJ (1:[] -> 1:[]) (Does NEWOB if necessary)
35F53=Internal CONJ (1:Array) (Does user obj if necessary)
35F6C=:: ' C%%CONJ SWAP DOPRG1[] ;
35F6C=Internal CONJ (1:[C%]) (Doesn't NEWOB)
35F8F=Internal RE (1:[] -> 1:[])
35FA3=Make 0 Array (1:[] --> 2:[] 1:[%0])
35FEE=Internal IM (1:[] -> 1:[])
36039=Internal R->C (2:[%re] 1:[%im] -> 1:[C%])
360B6=Internal C->R (1:[C%] -> 2:[%re] 1:[%im])
36115=Internal + (2:[] 1:[] -> 1:[])
36129=([F%] [F%] prg prg --> [F%] )
361C9=(2:[] 1:[] -> 1:[]) No newob for stk1
36278=Internal - (2:[] 1:[] -> 1:[])
362DC=Internal * (2:%/C%/[] 1:%/C%/[] -> 1:[])
363CC=Internal / (2:[] 1:%/C% -> 1:[])
36435=Internal SQ (1:[] -> 1:[])
3643F=Internal * (2:[] 1:[] -> 1:[])
365AC=Internal RSD (3:[] 2:[] 1:[] -> 1:[])
366F6=Internal DOT (2:[] 1:[] -> 1:[])
3675A=Converts %% to % (Or C%% to C%). Does nothing for % or C%
36782=Internal CROSS (2:[] 1:[] -> 1:[])
36796={ <3h> }
367C3=(3:#m 2:#n 1:[] -> 4:%%elementm 3:%%elementn 2:#m 1:#n)
367FA=(4:%% 3:%% 2:%% 1:%% -> 4%%*1%%-3%%*2%% (det) )
36868=If either arry is [C%] returns C%0, else %0 ([F%] [F%] --> F%0)
368CC={ %3 }
368E5=Internal RNRM (1:[] -> 1:%)
368F9=Internal CNRM (1:[] -> 1:%)
3690D=Internal RNRM...(1:[])
369CB=Internal ABS (1:[] -> 1:%)
36A2A=Internal DET (1:[] -> 1:%/C%)
36AC5=DET of 2*2 matrix (2:[] 1:#2 -> 1:det)
36B0B=Internal INV (1:[] -> 1:[]) (Does NEWOB if necessary)
36B24=Internal INV (1:[]) (Does User obj if necessary)
36B33=Internal INV (2:#side 1:[]) (Doesn't NEWOB, no square check)
36B60=Internal / (2:[] 1:[] -> 1:[])
36BF1={ LAM_#a LAM_#b }
36CEA={ LAM_#b NULLLAM }
36D41=DET (size > 2) (2:[] 1:#side -> 3:[] 2:%% or C%% 1:#)
36D5A={NULLLAM NULLLAM}
36D82={NULLLAM NULLLAM NULLLAM}
36DEB=:: C%%CHS C%%CONJ ;
36F6C=([] -> [] %%1/C%%1)
3742D=Makes HXS of length #len (Random data) (1:#len -> 1:HXS)
3745E=Swap 2 rows in [] (3:[] 2:# 1:# -> 3:[] 2:# 1:#) (Doesn't do TEMPOB)
37500=Swap 2 colums in [] (3:[] 2:# 1:# -> 3:[] 2:# 1:#) (Doesn't do TEMPOB)
375B0=Correct format?? (Long real? Real?)
375B0=Stores array contents to HXS (2:[] 1:HXS -> 1:[])
376AE=(2:#n 1:$ -> 1:#chrcode) Gets Nth char as #
376AE=True meaning probably something else
37820=If A is 02933 then ST=0 0, else ST=1 0 (Uses C.A)
37AFE=Make Imaginary parts 0 (1:[%] or [C%] -> 1:[C%])
37B1C=:: DROP %%0 %%>C% ;
37B44=If obj in TEMPOB, not embedded, not referenced, nothing, else NEWOB
37B5D=If REF? then make new copy to TEMPOB
37B7B=:: DUP MDIMS ?SEMI?SETInvDimERR #= ?SEMI?SETInvDimERR ;
37B7B=If not square matrix, then error (1:[] -> 2:[] 1:#side)
37B9E=If DIMS not same, then error (2:[] 1:[] -> 2:[] 1:[])
37BCB=:: DUP ARSIZE COLA #1+_ONE_DO ;
37BCB=Start Loop through [] ( #elements+1 ONE DO )
37BE9=Addition in long format (F% F% --> F%  /  L% L% --> L% )
37C20=Addition in long format ( C% C% --> C% )
37C48=Addition in long format ( % C% --> C% )
37C66=Addition in long format ( C% % --> C% )
37C7A=Substract in long format (F% F% --> F%  /  L% L% --> L% ) 
37CB1=Substract in long format (C% C% --> C%)
37CC5=Substract in long format (% C% --> C%)
37CD9=Substract in long format (C% % --> C%)
37CED=Multiply long floats (L% L% --> L%) (NOPs for short floats)
37D24=Divide long floats (L% L% --> L%) (NOPs for short floats)
37D5B=ABS (B% --> B%)
37D7E=NEG (B% --> B%)
37DA1=Equal to zero? (B% --> flag)
37DC4=Float to long float (% --> %%  / C% --> C%%)
37DE2=Error: Invalid Dimension
37DF6=:: ?SEMI SETInvDimERR ;
37E0F=REDIM array (2:[] 1:{#dims} -> 1:[]) (makes TEMPOB if necessary)
37E2D=REDIM array (2:[] 1:{#dims} -> 1:[] (makes UserObject if necessary)
37E4B=(2:[] 1:{#m #n} -> 6:[] 5: #elements 4:#m*#n 3:#m 2:#n 1:TWO)
37E4B=(2:[] 1:{#m} -> 5:[] 4:elements 3:#m 2:#m 1:ONE)
37E4B=Used by RDM to check dimensions
3811F=Internal TRN (1:2D[] -> 2D[]) (Makes NEWOB if necessary)
3814C=Internal TRN (1:2D[] -> 2D[]) (Makes user object if necessary)
38179=Internal TRN (1:2D[] -> 2D[]) (Does no NEWOB)
3834F=Link table for library 0F0 (XLIB 240)
3858E=Starts system UI after warmstart (Configs etc already done before)
385A7=No errortrap for memory out situations!!
3866F=Update display menu bar
386A1=Update display stack area if no key in keybuffer
386D8=Display a warning if Alarm or LowBat)
386EC=:: <Eh> #AND ;
38908=Beeps, displays (&freezes) error message (Makes TOADISP!!)
38926=Flash a warning message (1:$)
38994=:: POLSetUI POLKeyUI ;
389BC=Save current user interface in a temporary environment (no args)
389CB=Recall current user interface
38A11=Recall system interface (-> 5:LASTMENU 4:# 3:prg 2:MenuRow@ 1:<4h>)
38A3E=Temporary storage for user interface (parametrized outer loop)
38A64=Set current user interface (same args as to ParOuterLoop)
38AEB=Executes set user interface
38B09=Executes set user interface only once
38B77=Handles UI errors if POLRestoreUI doesn't
38B90=Restore saved UI (POLSaveUI) and ABND (no args)
38C08=Store display update object for UI
38C18=(-> 2:prg 1:True / 1:False)
38C38=Store Hard key assignments for UI
38C68=Store Exit condition program for UI (Must return True or False)
38C78=Recall user interface exit program
38C98=Store UI error program
38CFB=ParOuterLoop on by user? (-> 1:True/False)
38F8C=ClrDAsOK SetDAsBad ClrDA2RollF ClrNoRollDA2
38FD2=SetDA1ValidF ClrDA1Bad ClrDA1IsStat
38FEB=SetDA2aValidF ClrDA2aBad
38FFF=SetDA2bValidF ClrDA2bBad ClrSomeEditRequest
39018=SetDA3ValidF ClrDA3Bad
3902C=Freeze display area 1 (Status area)
3902C=SetDA1TempF ClrDA1Bad ClrDA1IsStat
39045=SetDA2aTempF ClrDA2aBad
39059=SetDA2bTempF ClrDA2bBad ClrSomeEditRequest
39072=SetDA3TempF ClrDA3Bad
39072=freeze menu area
39086=EditExst?NOT ITE SetDA2RollF SetDA2aNoCh
390CC=ClrDA1ValidF ClrDA1TempF ClrDA1NoCh
390CC=Tell the 48 to redraw the display area 1 when prg ends
390E5=ClrDA2aValidF ClrDA2aTempF ClrDA2aNoCh
390FE=ClrDA2bValidF ClrDA2bTempF ClrDA2bNoCh
3912B=ClrDA3ValidF ClrDA3TempF ClrDA3NoCh
3912B=Tell the 48 to redraw the display area 3 when prg ends
39144=Tell the 48 to redraw the lcd when prg ends
3921B=Freeze display area 1&2 (Status & Stack)
39248=True, if any DAxBad? is True
39531=Suspend ticking clock display
3959C=Update status area if keybuffer is empty
39632=Displays the output of AlgEntryStat, ComVecStatus etc
39673=(-> 4:$ 3:# 2:# 1:#)
396C8=Rcl Complex mode (-> 4:$ 3:<16h> 2:<14h> 1:<25h> )
3970E=if ''halt' exists, then "HALT", else ""; <27h>, <25h>, <38h>
3975C=Clears chars from $ according to flags 1-5 (1:"_____" -> 1:$)
397CA=Recalls "USR1" or "USER"
39958=:: <6h> <8h> BLANKIT ;
39971=Makes path & clock grobs ( clock? --> grob grob flag)
39A06=(1:DIR -> 1:UPPERDIR / nothing)
39A4C=(2:ID/LAM 1:Any -> 2:Any 1:$)
39A60=(2:Ob2 1:Ob1 -> 2:Ob1 1:"HOME")
39A83=Shows time/date regardless of flags.
39AD8=If not DA1IsStat? then SHOWTIME
39AF1=Clock visible? (-> 1:T/F) (User flag or ShowClock?)
39B0A=Draws status area divider
39B2D=status area divider (Graphic 131 x 2)
39B85=Update stack area if keybuffer is empty
39BF3=Moves stack display up if not NoRollDA2?
39E0F=(composites,arrays,dirs,complex numbers)
39E0F=Can object be > 1 line long on stack display? (1:Any -> 1:T/F) 
39E78=decompiles one line of composite using Stack$?
39EB9=Inserts linenumber to front of a multi line object
39F56=Tests system flag 52
39F93=Calculates number of visible stack lines in edit mode ( --> C.A )
39FB0=Abbreviated stack display? (Displays types only)
39FE3=:: FIVE ;
39FFE=:: TWENTYTWO ;
3A0E4=Calculates pos of first shown edit line ( $ ONE --> $ # )
3A1CA=:: KEYINBUFFER? NOTcase DispMenu SetDA3Bad ;
3A1CA=If no keys pressed DispMenu & freeze current menu
3A1E8=:: DispMenu.1 SetDA3Valid ;
3A1E8=Display & freeze current menu
3A1FC=:: TURNMENUON P12847 <6Eh> <58h> <42h> <2Ch> <16h> <0h> <7h> ONE_DO INDEX@ GETDF DoLabel LOOP ;
3A1FC=Display current menu
3A260=Dispatching Grob>Menu, Str>Menu, Seco>Menu or Id>Menu
3A328=build normal menu key
3A337=normal menu key (blank/inverse) (Graphic 21 x 8)
3A38A=build checked menu key ($ -> grob (box with bullet))
3A399=checked menu key (blank/inverse) (Graphic 21 x 8)
3A3FB=direcotory menu key (blank/inverse) (Graphic 21 x 8)
3A45D=solver menu key (blank) (Graphic 21 x 8)
3A4CE=Disp in 5x7 font at #startrow for #max rows (3:$ 2:#startrow #max)
3A546=BLANKIT rows 0-15
3A55F=BLANKIT rows 16-56
3A578=BLANKIT rows 0-56
3A71C=:: TakeOver'R SIX SetSomeRow
3A735=:: TakeOver'R <FFFFAh> SetSomeRow ;
3A7A3=Starts time menu application
3A7D5=Show edit menu
3A87A=Move cursor in cmd line
3A924=Move cursor in cmd line
3A93D=Does UPSTK if cmd line height is 0/1, else moves cursor up
3A974=Move cursor in cmdline
3A9CE=:: :TakeOver: TurnOff SetDAsNoCh ;
3A9E7=:: MenuRow@ #+ STOMenuRow SetThisRow P418E4 ;
3AA0A=If flag -60 is set then LockAlpha, else only SetKeysA
3AC7B=Repeats !CrsRight or !CrsLeft #n times ( right? #n --> )
3AF50=If PrgMode? then DUP, else Equation Writer
3AF73=Smart visit via down arrow
3B068=If PrgMode? then DUP else Matrix writer
3B095=Enter Program-Entry Mode and start command line
3B211=:: TakeOver' ONE MenuRow! SetThisRow DoMenuRowAct@ ;
3B234=All key entries are like { "NAME" Action } or { "Name" menu }
3B234=All menulists are the menus initiated if there are preparing action
3B234=CstMenu etc are used like this :: ' CstMenu InitMenu ;)
3B234=DoXXXkey is executed when you PRESS the menukey
3B234=Entire menu list
3B234=Type of menu (:: or {}) indicates if there are preparing actions
3B234=XXXkeyops is a list of NS,LS(,RS) routines
3B234=XXXlabelprg return new label if key is pressed ( -> Grob)
3B284=Does SetDirMenu and SetDirKeys first
3B293={ MathPartsKey MathProbKey ... MathBaseKey }
3B542=Does SetDirMenu and SetDirKeys first
3BEB3=SOLVE SOLVR menu list
3C1B8=(-> 2:%xmin 1:%xmax)
3C203=(-> 2:%ymin 1:%max)
3DB1A=Errors if no list is stored (or argument)
3DB1A=Get stored list (1:{}/ID/LAM) ({} as arg stays the same)
3E64D=(--> NotAtStart? Current_SpaceOrNewline?)
3E6A2=(--> NotAtEnd? Next_SpaceOrNewline)
3EC71=dead menu key  (:: NULL$ DoBadKey ; )
3EC85=Sets NOP as action when menu is exited (:: 'NOP ExitAction! ;)
3EC99=If pop stk1 = True, then build checked menu key, else build normal menu key
3ECD0=Build menugrob according to next info (1st "NAME" 2nd #flag)
3ECD0=Example: :: FStd/BoxLbl: "SYM" #3 ;
3ECD0=Makes a menu grob of "NAME", then INSERTS a square if #flag is set
3ECEE=Build menugrob according to next info (1st "NAME" 2nd #flag)
3ECEE=Makes a menu grob of "NAME", then APPENDS a square if #flag is set
3ED25=Used like: :: BBox/StdLabel "HEX" #10 ; -> grob  (according to base)
3ED48=Used like: :: MBox/StdLabel "FIX" #1 ; -> grob (according to fixmode)
3ED6B=Build directory menu key graphic from next $ 
3ED6B=Example: :: DirLabel: "SOLVR" ; -> grob
3ED84=Example: :: DoTogSysFlag: #3 SetDA12NoCh ; is DoSYMkey
3ED84=Toggles next system flag, then SetDA2bNoCh
3EDA2=Toggles system flag (1:#n)
3EDC5=If PrgmEntry DoKeyOb next, else EVAL it & AtUserStack
3EDF2=Does R> then if PrgmEntry? takes CARCOMP and finally DoKeyOb
3EE1A=If Prg-Entry Mode then DoNextKey&Ret else SkipNext&Cont
3EE47=Take next 2 to command line (with spaces and linefeeds)
3EF14=Sets Units key routines
3EF1E=units Unshifted Menu Key routine
3EF41=units Left-shifted Menu Key routine
3EF64=units Right-shifted Menu Key routine
3EFE6=Stores DoDirKey as NS routine and DropBadKey LS and RS ones
3EFF0=Top-level Unshifted Menu Key routine
3F00E=Stores stk1 as NS routine and DropBadKey as LS and RS routines
3F040=Label definition for menus with only sub-menu entries
3F38A=Library Unshifted Menu Key routine
3F50B=(Obn ... Ob1 #n -> ...{Obn-2 Obn-3} {Obn Obn-1} #m
3F547=(Meta1 Meta2 Ob1 Ob2 -> Meta1&{Ob1 Ob2} Meta2)
3F56A=Goes to library menu (1:%libnum)
3F5BF=(1:#libnum -> 1:#romptr_count) (Counts visible romptrs)
3F6B5=Goes to #port menu (Do PORTmenuOn first to stay there)
3F9DA=(3:#key 2:Any (dropped) 1:#plane -> 1:prg)
3F9DA=Gets the programs assigned to a key
3F9DA=Works in normal, application, user etc modes
3FAC5=If user key definition is ID/LAM SKEY gets StdKeyOb instead
3FB33=( #key #plane UserKeys --> ob TRUE / FALSE )
3FB97=Or even list of arrays. #0 in place of array means stdkey   !!
3FB97=UserKeys actually can also be arrays of arrays like StdKeys !!
3FBE7=Gets key definition from [] ( #key #plane [] --> ob )
3FDC7=NULLMenuKey routine
3FDD1=chirp (337 Hz, 70 msec), freeze display
3FDFE=unevaluated chirp (337 Hz, 70 msec), freeze display
3FE44=(1:#keycode -> 1:#) (#80->#1E #40->#23 #C0->#28)
3FE7B=( #key #plane --> flag ) TRUE if shift/alpha changes
3FF1B=?CaseKeyDef <keydef> == #casedrop :: ' <keydef> True ;
3FF75=Tst_7068C:4 (are unassigned keys activated? -> True/False)
3FF86=Set_7068C:4 (activate unassigned keys)
3FF97=Clr_7068C:4 (deactivate unassigned keys)
3FFA8=(True = USR1MODE, False = USERMODE)
3FFA8=Tst_70688:1
3FFB9=Set_70688:1
3FFCA=Clr_70688:1
4019D=General Unshifted Menu Key routine
401D4=General Left-shifted Menu Key routine
4021F=General Right-shifted Menu Key routine
40454=Main key handler (acts like menu key, takes stk1) (1:Any)
404A9=behave as TOS is assigned to a key/menulbl (1:String)
404BD=behave as TOS is assigned to a key/menulbl (1:Unit)
404E5=behave as TOS is assigned to a key/menulbl (1:Program/Command)
4051C=behave as TOS is assigned to a key/menulbl (1:XLIB Name)
405BC=behave as TOS is assigned to a key/menulbl (1:Algebraic)
405F3=DoKeyOb for ob types of no special meaning
40625=Insert stk1 in cmdline between 2 blanks (1:Any)
40693=Appends "(" and ")" to string
4073D=Doesn't insert space if not INS mode, at line start, cur/next is spc
40788=A null program
40788=Serves as an identifier for a valid program to execute
40788=by a keypress in edit mode
40792=(1:seco -> 2:seco 1:TRUE/FALSE)
40792=Accepted: TO , :: TO <rest> ; , :: :: TO <rest1> ; <rest2> ;
40792=Checks if TakeOver is first in a secondary
40828=Get object bound to menu key (key number follows)
4085A=:: TakeOver ;
408AA=Not PRGMODE? nor AlgEntryOn?
408C3=If Level1 = LAM or ID then DECOMP$ else EDITDECOMP$
40A0B=If level1 = LAM/ID then ID>$ else NULL$
40A6F=Store name of current prg (1:Cmd/Funct/ID/XLIB)
40A82=Rcl name of current prg -> (1:Cmd/Funct/ID/XLIB)
40A95=Clear name of current program
40AA8=Is KeyOb@ <> 00000 (--> flag )
40ABB=Parses EDITLINE$
40BB5=ENTER key executes this when on command line
40BC9=:: CK0NOLASTWD 0LASTOWDOB! ;
40D4D=Toggle user keyboard flag -62
40D61=Activate the user keyboard for one keypress
40D93=If no command line exists COLA (Actually DoKeyOb) else SKIP
40DC0=:: InitMenu SetDA12NoCh ;
40DD4=Insert next item (character) in cmdline
40DF7=Insert next item (string w/o LF) in cmdline, move cursor left one pos
40EE7=delay loop (0055E)
40F02=delay loop (06B67)
40F12=delay loop (43206)
40F86=Initializes menu (first page) (1:{menu}) (Used by TMENU with {})
40F9A=display menu (2:menu,1:offset)
41175=(Meta --> ) Sets menu keys according to keydefs in Meta
411D4=( MenuKey --> Proc Def) gets data for STODF and STOPROC
4132D={"0" "1" "2" "&"}
4139B=save current menu/offset as last menu/offset
413B9=display Last Menu
413D2=This does the normal REVIEW
415C9=Internal RCLMENU (-> %menu.page)
4161A=Get current menu number -> (1:%)
41679=Internal TMENU (1:%)
416F1=recall menu (1:#)
41741=(Used by CST,SOLVER)
41741=Saves CONTEXT, sets var menu on
41804=PORT menu updated?
41848=save Current Menu Offset (1:#) (to 707C9)
4185B=get Current Menu Offset as # (from 707C9)
4186E=save Last Menu Offset (1:#) (to 707D3)
41881=get Last Menu Offset as # (from 707D3)
41894=save Current Menu (to 7061E)
418A4=get Current Menu (from 7061E)
418B4=save stk1 (pointer) into 70628 (storage for cst menu???)
418C4=execute saved stk1 (@70628 = pointer)
418D4=save stk1 (pointer) into 7062D
418E4=execute @7062D (pointer)
418F4=save stk1 (pointer) into 70632
41904=execute @70632 (pointer)
41914=save Unshifted Menu Key routine
41924=get Unshifted Menu Key routine
41934=execute Unshifted Menu Key routine
41944=save Left-shifted Menu Key routine
41954=execute Left-shifted Menu Key routine
41964=save Right-shifted Menu Key routine
41974=execute Right-shifted Menu Key routine
41984=save stk1 (pointer) into 70646
41994=execute @70646 (pointer)
419A4=save stk1 (pointer) into 70650
419B4=execute @70650 (pointer)
419C4=save stk1 (pointer) into 70655
419D4=execute @70655 (pointer)
419E4=save Last Menu
419F4=get Last Menu
41A04=Save current CONTEXT pointer to SavedContext
41A14=Get saved CONTEXT pointer from SavedContext
41A39=unevaluated 'UserKeys' (ID)
41A5F=unevaluated 'UserKeys.CRC' (ID)
41A8D=if User Mode active (-62) -> True/False
41AA1=Intenral STOKEYS (1:{})
41B28=Internal ASN (2:Any 1:%keycode)
41B3C=Internal DELKEYS (1:{})
41B69=Internal DELKEYS (1:%keycode)
41B8C=delete user key definition (2:key# 1:plane#)
41BA5=Internal STOKEYS (1:ID/LAM)
41BB9=Internal DELKEYS (1:ID/LAM)
41BCD=SIZEERR if stk1 not ID S nor LAM S
41C02=Recalls Assigned keys ({} if none)
41CA2=validate key (rc.p) and convert to key# & plane#
41E32=store into UserKeys with checksum in UserKeys.CRC
41E78=save user key definition (3:value,2:key#,1:plane#)
41E8C=(1:Ob -> 1:{Ob Ob Ob....Ob} (size = 49)
41ECD=(1:Ob -> 1:{Ob Ob Ob Ob Ob Ob}
41F13=delete all user key definitions
41F2C=save ptr to User Keys
41F3F=get User Keys
41F65=Waits for key press (->2:#keycode 1:#keyplane)
42023=:: TakeOver TRUE 1PUTLAM ;
42023=The usual way of exiting a POL is using 1LAM as exit condition
42078=If EditLExists? and DA2bEdit? then SetBlinkOn else ClrBlinkOn
420A0=keywait (-> 2:# 1:T | 2:F 1:F (If alarm/AutoOff)
42131=:: TurnOff FalseFalse ;
42145=:: FLUSHRSBUF FalseFalse ;
42159=keywait (-> 2:# 1:T | 1:F (If attn/Alrm/AutoOff)
42208=(--> flag ) Returns TRUE if keybuffer read is overridden
42208=by ATTN?, UART?, TIMEOUT? or ALARM?
42262=if @70679.A <> 0 -> True/False
4231A=Set busy annunciator on
4245C=if @70679.A = 0, then semi
4256B=Move cursor in one cmd line
425D4=Moves right if not at the end of line
426F1=Is the cursor in the last line of the cmdline?
4272D=Is the cursor in the first line of the cmdline?)
427AF=Checks modifications in 1stEditLine and FirstChar
427AF=after evaluating next. DispEditLine if either changed.
42804=:: case #-#- DROP !CursorXLoc ;
4285E=If @1stEditL + 3 = @CursorLine then Inc1stEditL
42886=If @1stEditL = @CursorLine then Dec1stEditL
428F9=   @FirstChar #+ #+ !CursorLoc ;
428F9=:: ITE SWAPDROP :: DROPDUP !CursorXLoc ;
42AC4=Calculates cursor location to C.A, (A.A=2*(CursorLoc+1), B.A=endaddr)
42AE4=behave as TOS is assigned to a key/menulbl (1:Character)
42BD4=behave as TOS is assgn. to a key/menulbl (DA1 Not Freezed) (1:$)
42BFC=If $ has Char #0 then Doerr #102 (1:$)
42C3D=(1:$ -> 2:$ 1:T/F) Returns False if $ contains CHR(0)
42C5B=(1:$ -> 4:$ 3:#1 2:#lfpos 1:T/F) (#lfpos = 0 if no linefeed is found)
42C92=behave as TOS is assgn. to a key/mnlbl (1:String w/ LF)
42CE2=behave as TOS is assgn. to a key/mnlbl (1:String w/o LF)
42CFB=Inserts chr/$ to editline in insert mode
42D82=Edit level1 (1:Any -> 2:Any 1:True if <ENTER> | 1:False if <ATTN> )
42DC8=Starts >EqWriter, >MatrixWriter or CharEdit on stk1
42DFF=%VISIT  (1:Real)
42E13=%SVISIT  (1:Real)
42E5E=(1:ID/LAM)
42E72=(1:ID/LAM)
42E86=SAFE@_HERE, 'REVAL (this must exit with 1:T/F) and if True STO back
43395=Internal INPUT (2:$ 1:$)
433CC=Internal INPUT (2:$ 1:{})
4365D=Enter the interactive stack
43D10=  UPS->LISTkey UPSDUPNkey UPSDRPNkey UPSKEEPkey UPSLEVELkey }
43D10={ ECHOkey UPSVIEWkey UPSPICKkey UPSROLLkey UPSROLLDkey
44197=(... #n -> ... 2:Ob 1:True / ... 1:False) False if #n is out of range
4426D=Maximum inverted lenght, 21
442A4=Clears (& reserves) #30 nibbless between DSKBOT and TEMPENV for $
4434F=FirstChar=CursorLoc=CursorXLoc=0, CursorLine=1stEditLine=1
443A8=ClrAlgEntry, ClrPrgmEntry, ClrLowCase, unLockAlpha, SetINSMode
44407=N is a nibble counter, thus #2 means next, ##ffffe means previous
44487=Gets next char AND returns true if it is CHR(0)
444A5=Returns TRUE if next char is CHR(0) or newline
444C3=Insert stk1 in cmdline (1:$ w/o LF)
44683=Makes new copy of $ to tempob area. Not bad unless the
44683=Recalls string being edited (Check EditExists? first)
44683=wrong routines are using it... :(
446E7=(-->A.A=endaddr, C.A=chars)
44711=Recalls size of $ being edited?
44730=CMDLINELines  (command-line lines counter -> (1:Syst Bin \>= 0))
44747=(--> A.A=EditParts, C.A=firstloc) Carry set if EditLExists? is not set
44772=(--> C.A=D0=firstloc, A.A=firstchar)
4478A=Returns TRUE if firstchar is 00.
447A9=(A.A=line --> C.A=firstchar) ST2 set if all line scrolled over
4482D=(--> #firstchar #CursorXLoc flag) TRUE if CursorXLoc>firstchar
4489E=(--> EDITDPARTS+CursorLine-1stEditLine+1)
44C31=Enter Matrix Writer with no matrix in it
44F42=(21 args)
44F6A=:: 2PUTLAM 3PUTLAM ... 22PUTLAM ZERO 1PUTLAM ;
44FE7=(1:[] -> 2:[] 1:T if <ENTER> | 1:F if <ATTN> )
44FE7=Starts matrix writer with a matrix
450BE='centered-dot' 0xB7 (Character)
45174='-' 0x2D (Character)
45716={ <1h> <1h> }
45C2F=:: SWAP#1- 21GETLAM #* #+ ;
4600D=  -ROWkey +COLkey -COLkey MATWR->STKkey MATWRUPSTKkey }
4600D={ MATWREDITkey MATWRVECkey <-WIDkey WID->key GO->key GOdownkey +ROWkey
4731A=(-> #) (#0 = -> ??, #1 = down??)
4737D=ID_EQ is special ??? dunno what
4737D=Recalls ID contents (1:ID -> 2:contents 1:True | 1:False)
473A0=ID_EQ is special ??? dunno what
473A0=Recalls ID contents (1:ID -> 3:ID 2:contents 1:TRUE | 2:ID 1:FALSE)
47409=Something about EQ checking for ID_X ????????????
47975=If MSGOK? then APPprompt1! & valids status area, else DROP
47984=Displays $ in a 'separated' status area (1:$ ->)
479A7=If MSGK? then APPprompt2!, else 2DROP 
479B6=Displays 2 strings in status area & valids it
479D4=(->1:T/F) True if PrgmEntry?/AppMode?/ImmedEntry?/Key pressed etc..
47A1A=Internal XRNG (2:% 1:%)
47A42=Internal YRNG (2:% 1:%)
47A6A=Internal INDEP (1:%)
47A8D=Internal DEPND (1:%)
47BF0=( Menu_Program Var_List --> )
48FF9=Do VERYSLOW 5 times
49017=Is current menu PLOTmenu?
49035=TRUE if PTYPE = BAR | HISTOGRAM | SCATTER else FALSE
490CB=:: %0 1REV ;
49199={ NULLLAM.... NULLLAM } (8 NULLLAMs)
491D5=Internal AUTO
4949B=Push %1 and %-1
49569=(2:[%] 1:#column -> 2:%min 1:%max)
4959B=(1:% -> 2:% 1:%0  | 1:C% -> 2:%re 1:%im)
495F5=(2:%eithery 1:%othery)
495F5=Orders STK1 & STK2, Puts to YRNG and lowers YMIN with 1 pixel amount
496F5=:: LnwDecomp$ !append$ ; (2:$ 1:Ob -> 1:$)
4978F=Invoke GRAPH FCN menu
49AD3=:: DROP 595B0 ;
49CD6=1:{ ob1 ob2 ob3 .. obn } -> 1:{ ob2 ob3 .. obn ob1 }
49CD6=ROLL lists contents (If empty SETNoEQERR)
49E43=->NUM level1 (stk2,3,4 are bound to LAMs meanwhile, why????)
4A055=Displays coords until key is pressed
4A078=:: RECORDX&YC% C>Re%
4A08C=Gets first equation from ID_EQ, (EQ itself if ID_EQ is not a list)
4A0AA=Gets Nth (#) equation from ID_EQ
4A16C=Internal SigmaLINE
4A194=(2:Ob2 1:Ob1 -> 1:'Ob2+Ob1*X'
4A1D4=(2:Ob2 1:Ob1 -> 1:'Ob2+Ob1*LN(X)'
4A223=(2:Ob2 1:Ob1 -> 1:'Ob2*EXP(Ob1*X)'
4A28F=Returns 'EQ' or EQ:contents (tagged) (Checks fast flag etc too)
4A770=Ask for ID (2:$messageline 1:$editline -> 2:ID 1:True)
4A770=SETTYPEERR if wrong type gotten, if ON pressed return (-> 1:False)
4A7CA=Finds and calcs the bestmodel (to sigmaPAR) (no args)
4A7CF={ LINFIT LOGFIT EXPFIT PWRFIT }
4A982=:: %0 1REV ;
4A9D7=(1:{} -> 1:list element 1)
4A9D7=Checks that LEN{} = 3, {2} and {3} are strings
4AA59=Checks that last entry in exploded PPAR is ID (errors if not)
4AA68=The same as in address 4A9D7
4AAA9=Checks PPARs validity too
4AAA9=Recalls exploded PPAR to stack (Makes one if necessary)
4AAEA=Creates default PPAR & pushes it ( -> StdPPAR{} )
4AB7B=Returns standard ranges (Like <131d> -> -6.5 6.5 )
4ABC1=If stk1 is not a PTYPE, set FUCTION as PTYPE
4AC1B=Sets FUNCTION as PTYPE
4AC61=Internal CENTR (1:C%)
4AE3C=Internal SCALE (2:% 1:%)
4AF77=Internal INDEP (1:ID)
4AF8B=Internal INDEP (1:{})
4AFB3=Internal DEPND (1:ID)
4AFC7=Internal DEPND (1:{})
4AFEF=Internal RES (1:%)
4B012=Internal RES (1:positive % / HXS)
4B03A=Internal AXES (1:C%)
4B04E=Internal AXES (1:{})
4B062=Get PLOT type (-> 1:Type)
4B076=Stores PLOT type (1:Type)
4B09E=Internal PMIN (1:C%)
4B0C6=Internal PMAX (1:C%)
4B1F2=(-> 2:HXS_xsize 1:HXS_ysize)
4B206=Internal PDIM (2:C% 1:C%)
4B2D3=(2:(re2,im2) 1:(re1,im1) -> 2:%%(im1-im2) 1:%%(re1-re)
4B300=Internal PDIM (2:HXS,1:HXS)
4B323=Internal PDIM (2:#,1:#)
4B364=Checks PPAR validity, then gets Nth item (1:#n -> 1:Ob)
4B3BE=(3:Ob3 2:Ob2 1:Ob1->..3:TYPESTR?(Ob1) 2:TYPESTR?(Ob2) 1:TYPECMP?(Ob3)
4B3E1=(3:Ob3 2:Ob2 1:Ob1->..3:TYPEID?(Ob1) 2:TYPEREAL?(Ob2) 1:TYPEREAL?(Ob3)
4B44F=(1:{ Ob1 Ob2 Ob3 Ob4 } -> 1:{ Ob1 Ob3 Ob4 } )
4B490=(2:Ob2 1:Ob1 -> 4:Ob2 3:Ob1 2:TYPEREAL?(Ob1) 1:TYPESTR?(Ob2) )
4B490=(2:Ob2 1:Ob1 -> 4:Ob2 3:Ob1 2:TYPESTR?(Ob1) 1:TYPESTR?(Ob2) )
4B51C=(2:%2 1:%1 -> 2:MIN(%2,%1) 1:MAX(%2,%1)
4B553=Internal *H (1:%)
4B5AD=Internal *W (1:%) (Funny how HP names their internals)
4B60C=Internal ERASE
4B6AC=Internal DRAW
4B941=:: @ DROP ;
4BE23=If Attn is pressed, ExitAtLOOP (ZEROISTOPSTO)
4C02B=Calculates 10 499 %CHS %^
4C0FD=Fetches YMIN and YMAX from PPAR (2:%ymin 1:%ymax)
4C3E1=(1:C% -> 2:%re 1:%im=0? (True/False) )
4C5E4=:: 8PUTLAM 7PUTLAM ;
4C607=Internal DRAX
4C8F4=Internal BINS (3:% 2:% 1:%)
4C93F={ LAM_'xmax LAM_'N }
4CA0F=(3:Ob3 2:Ob2 1:Ob1 -> 4:#1 3:#1 2:Ob2 1:Ob1)
4CD2A=(4:#n 3:Any3 2:Any2 1:#m -> 4:#n+1 3:Any3 2:Any2 1:#m-1)
4CDD9=(5:#m 4:Ob4 3:Ob3 2:#n 1:Ob1 -> 5:#m 4:#n-#m 3:Ob3 2:Ob2 1:Ob1)
4CE10=(6:#m 5:Ob5 4:Ob4 3:Ob3 2:Ob2 1:#n -> 4:#m 3:Ob5 2:Ob4 1:#n-#m)
4D1AA=Internal GRAPH
4E2CF=Turn menu display off, enlarges text grob to fill it
4E347=Turn menu display on
4E875=Internal LABEL
4EE1A=Invoke GRAPH ZOOM menu
4EE3D=GRAPH ZOOM menu list
4F011=Internal PVIEW (1:C%)
4F02F=Internal PVIEW (1:List)
4F0AC=Internal PX->C (1:{})
4F179=Internal C->PX (1:C%)
4F2CD=(6:#x2 5:#y2 4:(xmin,ymin) 3:(xmax,ymax) 2:#x 1:#y ->
4F2CD=6:x2 5:y2 4:(x-1)/dx 3:-xmin*(x-1)/dx 2:(y-1)/dy 1:ymax*(y-1)/dy
4F37C=Internal STO (2:Grob 1:PICT)
4F3D1=Convert level 1 and 2 HXSs to #
4F3EF=Internal PIXON (1:C%)
4F458=Internal PIXON (1:List)
4F471=Internal PIXOFF (1:C%)
4F48A=Internal PIXOFF (1:List)
4F4A3=Internal PIX? (1:C%)
4F4BC=Internal PIX? (1:List)
4F525=Internal LINE (2:List,1:List)
4F539=Internal TLINE (2:List,1:List)
4F584=Internal LINE (2:C%,1:C%)
4F598=Internal TLINE (2:C%,1:C%)
4F665=Internal BOX (2:List,1:List)
4F688=Internal BOX (2:C%,1:C%)
4F6A1=Internal BLANK (2:HXS,1:HXS)
4F6BA=Internal GOR/GXOR (4:Graphic,3:List,2:Graphic,1:True/False)
4F6F6=Internal GOR/GXOR (4:Graphic,3:C%,2:Graphic,1:True/False)
4F741=Internal GOR/GXOR (4:PICT,3:C%/List,2:Graphic,1:True/False)
4F78C=( flag grob1 grob2 #x #y > grob' ) (GOR or GXOR)
4F8D1=Internal + (2:Grob 1:Grob -> 1:Grob)
4F999=Internal REPL (3:Grob 2:{} 1:Grob -> 1:Grob)
4F9F3=Internal REPL (3:Grob 2:C% 1:Grob -> 1:Grob)
4FA2F=Internal REPL (3:PICT 2:{}/C% 1:Grob ->)
4FA7A=Internal REPL (3:{} 2:% 1:{} -> 1:{})
4FAF7=Internal REPL (3:$ 2:% 1:$ -> 1:$)
4FB74=Internal SUB (3:Grob 2:{} 1:{} -> 1:Grob)
4FBC4=Internal SUB (3:Grob 2:C% 1:C% -> 1:Grob)
4FBF6=Internal SUB (3:PICT 2:C% 1:C% / 2:{} 1:{} ->)
4FC28=Internal NEG (1:Grob -> 1:Grob)
4FC3C=Internal NEG (1:PICT ->)
4FC5F=Internal ARC (4:C% 3:% 2:% 1:%)
4FD2C=Internal ARC (4:{} 3:HXS 2:% 1:%)
4FE12=Rounds complex number (0 RND) and does C%>% (1:C% -> 2:%re 1:%im)
50154=Drop levels 6,5,1 (6:Ob6 5:Ob5...1:Ob1 -> 3:Ob4 2:Ob3 1:Ob2 )
5032A=(2:%2 1:%1 -> 3:%2 2:%1 1:(%1-5GETLAM)^2+(%2-6GETLAM)^2
503B1=Substract smaller from bigger (2:% 1:% -> 1:ABS(stk2-stk1) )
503C5=Internal TEXT
503D4=Internal LCD->
50438=Internal ->LCD (1:Graphic)
5046A=Internal CLLCD
5048D=Internal ->GROB (2:Any 1:%)
5053C=graphics cursor (Graphic 5 x 5)
5055A=graphics mark (Graphic 5 x 5)
50578=get GROB dimensions -> (2:Rows,1:Columns)
505B2=Graphic template (Graphic 0 x 0)
506C2=If POP stk2 is #0, negate stk1 (2:# 1:# -> 1:#)
50701=Get window height (???) ( -> 1:#)
50923=(4:Ob4 3:Ob3 2:Ob2 1:Ob1 -> 5:Ob1 4:Ob2 3:Ob3 2:Ob4 1:TRUE)
50A3B=(3:Ob3 2:Ob2 1:Ob1 -> 2:Ob1 1:%0)
50A63=(4:Ob4 3:Ob3 2:Ob2 1:Ob1 -> 4:Ob1 3:Ob2 2:Ob3 1:Ob4 )
50D02=Get INDEX@+1th item from EQ list (errors if not there) ( -> 1:Ob)
50D78=:: 15GETLAM 16GETLAM %< NOTcase TRUE ATTNFLG@ #0<> ;
50DA5=:: ATTNFLG@ #0= 15GETLAM 16GETLAM %= AND ;
50DCD=Push True If PTYPE = SCATTER | HISTOGRAM | BAR, else False
50E94=Saves D1 to R0, pops to D1, gets to A
5102B=:: 16GETLAM ;
5103A=Put item to Nth place from end of PPAR (2:Ob 1:#n)
51067=Makes PPAR from stack contents
51085=If False do SETPPARERR
51099=Gets DEPND var, takes 1st element if list
510AD=Gets DEPND var, takes 1st element if list
510C1=If stk1 is list, CARCOMP, else nothing
51125=Stores blank grob over HARDBUFF2 (menugrob) (no args)
51148=validate pop stk1 is PICT (Bad Argument Type)
51166=If PICT dims = 0 store BLANK (131 x 64) in PICT
51166=If dims over (131 or 64) (broaden heighten) PICT
51184=3DROP and STORE BLANK (131 x 64) in graph grob (3:Any 2:Any 1:Any)
511B6=Broadens GDISP or ABUFF (3:ABUFF or GDISP 2:nomeaning 1:#x)
511B6=Make sure #x is > <131d> before calling
511E3=(2:PICT or TEXTGROB 1:#y) Adds rows to GROB if #y > #40
5120B=Gives GBUFF dims, makes them atleast Standard sized (131 x 64)
5121F=(2:#ysize 1:#xsize -> 2:MAX(#ysize,YHI) 1:MAX(#xsize,XHI) )
513DC=(1:ALG -> 1: ALG:: | 2:ALG 1:#0 if not found)
513DC=Replaces s1 with 1 in algebraic and makes a program of it
51404=(1:ALG -> 1: ALG:: | 2:ALG 1:#0 if not found)
51404=Replaces s1 with -1 in algebraic and makes a program of it
5142C=(1:ALG -> 3:ALG 2:#0 1:False) if not found
5142C=(1:ALG ->..stackform..3:#origlength of alg 2:#s1locationOnstack 1:True
5142C=:: FINDs1 ITE :: %1 SWAP UNROLL SYMBN ; 2DROP ;
5142C=Example: To replace s1 with 1: (stk1 is algebraic)
5142C=Finds s1 from algebraic(explodes it) and gives its location if found
51482=(1:SYMB -> 1:SECO) Does GetBHS, then ::N
51496=(1:SYMB -> Meta) Gets 1st argument in symbolic as Meta 
514AF=RHS = Right Hand Side ??? :)
514C3=(1:SYMB -> Meta) Gets last argument in symbolic as Meta
514DC=One revolution in current degrees (2PI, 360 or 400) (-> 1:%)
51519=INNERCOMP, if not #2= then SIZEERR
51532=Verify a list of 2 hxs elements, then 2HXS># (1:{} -> 2:# 1:#)
51564=Errors if NOT GROBDIMS>?
51578=Gives true if both grob dims are bigger than nums on stack
51578=(3:#columns 2:#rows 1:GROB -> 3:#rows 2:#columns 1:Flag)
515A0=Gives y-coord of top row in window ( -> 1:#)
515B4=Gives y-coord of bottom row in window (-> 1:#)
515CD=Changes prolog of stk1 object to DOGROB (1:Ob -> 1:GROB)
515FA=Gives x-coord of left border in window (-> 1:#)
5162C=Is TOPROW equal to 7LAM?
5165E=IS LEFTCOL equal to 8LAM?
51690=Sets ZERO as TOPROW
51735=(Naturally the internal editor uses REPEATER :)
51735=REPEATER slows down the repeat, this one doesn't
5176C=Byproduct of a bad compiler
5179E=push GROB dimensions (1:GROB -> 3:GROB 2:#rows 1:columns)
517B2=3 PICK and get GROB dimensions
517C6=(Ob Ob') :: OVEREQcaseDROP <False> ; -> == () / Ob <False>
517DA=(Ob) :: COLADROP <Never> ; -> ()
517F3=(Ob1 Ob2 Ob3) :: EQUALcasedro <True> <False> ; == <True> / Ob1 <False>
51807=:: DROP COLA COLA ; ( NS:DROPCOLA elsewhere )
5182F=Calculate ISTOP@ - INDEX@ (-> 1:#)
51843=(2:#n 1:Any -> 2:#n+1 1:Any)
51857=(2:#n 1:Any -> 2:#n-1 1:Any)
5186B=Internal DROP and chirp (337 Hz, 70 msec), freeze display
5187F=Get PICT dimensions -> (2:#Rows 1:#Columns)
51893=(4:#x2 3:#y2 2:#x1 1:#y1 -> 4:#Min(x1,x2) 3:#Min(y) 2:#Max(x)...
518CA=(4:%x2 3:%y2 2:%x1 1:%y1 -> 4:%Min(x1,x2) 3:%Min(y) 2:%Max(x)...
51901=Error (Obj in use) if in Plot environment
5198F=Internal RE for reals (1:Ob -> 1:%0)
519A3=Internal RE (1:C% -> 1:%re)
519B7=Internal IM (1:C% -> 1:%im)
519CB=Internal C->LR (1:C% -> 2:%%re 1:%%im)
519DF=Internal C->LR (1:C% -> 2:%%im 1:%%re)
519F8=Internal LC->C (1:C%% -> 1:C%)
51A07=Internal LR->C (2:%%re 1:%%im -> 1:C%)
51A37=Internal R->C (1:%re -> 1:C%)
51A4A=multiply by i (1:C% -> 1:C%)
51A5F=divide by i (1:C% -> 1:C%)
51A71=Calc stk1^2 + stk2^2 (2:% 1:% -> 1:%%)
51A94=Calc stk1^2 + stk2^2 (2:%% 1:%% -> 1:%%)
51AB7=(1:% -> 1:%0, %MAXR or -%MAXR) (According to sign)
51ADF=(4:%%re 3:%%im 2:%%re 1:%%im -> 2:%%re 1:%%im)
51BD0=Internal + (2:C% 1:% -> 1:C%)
51BE4=(3:Any 2:% 1:% -> 2:% 1:Any)
51BF8=Internal + (2:% 1:C% -> 1:C%)
51C16=Internal + (2:C% 1:C% -> 1:C%)
51C3E=Internal + (2:C%%1:C%%)
51C6B=(2:C%2 1:C%1 -> 4:%re1 3:%im1 2:%re2 1:%re1)
51C84=(2:C%%2 1:C%%1 -> 4:%%re1 3:%%im1 2:%%re2 1:%%re1)
51DFB=(3:%%re1 2:%%re2 1:%%im2 -> 2:%%re 1:%%im)
51E19=Internal / (2:% 1:C% -> 1:C%)
51E64=Internal / (2:C% 1:% -> 1:C%)
51E9B=(3:Any 2:%%2 1:%%1 -> 4:%%2*%%2+%%1*%%1 3:%%2 2:-%%1 1:Any)
51EA5=(3:Any 2:%%2 1:%%1 -> 4:%%2*%%2+%%1*%%1 3:Any 2:%%2 1:%%1)
51EC8=Internal / (2:C% 1:C% -> 1:C%)
51EFA=Internal INV (1:C% -> 1:C%)
5203A=If infinite result allowed flag set, set indicator, else error
52062=Internal ABS (1:C% -> 1:%)
52099=Internal ARG (1:C% -> 1:%)
520B2=(2:%% 1:%% -> 3:%% 2:%% 1:%%SQRT(%%2*%%2+%%1*%%1)
520CB=Internal SIGN (1:C% -> 1:C%)
52107=Internal sqrt (1:C% -> 1:C%)
52193=Internal EXP (1:C% -> 1:C%)
521A7=(2:%%re 1:%%im -> 1:C%)
521E3=Internal LN (1:C% -> 1:C%)
522BF=Internal LOG (1:C% -> 1:C%)
52305=Internal ALOG (1:C% -> 1:C%)
52342=Internal ^ (2:% 1:C% -> 1:C%)
52360=Internal ^ (2:C% 1:% -> 1:C%)
52374=Internal ^ (2:C% 1:C% -> 1:C%)
52530=Internal SIN (1:C% -> 1:C%)
52571=Internal COS (1:C% -> 1:C%)
525B7=Internal TAN (1:C% -> 1:C%)
5262F=Internal SINH (1:C% -> 1:C%)
52648=Internal COSH (1:C% -> 1:C%)
5265C=Internal TANH (1:C% -> 1:C%)
52675=Internal ATAN (1:C% -> 1:C%)
527EB=Internal ATANH (1:C% -> 1:C%)
52804=Internal ASIN (1:C% -> 1:C%)
5281D=Internal ASINH (1:C% -> 1:C%)
52836=Internal ACOSH (1:C% -> 1:C%)
52863=Internal ACOS (1:C% -> 1:C%)
52C36=(4:SECO 3:%accuracy 2:%low 1:%hi -> 2:%integral 1:%error)
52C36=Calculates numeric integral, use this for speed
52C36=Ensures 1E-12 <= %accuracy <= 1
52C36=Is %low=%hi, return %0 %0
52C8C=Creates HXS 105, stores %hi %lo and %acc into it
52D49=Calculates midpoint of integration range (--> %mid )
535CC=SPLTAC + RADDF
535DA=SPLTAC + MULTF
535E8=XYEX + DIVF
536FB=(1:#n -> 2:#2^n)
53725=Set user flag (1:#)
53731=Set system flag (1:#)
53755=Clear user flag (1:#)
53761=Clear system flag (1:#)
53778=User flag set? (1:# -> 1:T/F)
53784=System flag set? (1:# -> 1:T/F)
537A6=NS:GetFlag
5380E=If pop stk1 = True then push 1 else push 0
53842=If LASTARG flag is clear ClrLastArgs
5389E=Clears LASTCMD1..LASTCMD5
539E6=Argument example: LC(5) 887 -> Test 70600+87:8
53A4A=Tru editing or command line (HP:ImmedEntry? at 408AA)
53A9E=TIME menu etc set this one
53AF2=Sets carry if ISysFlag is set, If C.A = 00487, tests C0687:4
53B61=( -> 1:#n) 0=Std, 1=Fix, 2=Sci, 3=Eng 
53B88=clear Numeric Results (-3)
53B9C=set Numeric Results (-3)
53BB0=if not Numeric Results (-3) -> True/False
53BDD=if Radians (-17) -> True/False
53BF1=return Angle Mode Flags -> (2:Rad 1:Degrees/Grads)
53C0A=if not Symbolic Constants (-2) -> True/False
53C23=if Principal Solution (-1) -> True/False
53C37=Internal HEX
53C43=Internal BIN
53C4F=Internal OCT
53C5B=Internal DEC
53C96=Internal STWS (1:% ->)
53CAA=Internal STWS (1:# ->)
53CF0=Internal RCWS (-> 1:%)
53D04=Internal AND (2:HXS 1:HXS -> 1:HXS)
53D15=Internal OR (2:HXS 1:HXS -> 1:HXS)
53D26=Internal XOR (2:HXS 1:HXS -> 1:HXS)
53D4E=Internal NOT (1:HXS -> 1:HXS)
53D5E=Internal SL (1:HXS -> 1:HXS)
53D6E=Internal SLB (1:HXS -> 1:HXS)
53D81=Internal SR (1:HXS -> 1:HXS)
53D91=Internal SRB (1:HXS -> 1:HXS)
53DA4=Internal RR (1:HXS -> 1:HXS)
53DE1=Internal RRB (1:HXS -> 1:HXS)
53E0C=Internal RL (1:HXS -> 1:HXS)
53E3B=Internal RLB (1:HXS -> 1:HXS)
53E65=Internal ASR (1:HXS -> 1:HXS)
53E95=Pushes A.WP as hxs, exits to rpl
53EA0=Internal + (2:HXS 1:HXS -> 1:HXS)
53EB0=Internal - (2:HXS 1:HXS -> 1:HXS)
53EC3=Internal NEG (1:HXS -> 1:HXS)
53ED3=Internal * (2:HXS 1:HXS -> 1:HXS)
53EE4=Multiplies A.WP and B.WP (--> A.WP)
53F05=Internal / (2:HXS 1:HXS -> 1:HXS)
53F77=Pops hxs to C and A, SAVPTR
53F8D=Pops hxs to A, SAVPTR
54021=Gets current wordsize to A, Uses D0,A,C, Clears Carry
54039=Internal RCWS (-> 1:#)
54050=(-> 1:  Hex:#10h Dec:#10d Oct:#10o Bin:#10b) 
54061=Does hxs>$, then appends base character (1:HXS -> 1:$)
5407A=Returns b, o, d or h according to current base (-> 1:Char)
540BB=Converts HXS to string without base character (1:HXS -> 1:$)
5422C=P is lenght-1, A has data (P=15 pushes A.W)
5429F=Internal / (2:% 1:HXS -> 1:HXS)
542BD=Internal / (2:HXS 1:% -> 1:HXS)
542D1=Internal * (2:% 1:HXS -> 1:HXS)
542EA=Internal * (2:HXS 1:% -> 1:HXS)
542FE=Internal - (2:% 1:HXS -> 1:HXS)
5431C=Internal - (2:HXS 1:% -> 1:HXS)
54330=Internal + (2:% 1:HXS -> 1:HXS)
54349=Internal + (2:HXS 1:% -> 1:HXS)
5435D=Internal B->R (1:HXS -> 1:%)
543F9=Internal R->B (1:% -> 1:HXS)
54419=MC: push A.W (%) as HXS
544D9=Internal == (2:HXS 1:HXS -> 1:%)
544EC=Internal <> (2:HXS 1:HXS -> 1:%)
54500=Internal > (2:HXS 1:HXS -> 1:%)
5452C=Internal >= (2:HXS 1:HXS -> 1:%)
5453F=Internal <= (2:HXS 1:HXS -> 1:%)
54552=Internal < (2:HXS 1:HXS -> 1:%)
54565=Internal IFTE (sym symf symf --> symf )
5456A=Used to bind true and false clauses for IFTE
5456F=Storege for IFTE true clause
54580=Storage for IFTE false clause
5459B=Same as SYMIFTE, but stk1&2 already bound to 'tcls and 'fcls (No ABND)
54609=Builds IFTE expression (Meta_condition --> Meta' )
54609=Clauses are recalled from LAMtcls and LAMfcls
54653=Re-evaluates xIFTE after succesful ->NUM in numeric mode
547B5=Example: ('X+C' 'C' B 'X' Y #5 --> 'Y+B' )
547B5=Internal | (symb QN1 id1 ... QNN idn #2n+1 --> symf )
547E2=Used when ALG to check is #1 sized
54805=(meta Ob -> Ob or ALG_Ob) (ID,LAM,%,C%,Unit not symcomp'ed)
5483C=Return & (Meta&Ob -> Ob)
548AA=(Meta&Ob1 Ob2 -> Ob1&Ob2 Meta)
54922=(Meta4 Meta3 Meta2&Meta1 --> Meta4 ALG1&Meta4&Meta3 Meta2 )
54954=Internal delta (complete derivative) (2:sym 1:sym)
54977=Stepwise derivative (2:ALG_dervar 1:sym)
5499F=(Meta -> %0)
549CC={ ''dvar' }
549EC=If meta has no IDs/LAMs/ALGs/romps then COLA else SKIP
54B32=(Meta SYMB_ID <op> ->)
54BAF=Does COMPEVAL until stk1 isn't algebraic/doesn't contain derivatives
54C63=Checks meta object for syms (% C% Unit sym allowed) (...1:#n)
54CDB=Internal MINR (1.E-499)
54CEF=(Meta -> 'Meta&Ob') Adds next then SYMBN
54D12=Internal MAXR (9.99999999999E499)
54D35=Internal pi (3.14159265359)
54D58=Internal i (0,1)
54D7B=Internal e (2.71828182846)
54E7F=PI -> COLA, PI 2 / -> skipcola, else continue (Others for prev stream)
54E7F=Used by COLCT routines (SIN(PI/2) etc)
54E8B:[PI Ob Ob Ob Ob]
54E95:[/ 2 PI Ob Ob]
54EA0=Internal RE (1:sym -> ALG)
54EB9=Internal IM (1:sym -> ALG)
54ED2=Internal NOT (1:sym -> ALG)
54EEB=Internal NEG (1:sym -> 1:ALG)
54F04=Internal ABS (1:sym -> 1:ALG)
54F1D=Internal CONJ (1:sym -> 1:ALG)
54F36=Internal INV (1:sym -> 1:ALG)
54F4F=Internal ARG (1:sym -> 1:ALG)
54F68=Internal SIGN (1:sym -> 1:ALG)
54F81=Internal sqrt (1:sym -> 1:ALG)
54F9A=Internal SQ (1:sym -> 1:ALG)
54FB3=Internal SIN (1:sym -> 1:ALG)
54FCC=Internal COS (1:sym -> 1:ALG)
54FE5=Internal TAN (1:sym -> 1:ALG)
54FFE=Internal SINH (1:sym -> 1:ALG)
55017=Internal COSH (1:sym -> 1:ALG)
55030=Internal TANH (1:sym -> 1:ALG))
55049=Internal ASIN (1:sym -> 1:ALG))
55062=Internal ACOS (1:sym -> 1:ALG))
5507B=Internal ATAN (1:sym -> 1:ALG))
55094=Internal ASINH (1:sym -> 1:ALG))
550AD=Internal ACOSH (1:sym -> 1:ALG))
550C6=Internal ATANH (1:sym -> 1:ALG))
550DF=Internal EXP (1:sym -> 1:ALG))
550F8=Internal LN (1:sym -> 1:ALG))
55111=Internal LOG (1:sym -> 1:ALG))
5512A=Internal ALOG (1:sym -> 1:ALG))
55143=Internal LNP1 (1:sym -> 1:ALG))
5515C=Internal EXPM (1:sym -> 1:ALG))
55175=Internal ! (1:sym -> 1:ALG))
5518E=Internal IP (1:sym -> 1:ALG))
551A7=Internal FP (1:sym -> 1:ALG)
551C0=Internal FLOOR (1:sym -> 1:ALG)
551D9=Internal CEIL (1:sym -> 1:ALG)
551F2=Internal XPON (1:sym -> 1:ALG)
5520B=Internal MANT (1:sym -> 1:ALG)
55224=Internal D->R (1:sym -> 1:ALG)
5523D=Internal R->D (1:sym -> 1:ALG)
55256=Internal UBASE (1:sym -> 1:sym)
5526F=Internal UVAL (1:sym -> 1:sym)
55314=Example: A B + #3 (1LAM=INV) :: M1s.. INV ; -> A B + INV #4
55314=Example: A B + #3 (1LAM=INV) :: M1s.. x+ ; -> A B #2
55314=Example: A B + INV #4 (1LAM=INV) :: M1s.... INV ; -> A B + #3
55314=If next matches Metas 1st ob then drop it, else add 1LAM to tail
553D2=All M<op>w1 words must have <op> in 1LAM and ABND is NOT made
553D2=Negates Meta object (1LAM has xNEG)
5540E=Example: (1LAM=SIGN) A B + #3 -> A B + SIGN #4
5540E=Example: (1LAM=SIGN) A B + SIGN #4 -> A B + SIGN #4
5540E=If Metas 1st is EQ to 1LAM then nothing, else add it to tail
554EF=(Meta&Ob -> Meta&w1&NEG)
5551C=(Meta -> %0 #1)
55535=(Meta -> %1 #1)
5554E=(Meta -> %-1 #1)
55620=(Meta SQ if already ^) Example: A B + 3 ^ #5 -> A B + 3 2 * ^ #5 
5573D=:: :: :: R2skipcola <Never> ; <Never>; <Never> <This> <Never> ;
5573D=:: RDROP 'R DROPCOLA COLA ;
55878=(Meta1(=Meta2) Meta3(=Meta4) -> ALG_Meta1<op>Meta3=Meta2<op>Meta4 ) 
55878=Executes 2LAM (A meta handler) on 2 metas after splitting them (=)
558BE=If meta is equation split it (dropping =), else duplicate meta
558BE=Example: A B + 3 = #5  ->  3 #1  A B + #3
558DC=(2:sym 1:sym) Usage: :: sscknum2 <ToMeta> Command ;
558DC=(with Command on 1LAM) after which SYMBN is done (if necessary)
558DC=Else stk1&2 are splitted and op&addtailw1 is executed with xAND
558DC=Evaluates command according to NumFlag?
558DC=Example: :: sscknum2 top&addtailw1 xAND ; is internal SYMAND
558DC=If NumFlag is set, stk1&2 are evaled and xAND is EVALed
558DC=If symbolic mode, then <ToMeta> is evaluated on the exploded sym
558F5=(2:sym 1:%) Othewise the same as sscksum2 (2 first letters!!)
5590E=(2:% 1:sym) Othewise the same as sncksum2 (2 first letters!!)
55927=Internal = (2:%/C%/sym/Unit 1:%/C%/sym/Unit -> 1:ALG)
5599A=Internal AND (2:sym,1:%)
559B3=Internal AND (2:%,1:sym)
559CC=Internal AND (2:sym,1:sym)
559E5=Internal OR (2:sym,1:%)
559FE=Internal OR (2:%,1:sym)
55A17=Internal OR (2:sym,1:sym)
55A30=Internal XOR (2:sym,1:%)
55A49=Internal XOR (2:%,1:sym)
55A62=Internal XOR (2:sym,1:sym)
55A7B=Internal == (2:sym 1:%/C%/Unit)
55A94=Internal == (2:%/C%/Unit 1:sym)
55AAD=Internal == (2:sym 1:sym)
55AC6=Internal <> (2:sym 1:%/C%/Unit)
55ADF=Internal <> (2:%/C%/Unit 1:sym)
55AF8=Internal <> (2:sym 1:sym)
55B11=Internal < (2:sym,1:%/Unit)
55B2A=Internal < (2:%/Unit,1:sym)
55B43=Internal < (2:sym,1:sym)
55B5C=Internal > (2:sym,1:%/Unit)
55B75=Internal > (2:%/Unit,1:sym)
55B8E=Internal > (2:sym,1:sym)
55BA7=Internal <= (2:sym,1:%/Unit)
55BC0=Internal <= (2:%/Unit,1:sym)
55BD9=Internal <= (2:sym,1:sym)
55BF2=Internal >= (2:sym,1:%/Unit)
55C0B=Internal >= (2:%/Unit,1:sym)
55C24=Internal >= (2:sym,1:sym)
55C3D=Internal % (2:sym 1:%/Unit -> 1:ALG)
55C56=Internal % (2:%/Unit 1:sym -> 1:ALG) 
55C6F=Internal % (2:sym 1:sym -> 1:ALG)
55C88=Internal %CH (2:sym 1:%/Unit -> 1:ALG)
55CA1=Internal %CH (2:%/Unit 1:sym -> 1:ALG)
55CBA=Internal %CH (2:sym 1:sym -> 1:ALG)
55CD3=Internal %T (2:sym 1:%/Unit -> 1:ALG)
55CEC=Internal %T (2:%/Unit 1:sym -> 1:ALG)
55D05=Internal %T (2:sym 1:sym -> 1:ALG)
55D1E=Internal COMB (2:sym 1:% -> 1:ALG)
55D37=Internal COMB (2:% 1:sym -> 1:ALG)
55D50=Internal COMB (2:sym 1:sym -> 1:ALG)
55D69=Internal PERM (2:sym 1:% -> 1:ALG)
55D82=Internal PERM (2:% 1:sym -> 1:ALG)
55D9B=Internal PERM (2:sym 1:sym -> 1:ALG)
55DB4=Internal RND (2:sym 1:% -> 1:ALG)
55DCD=Internal RND (2:%/C%/Array/Unit 1:sym -> 1:ALG)
55DE6=Internal RND (2:sym 1:sym ->1:ALG)
55DFF=Internal TRNC (2:sym 1:% -> 1:ALG)
55E18=Internal TRNC (2:%/C%/[]/Unit 1:sym -> 1:ALG)
55E31=Internal TRNC (2:sym 1:sym -> 1:ALG)
55E4A=Internal MAX (2:sym 1:%/Unit -> 1:ALG)
55E63=Internal MAX (2:%/Unit 1:sym -> 1:ALG)
55E7C=Internal MAX (2:sym 1:sym -> 1:ALG)
55E95=Internal MIN (2:sym 1:%/Unit -> 1:ALG)
55EAE=Internal MIN (2:%/Unit 1:sym -> 1:ALG)
55EC7=Internal MIN (2:sym 1:sym -> 1:ALG)
55EE0=Internal ^ (2:sym 1:%/C%/Unit -> 1:ALG)
55EF9=Internal ^ (2:%/C%/Unit 1:sym -> 1:ALG)
55F12=Internal ^ (2:sym 1:sym -> 1:ALG)
55F2B=Internal + (2:sym 1:%/C%/Unit)
55F44=Internal + (2:%/C%/Unit 1:sym)
55F5D=Internal + (2:sym 1:sym -> 1:ALG)
55F76=Internal - (2:sym 1:%/C%/Unit ->1:ALG)
55F8F=Internal - (2:%/C%/Unit 1:sym -> 1:ALG)
55FA8=Internal - (2:sym 1:sym -> 1:ALG)
55FC1=Internal * (2:sym 1:%/C%/Unit -> 1:ALG)
55FDA=Internal * (2:%/C%/Unit 1:sym -> 1:ALG)
55FF3=Internal * (2:sym 1:sym -> 1:ALG)
5600C=Internal / (2:sym 1:%/C%/Unit -> 1:ALG)
56025=Internal / (2:%/C%/Unit 1:ALG)
5603E=Internal / (2:sym 1:sym -> 1:ALG)
56057=Internal MOD (2:sym 1:% -> 1:ALG)
56070=Internal MOD (2:% 1:sym -> 1:ALG)
56089=Internal MOD (2:sym 1:sym -> 1:ALG)
560A2=Internal XROOT (2:sym 1:%/Unit -> 1:ALG)
560BB=Internal XROOT (2:%/Unit 1:sym -> 1:ALG)
560D4=Internal XROOT (2:sym 1:sym -> 1:ALG)
560ED=Combines metas, then adds LAM1 to tail
560ED=Example: (1LAM=+)  A B + #3  C D - #3  ->  A B + C D - + #7
56101=(Meta -> LAM3&Meta&LAM1)
56101=Example: (3LAM=0,1LAM=+) A B + #3 -> 0 A B + + #5
5611F=(Meta -> Meta&LAM3&LAM1)
5611F=Example: (3LAM=0,1LAM=+) A B + #3 -> A B + 0 + #5
5613D=(Meta Meta -> Meta) (Meta1 Meta2 -> Meta1&Meta2<op>) (<op> from LAM1)
56174=If Metas are Equal, %0 #1
56183=(Meta1 Meta2 -> %0 #1)
561D8=(Meta1 Meta2 -> %-1 #1)
562BE=(Meta1 Meta2 Meta3 -> Meta1&Meta2LAM1)
56309=(Meta Ob -> LAM3 #1)
56331=Meta + (3GETLAM, if num=0 then no add, else SWAP and M+)
563F4=(Meta<INV> Ob -> Ob&Meta<*>,  Meta Ob -> Ob&Meta</>
5643A=(Meta Ob -> %0 #1)
5645D=(3LAM = %) (Meta -> Meta')
5646C=(3LAM = %0 or C%0) (Meta Any -> %1 / C%1 #1)
564D0=(3LAM = %2 or C%2) (Meta -> Meta')
5662E=Numeric Integral (4:sym 3:ALG_var 2:low 1:hi)
56683=Numeric Integral (4:sym 3:ALG_var 2:low_Unit 1:hi_Unit)
566A6=Numeric Integral (4:sym 3:ALG_var 2:%low 1:%hi)
566D8=Binds CARCOMP (ID) to ID>LAM (same name)
5670F=Changes all IDs that match LAM_'dvar to LAM_'dvar (#0 Meta -> Meta)
5676E=( --> LAM )
56912=Numeric Integral (4:sym 3:ALG_var 2:low(%,Unit,sym) 1:hi(%,Unit,sym))
56949=Internal Sigma (4:sym 3:sym 2:sym 1:Any)
56A06=Internal Sigma (4:sym 3:sym 2:% 1:Any)
56A4C=Internal Sigma (4:sym 3:% 2:sym 1:Any)
56AC9=Internal Sigma (4:sym 3:% 2:% 1:Any)
56C27=(Meta1 Any -> ALG_Meta1&SIGN)
572A2=Internal ISOL (sym id --> symb )
572A7=(sym ID -> sym ID Meta T/F) (Rstack is popped if RINVers got it)
57414=(Meta1 Meta2 Ob1 Ob2 -> FALSE)
57428=(Meta1 Meta2 Ob -> FALSE)
57441=(Meta1 Meta2 Ob -> Meta2&Ob Meta1)
5768A=(Meta Ob -> Meta Ob True/False) True if Ob is EQUAL to some ob in Meta
57888=(Meta1 Meta2&NEG -> Meta1&Meta2&-, Meta1 Meta2 -> Meta1&Meta2&+)
57A0C=Internal EXPAN (1:%/C%/sym)
57A48=Do 2 pshzer commands first (#0 #0 Meta -> Meta)
57A61=(Meta1 Meta2 Meta3 Meta2&Meta3&Meta1)
57AA2=(Meta -> Meta)
57B33=(Meta1 Meta2&Ob -> Meta1&Meta2 Ob #1)
57B58:[NEG INV Ob Ob Ob]
57B9F=(Meta Ob -> %1 #1)
57BC2=(Meta&Ob1&Ob2 Ob3 -> Meta)
57C71=(Meta1&Meta2&<+/->  ->  expanded Meta^2)
57CDF=(Meta -> Meta<%2><^>)
57CF8=If % is integer, -> %>0? SGN(%)*(ABS(%)-1) TRUE, else FALSE
57D90=Internal COLCT (1:%/C%/sym)
57E08=Meta is reversed & + and * are changed back to /,NEG etc
57F4B=(Meta1&Meta2 Meta3 --> Meta1 Meta3 Meta2 )
582BE=Tests if 2 metas have same ^ bases (M1 M2 --> M1^ M2^ M2b M1b flag )
582E6=(Meta4 Meta3 Meta2 Meta1 -> Meta2&Meta3&Meta4<+><^>)
5837C=(Meta2 Meta1 -> Meta2&Meta1<^>)
5848A=(Meta4 Meta3 Meta2 Meta1 -> Meta3&Meta4<+>&Meta2)
584B2=(Meta1 Meta2 -> Meta1 Meta2 T/F)
58525=(Meta1 Meta2 --> Meta1 Meta2 flag) (See BodyBigger?)
585A7=Takes 2 addresses from stack, compares data from there on until
585A7=a different nibble is found. Then if stk2 has bigger then TRUE else F
58620=(Meta1&Meta2<^> -> Meta2 Meta1) (Meta1&Meta2 -> 1 #1 Meta1&Meta2)
58715=(Meta -> Meta T/F) True,if M has no IDs/LAMs nor ::s starting with CK0
587AA=All 'lone' terms get a factor and all -,/,SQ etc cmds are replaced
587AA=with +,* and ^ (#0 Meta -> Reversed Meta)
58A61=Example: ([A INV B INV *] --> [A B * INV])
58A93=Example: ([A B INV *] --> [A B /])
58AAC=Example: ([A INV B *] --> [B A /])
58ADE=(Meta<%-1><^><*> ? -> case
58C02=Example: Meta<+><+><+> -> Meta #3)
58D75=Internal SHOW (2:sym 1:ID/LAM)
58DEB=If not seco, FALSE, else FormDataGet
5910B=Internal SHOW (2:sym 1:{}) (Doesn't check {} for being IDs only)
591AD=Internal QUAD (2:sym 1:ID)
5928E=( c b a --> SYMB flag ) Returns FALSE if only 1 solution
5928E=Goto entry to solve a quadratic equation
592B6=( c b a of quadratic eq --> SYMB TRUE )
592B6=Errors if a <> 0
595DD=Internal TAYLR (3:sym 2:ID 1:%)
595F1=( symf id % --> symf )
59E81=->() for CONJ,RE,IM
59F91=Internal SIZE (1:sym -> 1:%)
59FB9=(Meta&Ob1&Ob2&Ob3 -> Meta)
5A01D=Makes Algebraic of stk2
5A036=Evals next with NumFlag cleared (Resumed afterwards)
5A176=Adds WHERE to the tail of a symbolic
5A2F7=(Id&Meta -> Alg_Id Alg)
5A4B9=(2:#n 1:Any -> 1:T/F)  True if #n = #0/#2/#4/#6....
5A55E=Length of the fractional part (% -> #n)
5A5C9=(%Meta --> %den %nom)
5A5C9=Converts 'continued fractions' to a fraction
5A62E=Internal ->Q (2:#digits 1:% -> meta)
5A72A=(#accuracy % --> Meta) (If Meta len = #1 approx is integer)
5A72A=Low level ->Q, makes no ->QPI etc checks
5A8A5=(% #dd -> %)
5A8E8=(% #dd -> T/F)
5A952=Rcl current accuracy ( -> %0.0...1 )
5A983=Recall current display accuracy (-> 1:#digits)
5A9F5=Internal ->Q (1:% & 'piflag bound (1LAM) to mode (True = ->QPI))
5AA77=->Q (1:C% or % -> 1:C% % or ALG)
5AAC7=Symbolic INTEGRAL (4:low 3:hi 2:sym 1:ALG_var)
5AAE5=(Integration bounds list storage)
5ACC7=(#0 #0 Meta --> Meta_Ok Meta_NotOk )
5ACC7=(Merging with +)
5ACC7=Meta_Ok contains the integrated part, Meta_NotOk the unseccesful part)
5ACC7=Symbolically integrates a Meta object (var replaced by dvar)
5ACD6=(Meta&+ -> Meta, Meta -> Meta)
5AD08=(Meta --> Meta FALSE / Meta #level TRUE )
5AD08=Seeks LAMdvar (EQ test!) in Meta. Returns stack level if found.
5AD80=Is Meta linear in LAMdvar? (M #level --> M' TRUE / M' #loc FALSE )
5AD9E=(Meta #level --> Meta #loc flag )
5AFAB=(Meta_ok Meta_fail Meta_temp Meta --> Meta_ok' Meta_fail' Meta_temp)
5B0CD=(M_ok M_fail M_temp Meta --> M_ok' M_fail' M_temp )
5B0D2=(Meta --> Meta') Multiplies with LAMdvar
5B0FA=( M1 M2 M3 M4 --> M1&M4&+ M2 M3 TRUE)
5B131=(M1 M2 M3 M4 --> M1' M2 M3) (dvars? gives TRUE)
5B140=(Meta #loc --> Meta')
5B1F4=(MetaTail Meta MetaAdd --> Meta')
5B32F=Integration function is required to be 1st in Meta
5B34D=(Meta {} --> Meta FALSE / Meta' TRUE )
5B375=Takes lam and symbolic from stream, divides symb with dx(lam)
5B3D9=If DEG then adds '*(180/PI)/dx(L1)'
5B3D9=If GRAD then adds '*200/(PI)/dx(L1)'
5B3D9=If RAD then adds '/dx(L1)'
5B433=If RAD then adds '/dx(L1)'
5B433=if DEG then adds '*(180/PI)/dx(L1)'
5B433=if GRAD then adds '*(200/PI)/dx(L1)'
5B4A6=Adds *180/PI or *200/PI to Meta according to DEG? (Meta -> Meta')
5B861=(Meta3 Meta2 Meta1 -> Meta2&Meta1&Meta3)
5BBE5=Negates Meta object
5BC03=(Meta1&Meta2<op> -> Meta'&Meta2<op>) Where Meta'=metaNEG(Meta1)
5BC5D=(Meta&NEG -> Meta&-, Meta -> Meta&+)
5BC8A=(Meta&NEG -> Meta&+, Meta -> Meta&-)
5BCB7=(Meta&INV -> Meta&/, Meta -> Meta&*)
5BCE4=(Meta&INV -> Meta&*, Meta -> Meta&/)
5BD3E=(Meta&NEG&Ob -> Meta&-, Meta&Ob -> Meta&+)
5BE56=(A INV B INV * -> A B * INV, A B INV * -> A B /, A INV B * -> B A /)
5BE62:[* INV Ob INV Ob]
5BE6C:[* INV Ob Ob Ob]
5BE76:[* Ob INV Ob Ob]
5BE81=<--> command in RULES menu (Meta -> Meta')
5BE81=All these routines use the dispatching routine at 5F6F9
5BE8D:[+ Ob Ob Ob Ob]
5BE9D:[- Ob Ob Ob Ob]
5BEAD:[* Ob Ob Ob Ob]
5BEBD:[/ Ob Ob Ob Ob]
5BEDA:[+ + Ob Ob Ob]
5BEE4:[+ - Ob Ob Ob]
5BEEE:[- + Ob Ob Ob]
5BEFE:[- - Ob Ob Ob]
5BF0E:[* * Ob Ob Ob]
5BF18:[* / Ob Ob Ob]
5BF22:[/ * Ob Ob Ob]
5BF32:[/ / Ob Ob Ob]
5BF42:[^ * Ob Ob Ob]
5BF5F:[+ Ob + Ob Ob]
5BF69:[- Ob + Ob Ob]
5BF73:[+ Ob - Ob Ob]
5BF83:[- Ob - Ob Ob]
5BF93:[* Ob * Ob Ob]
5BF9D:[/ Ob * Ob Ob]
5BFA7:[* Ob / Ob Ob]
5BFB7:[/ Ob / Ob Ob]
5BFC7:[^ Ob ^ Ob Ob]
5BFE4:[* + Ob Ob Ob]
5BFEE:[* - Ob Ob Ob]
5BFF8:[/ + Ob Ob Ob]
5C008:[/ - Ob Ob Ob]
5C018:[^ + Ob Ob Ob]
5C028:[^ - Ob Ob Ob]
5C038:[EXP + Ob Ob Ob]
5C048:[ALOG + Ob Ob Ob]
5C058:[EXP - Ob Ob Ob]
5C068:[ALOG - Ob Ob Ob]
5C078:[LN * Ob Ob Ob]
5C088:[LOG * Ob Ob Ob]
5C098:[LN / Ob Ob Ob]
5C0A8:[LOG / Ob Ob Ob]
5C0C5:[* Ob + Ob Ob]
5C0CF:[* Ob - Ob Ob]
5C0D9:[/ Ob + Ob Ob]
5C0E3:[/ Ob - Ob Ob]
5C0ED:[^ Ob * Ob Ob]
5C0F7:[^ Ob / Ob Ob]
5C10E:[* Ob + Ob Ob]
5C118:[* Ob - Ob Ob]
5C122:[/ Ob + Ob Ob]
5C12C:[/ Ob - Ob Ob]
5C143:[NEG + Ob Ob Ob]
5C14D:[NEG - Ob Ob Ob]
5C157:[NEG * Ob Ob Ob]
5C167:[NEG / Ob Ob Ob]
5C177:[NEG LN Ob Ob Ob]
5C187:[NEG LOG Ob Ob Ob]
5C197:[NEG NEG Ob Ob Ob]
5C1A1:[NEG INV Ob Ob Ob]
5C1AB:[INV ^ Ob Ob Ob]
5C1BB:[INV EXP Ob Ob Ob]
5C1CB:[INV ALOG Ob Ob Ob]
5C1DB:[INV * Ob Ob Ob]
5C1E5:[INV / Ob Ob Ob]
5C1EF:[INV INV Ob Ob Ob]
5C1F9:[INV NEG Ob Ob Ob]
5C210:[* Ob Ob Ob Ob]
5C220:[/ Ob Ob Ob Ob]
5C230:[^ Ob Ob Ob Ob]
5C240:[EXP Ob Ob Ob Ob]
5C250:[ALOG Ob Ob Ob Ob]
5C26D:[LN Ob Ob Ob Ob]
5C27D:[LOG Ob Ob Ob Ob]
5C28D:[+ Ob Ob Ob Ob]
5C29D:[- Ob Ob Ob Ob]
5C2AD:[* Ob Ob Ob Ob]
5C2BD:[/ Ob Ob Ob Ob]
5C2DA:[EXP * Ob Ob Ob]
5C2EA:[ALOG * Ob Ob Ob]
5C2FA:[EXP / Ob Ob Ob]
5C30A:[ALOG / Ob Ob Ob]
5C327:[^ Ob EXP Ob Ob]
5C337:[^ Ob ALOG Ob Ob]
5C354:[LN ^ Ob Ob Ob]
5C364:[LOG ^ Ob Ob Ob]
5C381:[* Ob LN Ob Ob]
5C391:[* Ob LOG Ob Ob]
5C3A1:[/ Ob LN Ob Ob]
5C3B1:[/ Ob LOG Ob Ob]
5C3CE:[* ^ Ob Ob ^]
5C3DE:[/ ^ Ob Ob ^]
5C3EE:[* EXP Ob EXP Ob]
5C3FE:[* ALOG Ob ALOG Ob]
5C40E:[/ EXP Ob EXP Ob]
5C41E:[/ ALOG Ob ALOG Ob]
5C42E:[+ LN Ob LN Ob]
5C43E:[+ LOG Ob LOG Ob]
5C44E:[- LN Ob LN Ob]
5C45E:[- LOG Ob LOG Ob]
5C46E:[+ * Ob Ob Ob]
5C47E:[- * Ob Ob Ob]
5C48E:[+ / Ob Ob Ob]
5C49E:[- / Ob Ob Ob]
5C4AE:[+ Ob Ob Ob Ob]
5C4BE:[- Ob Ob Ob Ob]
5C4DB:[+ * Ob Ob *]
5C4EB:[- * Ob Ob *]
5C4FB:[+ / Ob Ob /]
5C50B:[- / Ob Ob /]
5C51B:[* ^ Ob Ob ^]
5C52B:[/ ^ Ob Ob ^]
5C548:[+ / Ob Ob Ob]
5C558:[- / Ob Ob Ob]
5C568:[+ Ob / Ob Ob]
5C578:[- Ob / Ob Ob]
5C595:[+ Ob Ob Ob Ob]
5C5A5:[- Ob Ob Ob Ob]
5C5B5:[* Ob Ob Ob Ob]
5C5C5:[/ Ob Ob Ob Ob]
5C5E2:[+ Ob Ob Ob Ob]
5C5F2:[- Ob Ob Ob Ob]
5C602:[* Ob Ob Ob Ob]
5C612:[/ Ob Ob Ob Ob]
5C62F:[+ Ob Ob Ob Ob]
5C63F:[- Ob Ob Ob Ob]
5C64F:[* Ob Ob Ob Ob]
5C65F:[/ Ob Ob Ob Ob]
5C67C:[EXP Ob Ob Ob Ob]
5C6A0:[+ Ob Ob Ob Ob]
5C6AA:[- Ob Ob Ob Ob]
5C6B4:[* Ob Ob Ob Ob]
5C6BE:[/ Ob Ob Ob Ob]
5C6C8:[= Ob Ob Ob Ob]
5C6EC:[+ Ob Ob Ob Ob]
5C6FC:[- Ob Ob Ob Ob]
5C70C:[* Ob Ob Ob Ob]
5C71C:[/ Ob Ob Ob Ob]
5C72C:[= Ob Ob Ob Ob]
5C73D=->() for CONJ,RE,IM
5C750:[CONJ + Ob Ob Ob]
5C760:[CONJ - Ob Ob Ob]
5C770:[CONJ * Ob Ob Ob]
5C780:[CONJ / Ob Ob Ob]
5C790:[CONJ NEG Ob Ob Ob]
5C7A0:[CONJ INV Ob Ob Ob]
5C7B0:[CONJ EXP Ob Ob Ob]
5C7C0:[CONJ SQ Ob Ob Ob]
5C7D0:[RE + Ob Ob Ob]
5C7E0:[RE - Ob Ob Ob]
5C7F0:[RE NEG Ob Ob Ob]
5C800:[IM + Ob Ob Ob]
5C810:[IM - Ob Ob Ob]
5C820:[IM NEG Ob Ob Ob]
5C830:[RE * Ob Ob Ob]
5C83A:[IM * Ob Ob Ob]
5C858:[SIN Ob Ob Ob Ob]
5C868:[COS Ob Ob Ob Ob]
5C878:[TAN Ob Ob Ob Ob]
5C888:[SINH Ob Ob Ob Ob]
5C898:[COSH Ob Ob Ob Ob]
5C8A8:[TANH Ob Ob Ob Ob]
5C8B8:[ASIN Ob Ob Ob Ob]
5C8C8:[ACOS Ob Ob Ob Ob]
5C8D8:[ATAN Ob Ob Ob Ob]
5C8E8:[ASINH Ob Ob Ob Ob]
5C8F8:[ACOSH Ob Ob Ob Ob]
5C908:[ATANH Ob Ob Ob Ob]
5C930:[SIN + Ob Ob Ob]
5C940:[SIN - Ob Ob Ob]
5C950:[COS + Ob Ob Ob]
5C960:[COS - Ob Ob Ob]
5C970:[SINH + Ob Ob Ob]
5C980:[SINH - Ob Ob Ob]
5C990:[COSH + Ob Ob Ob]
5C9A0:[COSH - Ob Ob Ob]
5C9B0:[TANH + Ob Ob Ob]
5C9C0:[TANH - Ob Ob Ob]
5C9D0:[TAN + Ob Ob Ob]
5C9E0:[TAN - Ob Ob Ob]
5C9FB=Meta<-A with M++, M-+, M**, M/*
5CA0F=op2 (M1 op1 M2) --> (op2 M2) op1 (M1)
5CA32=(op1 M1) op2 (M2) --> op1 (M1 op2 M2)
5CA50=(M1) op2 (M2 op1 M3) -->  (M1 op2 M2) op1 (M1 op2 M3)
5CAA5=(op1 M1) op2 (M2) --> op1 ((M1 op2 M2) op2 M2)
5CAE1=(M1 op1 M2) op2 (M3) --> (M1 op2 M3) op1 (M2)
5CB4F=M1&ob1&ob2 M2 M3&ob M3 M5 --> [M4 M3 M2 M1 ob2 ob1] TRUE
5CBF9=(Meta1&Meta2&op -> Meta2&Meta1)
5CC12=(Meta&Ob1&Ob2 -> Meta)
5CCEE=(Meta1 Meta2&Meta3<no> -> Meta1&Meta2 Meta3)
5CD02=(Meta -> Meta&+) example: A B + #3 -> A B + + #4
5CDE3=<-D with right shift = until no changes happen
5CFC3=->()m for CONJ,RE,IM
5D2D5=[M1 M2 op] --> M2 [op] M1
5D30C=[M1 M2 op] --> M1 [op] M2
5D6F4=(Meta1&Ob Meta2 -> Ob&Meta2 Meta1)
5D794=T-> with M+, M-
5D7EF=T-> with M*, M/
5DCEB=->() with M*RE
5DD19=->() with M*IM
5DD65=(Meta1 Meta2 -> Meta1&Ob Meta2&Ob) (Ob is next in this instr. stream)
5DE55=Actually this one drops remainder of this stream (Thus NS: name too)
5DEEB=Similar to below but accepts << -> LAM a << programs too
5DEF7=COLA if stk1 starts with << -> '...' or other function structure
5E067=If symbolic, INNERCOMP, else <1h>
5E085=Meta to symbolic (Doesn't make an ALG of 2:Ob 1:#1)
5E0A3=Tries SYMBN, if error then NULLSYMB
5E0DA=Tries {}N, if error then NULL{}
5E111=Tries ::N, if error then NULL::
5E2F8=(2:comp2 1:comp1 -> Meta2&Meta1)
5E30C=(ob2 ob1 --> Meta2 Meta1)
5E32A=(Obn .. Ob1 #n -> Meta) where Obs are exploded if they are ALGs
5E32A=Example: ALG_A+B 1 ALG_E*F #3  ->  A B + 1 E F * #7
5E35C=(Meta -> Meta Meta)
5E3AC=(Meta1 Meta2 Meta3 -> Meta1&Meta3 Meta2)
5E3C0=(Meta1 Meta2 Meta3 -> Meta1&Meta2 Meta3)
5E3E8=(Meta2 Ob -> Ob #1 Meta2)
5E401=(Meta Ob -> Ob&Meta)
5E415=(Meta1 Meta2 -> Meta1&Meta2)
5E490=(Meta1 Meta2 Meta3 -> Meta1&Meta2&Meta3)
5E4A9=(Meta&Ob -> Meta Ob)
5E4BD=(Ob&Meta -> Meta Ob)
5E4D1=(Meta1 Meta2 -> Meta2&Meta1)
5E4EA=(Meta1 Meta2&Ob -> Ob&Meta1 Meta2)
5E503=(Meta1 Meta2&Ob -> Meta1&Ob Meta2)
5E51C=(Meta -> Meta&Ob) (Next ob from this instr. stream)
5E530=(Meta -> Meta&Ob1&Ob2) (2 next obs from this instr. stream)
5E549=(Meta1 Meta2 -> Meta1&Ob Meta2) (Ob is next in this instr. stream)
5E562=(Meta1 Meta2 -> Meta1&Ob1&Ob2 Meta2) (2 next from this instr. stream)
5E585=(Meta1 Symb -> Meta')
5E59E=(Meta&Ob1 -> Meta&Ob2) (Ob1 dropped, Ob2 next in this instr.stream)
5E5B7=(1:ID/LAM/romp -> 2:Contents 1:F / 2:ID/LAM/romp/Other 1:T)
5E652=Make stk1 into an Algebraic (if already symb does nothing)
5E67A=(Meta -> #0 Meta)
5E68E=(Meta1&Meta2&Ob -> Meta2&Ob Meta1) (Internal OBJ->)
5E6BB=(Meta&Ob -> Ob #1 Meta)
5E6F2=(Meta1 Meta2&Meta3<no op> -> Meta1&Meta3 Meta2)
5E6F2=Example: A B + #3  C D * E F * #6  ->  E F * A B + #6 C D * #3
5E706=(Meta1 Meta2 Ob -> Ob&Meta1 Meta2)
5E7A5=(Meta1 Meta2 Ob -> Meta1&Ob Meta2)
5E843=(Meta1 Meta2 Meta3 -> Meta2&Meta1 Meta3)
5E857=(Meta1 Meta2 Meta3 -> Meta2 Meta1 Meta3)
5E889=(That is why Meta must be present)
5E889=Checks FCNAPPLY & INFARGSECO? before calling !argnum
5E889=Returns commands argument count (Meta ob --> Meta ob #args)
5E8DE=Arg count is decided on first command in the secondary, matches:
5E8DE=CK0 CK1&Dispatch ... CK4&Dispatch, else #5 is assumed
5E8DE=Returns alg. operators argument count (1:+,-...or.. -> 2:oper 1:#args)
5E984=If DUPTYPE? == seco then SKIP, else COLA
5EA72=If not symbolic constants/numeric mode then COLA else SKIP
5EA9F=(Meta without last operator -> Meta2 Meta1)
5EA9F=Example: A B + C D - #6 -> C D - #3 A B + #3
5EAC2=(Meta1&Meta2<no op> -> Meta1 Meta2)
5EAF4=(Meta&Ob -> Meta)
5EB08=subtract two and drop stk2/stk3 (3:Any,2:Anu,1:#) (See 5CC12)
5EB1C=(Meta1 Meta2 -> Meta2 Meta1)
5EB58=(Meta1 Meta2 Meta3 -> Meta2 Meta3 Meta1)
5EBDB=(Meta1 Meta2 Meta3 -> Meta3 Meta1 Meta2)
5EDBE=If @D1 is DOREAL, DOCMP, DOARRY or DOLNKARRY sets carry
5EDBE=NS:stk1arf?
5EDBE=Uses A.A (@D1) and C.A (last tested prolog)
5EDFC=If type stk1 is %, C%, [] or linked array the COLA, else SKIP
5EE10=If Metas 1st ob is %<0 then %ABS and COLA
5EE10=If Metas 1st ob is xNEG then drop it and COLA
5EEDB=If ob is % and < 0 then COLA else SKIP
5EF15=Is metaobs last ob EQUAL to next in this stream? & case (1:Meta)
5EF2E=(Meta) :: M1st+case <If level2 is +> <Else> ;
5EFD9=Is metaobs last ob equal to Any? & case (Meta 1:Any)
5EFF9=(Meta&ob1 Meta&ob2 ob3 --> Meta&ob1 Meta&ob2)
5EFF9=COLA if ob1=ob2=ob3 else SKIP
5F061=if copy type(stk2) = ID/LAM, then COLA, else skip
5F0FA=If stk1 = %0 or C%0 then COLA else SKIP
5F127=If DUP %0= then COLA else SKIP
5F13B=If DUP C%0= then COLA else SKIP
5F154=If DUP stk1 = %1 or C%1 then COLA else SKIP
5F181=If DUP %1= then COLA else SKIP
5F19F=If DUP C%1= then COLA else SKIP
5F1BD=If DUP stk1 is %2 or C%2 then COLA else SKIP
5F1EA=If DUP %2= then COLA else SKIP
5F208=If DUP C%2= then COLA else SKIP
5F23A=If DUP stk1 = %-1 or C%-1 then COLA else SKIP
5F267=if DUP stk1 = %-1 then COLA, else SKIP
5F285=If DUP C%-1= then COLA else SKIP
5F2A3=Explodes ob with recursive SINNER calls (ob --> Meta)
5F2EE=(Meta -> Ob) Checks VUNS properties too.
5F370=(Meta1 Meta2 Ob -> Meta1&Ob Meta2) If Meta2 is empty end loop
5F384=DROP & if not (ID,LAM,%,C%,Unit) then symcomp
5F537=If DUP stk1 == COMPLEX/POLARDUMMY then COLA else SKIP
5F6F2=Uses data at 5F7E0
5F6F9=This routine dispatches on the meta object (Starting at level 2)
5F6F9=Usage: LC(5) data-address  GOSBVL #5F6F9  arglist...
5F6F9=arlist is of form: nnnnn addr/XLIB nnnnn addr/XLIB.... F
5F6F9=#addr is the address to the pointer list to be used
5F6F9=(If match is found the next object is COLAd)
5F6F9=CALL.A never returns, CALL is just used to pass the address of arglist
5F6F9=Example: 10000 XLIB 1190 01 22020 XLIB 1190 02 F with above addr
5F6F9=Example: 5F7E0: + - * ....
5F6F9=Example: COLCT uses this to match PI and PI 2 /
5F6F9=Expects args like + #n or - - Any - #n, but doesn't error if no match
5F6F9=is found (Matching is done until FALSE or rest of the number is zeros)
5F821:Set mode1
5F824:Set FCNAPPLY
5F827:A=ob
5F82A:ob=fcnapply?
5F836:A=stk D1=ob
5F839:B=stk
5F83B:A=prlg
5F83E:ob is not seco?
5F84A:Skip seco prlg
5F84D:A=secocmd
5F850:secocmd=CKINFARGS?
5F863:Init args
5F865:Incr args
5F867:C=checker
5F86A:D1=next checker
5F86D:secocmd <> checker?
5F875:Set args=0
5F877:C=args
5F87D:A=stk
5F87F:D1=stk
5F886:Set CKINFARGS
5F889:A=stk
5F88B:D1=stk
5F88E:next stkob
5F891:A=args#
5F894:A=stk D1=args#
5F897:skip # prolog
5F89A:C=args
5F89D:D1=stk
5F8A0:back stkob
5F8A3:args+=1
5F8A5:CKINFARGS?
5F8AA:args+=1
5F8AC:Mode2?
5F8AC:Now args is corrected
5F8B1:Next stkob
5F8B4:Increase stklevel
5F8C2:Increase counter by args-1
5F8CC:Counter zero?
5F8D5:Mode1 done?
5F8D7:Cont mode
5F8DB:A=counter (mode2)
5F8E1:args>=counter?
5F8E4:mode1 done?
5F8E6:counter=counter-args+1
5F8F0:Set mode2
5F8F3:Correct stklevel
5F926=(Meta #n #m --> Meta #level)
5F926=:: splitpoint #1- tailpsh ; would push the wanted subexpressions.
5F926=Calculates split location of m subexpressions starting from stack
5F926=Returns level of the last ob to be included in the split.
5F926=level n. Obs below stack level n are totally ignored.
5F93A=Pops #n and #m to R0 and R1, then D1=stklevel_n
5F93A:A=stklevel C=cnt
5F941:R0=stklevel
5F947:R1=cnt
5F954:A=stklevel
5F95A:A=5(A-1)
5F964:D1=D1+A
5F96E=(Meta #n #m --> Meta #start #len )
5F96E=Calculates subexpression end in Meta starting from #n.
5F996=(Meta #n --> Meta1 Meta2)
5F996=Pushes n-1 last obs in Meta to Meta1
5FA2C=(Meta -> N+3:Arg1 4:Argn 3:#args 2:Command 1:T / Meta F)
5FA45=(Meta&Ob1&Ob2 -> Meta Ob1)
5FA63=(Meta1&Ob1 Ob2 -> Meta1 Ob2)
5FB49=if pop stk1 <> True, then False, iterate loop (pop back)
5FB5D=:: 'R EVAL RDROP ;
5FBE6=(Meta1 Meta2 -> Meta1 Meta2) If Meta1 is #0 sized then COLA, else SKIP
5FC24=(Ob Meta -> Ob Meta Ob)
5FC38=(Meta2 -> %1 #1 Meta2)
5FC4C=(Meta1 Meta2&Ob -> Ob&Meta1 Meta2) (Ob changed to symbolic)
5FCA3=Compares C.A objects in D0 and D1, clears carry if match
5FDC1=Lenght to match
5FDCE=Next stack ob to compare
5FDDB=Next ob in pattern to match
5FF23=Increment LAMp & LAMep
5FF73=IF stk1 is ID/LAM and 1st char is '&' then TRUE, else FALSE
601B6=(Meta #n #pos2 #pos1 --> Meta flag )
601B6=Compares n Meta objects starting from positions pos1 and pos2
60236=Multiplies A.A with 5 (Uses C.A)
603BF=Multiplies C.A with 5, uses A.A
6045F=:: INCRLAM: LAM a ;  Does LAM a #1+ ' LAM a STO
6080B=Has True if MATCH was succesful
60A54=Sets matching prg ((4:Arg) 3:Arg 2:Arg 1:True if 3 args, else False
60B17=If next is True umatch else dmatch (2:sym 1:{} -> 2:sym 1:%flag)
60EBD=SWAP in return stack (Example :: RSWAP RDROP ; Drops prevprev program)
60F0E=(Meta&Ob1 Ob2 -> Meta&Ob2)
61099=Calls DupAndThen, ie first DUP, the next object which is 4UNROLL
6113C=DROP(2,3,4)
6114E=Drops 2 from return stack
61160=Drops 3 from return stack
6119E=(Ob&Meta -> Ob&Meta Ob)
611B0=A gets #, C gets the old D1
612EC=MC XFER: ROLL A.A levels and continue RPL
61305=(Ob Meta -> Meta Ob)
615BC=C is the offset in TEMPENV field (1st is F, second 19 etc)
617D8= ( #n --> #n ob lam FALSE / #n TRUE )
617D8=Checks that n is in limits
617D8=Get lam name & contents ( n = lam*10, ie 2lam --> 20)
617D8=Use n=0 to get protection word (ob) and env lenght (lam) as PTRs
6186C=(# #') :: #=case <True> <False> ;     == <True>/<False>
6187C=(# #') :: OVER#=case <True> <False> ;     == # <True> / # <False>
61891=(#)    :: DUP#0=case <True> <False> ;     == # <True> / # <False>
61896=(#)    :: #0=case <True> <False> ;        == <True> / <False>
618A8=(#)    :: DUP#0=csedrp <True> <False> ;   == <True> / # <False>
618BA=(Ob1 Ob2) :: EQcasedrop <True> <False> ;  == <True> / Ob1 <False>
618D3=(# #') :: OVER#=casedrop <True> <False> ; == <True> / # <False>
618E8=(Ob f) :: NOTcasedrop <True> <False> ;    == <True> / Ob <False>
618F7=(Ob f) :: casedrop <True> <False> ;       == <True> / Ob <False>
61903=MC XFER: skip next object and continue RPL
61907=MC: DROP, return and execute the next object in this stream
61910=(Ob1 Ob2 f) ::NOTcase2drop <True> <False>;== <True> / Ob1 Ob2 <False>
6191F=(Ob1 Ob2 f) :: case2drop <True> <False> ; == <True> / Ob1 Ob2 <False>
61933=(Ob1 Ob2) :: EQcase <True> <False> ;      == Ob1 <True> / Ob1 <False>
6194B=(Ob1 f)   :: caseDROP <False> ;           == () / Ob1 <False>
61960=(Ob1 f)   :: NOTcaseDROP <False> ;        == () / Ob1 <False>
6196C=MC XFER: continue RPL
61970=(Ob1 Ob2 f) :: case2DROP <False> ;        == () / Ob1 Ob2 <False>
61984=(Ob1 Ob2 f) :: NOTcase2DROP <False> ;     == () / Ob1 Ob2 <False>
61993=(f)   :: case <True> <False> ;            == <True> / <False>
619AD=(f)   :: NOTcase <True> <False> ;         == <True> / <False>
619BC=(f)   :: IT <True> <Rest> ;               == <True> <Rest> / <Rest>
619CB=Goto next address ( :: <prg> :: GOTO <addr> ; <rest> ; is GOSUB)
619E0=Goto next address if True
619F3=Goto next address if False
61A02=If pop stk1 = True -> set carry, else clear carry
61A58=(Ob f)   :: ITE_DROP <False> <Rest> ; == <Rest> / Ob <False> <Rest>
61A6D=Drops rest & executes stk1
61A6D=Example: :: 1 2 ' x+ COLA_EVAL <Never> ; -> 3  
61A8E=(f <True> <False>) :: COLARPITE <Never> ;
61AD8=(f) :: ITE <True> <False> <Rest> ;
61AE9=(f) :: :: 2'RCOLARPITE <Never> ; <True> <False> <Rest> ;
61B45=:: :: :: 2@REVAL <Rest1> ; <Rest2> ; <This> <Rest3> ;
61B45=Fetch & EVAL 1st object in prevprev (Doesn't advance)
61B55=Fetch & EVAL 1st object in prevprevprev (Doesn't advance)
61B72=(Ob False ->)	(True ->)
61B89=If 'R is SEMI then RDROP & (-> False) else ( -> Ob True) & advance
61C1C=allocate nibbles (2:sized object,1:#length)
61CE9=Binds n objects to same LAM (Obn .. Ob1 #n LAM ->) (1LAM is count)
61D41=(Example: 
61D41=1 2 3 :: x+ SAVESTACK x+ undo ; -> 1 5 <LASTARG> -> 1 2 3
61D41=Saves stack (Depth bound to SAVELAM to SAVELAM)
61EA7=Dumps CACHEd LAMs (NULLLAMs) (-> Ob1 .. Obn #n)
61F8F=(Example: :: 1 2 SAVESTACK + 2 * undo ; -> 1 2)
61F8F=Resumes stack saved by SAVESTACK
61FA9=DUP & IS stk1 ROM XLIB'ed entry point -> (1:Any -> 2:Any 1:T/F)
61FB6=IS stk1 ROM XLIB'ed entry point (Has XLIB number) -> (1:Any -> 1:T/F)
61FCF=If copy stk1 is base ROM XLIB'ed entry point -> set carry
62001=4ROLL 4ROLL (Ob1 Ob2 Ob3 Ob4 -> Ob3 Ob4 Ob1 Ob2)
62073=Restore registers (GP) & Overwrite level1 with T/F(carry) & cont RPL
62278=Copies stk1 (#) to A.A
622E5=Inserts $m in front of $n (2:$n 1:$m -> 1:$mn)
622EF=Internal SWAP and + (2:$n 1:$m -> 1:$mn)
62312=Appends $m to $n (2:$n 1:$m -> 1:$nm)
62376=Appends $m to $n (2:$n 1:$m -> 1:$nm)
62394=Inserts $m in front of $n (2:$n 1:$m -> 1:$mn)
623A0=Appends $m to $n (2:$n 1:$m -> 1:$nm)
62474=Recalls next in prev & stores it to LASTCKCMD
6250B=pops 2 binarys, saves pointers, substracts, divides by 2
62636=Pops #, adds to C.A, pushes result, returns to rpl
626AE=Example: :: 5skipcola 1 2 3 4 5 6 7 8 9 ; -> 6
626AE=Return and execute the sixth object in this stream
62904=(Meta Ob -> Meta&Ob)
62958=:: :: RDROPCOLA <This> <Never> ; <Never> ;
6296D=:: :: COLACOLA <Never> ; <This> <Never> ;
6296D=Return, execute next, return
62986=Return, case	(f) :: :: COLAcase <Never> ; <True> <False> ; 
629A1=Return, NOT, case  (f) :: :: COLANOTcase <Never> ; <True> <False> ;
629BC=(f f) :: ORcase <True> <False> ;   == <True> / <False>
629D0=(Ob1) :: REQcase Ob2 <True> <False> ;  == Ob1 <True> / Ob1 <False>
629E9=(Ob1) :: REQcasedrop Ob2 <True> <False> ;  == <True> / Ob1 <False>
62A02=Internal STO (2:Any 1:ID/LAM)
62A2F=DUP and RCL (1:ID/LAM -> 3:ID/LAM 2:contents 1:T / 2:ID/LAM 1:F)
62A34=Internal RCL (1:ID/LAM -> 2:contents 1:T / 1:F)
62A61=If ROMWORD & seco then RPL@ (1:seco -> ROMPTR)
62A84=(If XLIB is in built-in-not-hidden ROM then @) (1:Any)
62B0B=Internal DROP2 and False
62B1F=Decompiles rom pointer (ob --> $ TRUE / ob FALSE )
62B5B=( romptr --> "romptr" TRUE )
62B88=(1:comp -> N:Ob1...1:Obn) 
62B9C=Internal GET (2:comp 1:#n -> 1:Ob) (Nothing if out of range)
62BB0=(1:"mesg" -> 1:"mesg ")
62BD8=Recall next romp's RPL :: RESOROMP XLIBname ; -> 1:rpl or nothing
62C41=Internal OBJ-> and DUP (1:comp -> N+2:Ob1...3:Obn 2:#n 1:#n)
62C69=Internal NEWOB and SWAP
62D1D=Internal GET (2:comp 1:#i -> 2:Ob 1:Ob)
62D81=(2:% 1:% -> 2:%max 1:%min)
62D9F=If False then SWAP
62DB3=:: 1GETLAM ABND SWAP ;
62DCC=(3:#m 2:Any 1:#n -> 2:#m+n 1:Any)
62DE5=(4:#m 3:Any3 2:Any2 1:#n -> 4:#m 3:Any3 2:#m+n 1:Any2)
62E4E=#1- ONE SWAP
62E8F=Internal R->LR and SWAP (2:Any 1:% -> 2:%% 1:Any)
62EA3=Internal * and SWAP (3:Any 2:%% 1:%% -> 2:%% 1:Any)
62ECB=ROT(4)
62F07=1GETLAM SWAP
62F43=If False then SWAPDROP else DROP
62F5C=If True then SWAPDROP else DROP
62F75=Internal DROPN and DROP (1:#n)
6303D=(3:Any 2:Ob2 1:Ob1 -> 3:Any 2:T/F 1:Any)
63105=(Meta Ob -> Ob Meta)
63141=(2:[] 1:Any -> 3:[] 2:Any 1:#elements)
63169=(f) :: caseERRJMP <False> ;
6317D=If True then CARCOMP
63191=Append <CR> (1:$ -> 1:$)
631A5=Internal subtract one and ->LIST (N:Ob1...1:#n -> 1:{})
631E1=(1:comp -> N+2:comp N+1:Ob1...2:Obn 1:#n)
631F5=(2:comp 1:Any -> N+2:any N+1:Ob1...2:Obn 1:#n)
63259=SUB$ from 1 to #n-1 (2:$ 1:#n -> 1:$)
6326D=SUB$ from #n to end (2:$ 1:#n -> 1:$)
632A9=(2:%im 1:%re -> 1:C%)
632BD=Unevaluated No Operation
632D1=->PROGRAM and EVAL (N+1:Ob1...2:Obn 1:#n)
632E5=2GETLAM EVAL
632F9=DROP RDROP
63312=:: SWAPCOLA <This> <Never> ; == SWAP <This>
63326=:: XYZ>ZCOLA <This> <Never> ; == XYZ>Z <This>
6333A=(#) :: #0=?SKIP <If not zero> <Rest> ;
633B2=:: :: COLASKIP <Never> ; <Never> <Rest> ;
6347F=Internal DUP and #0 #n DO (1:#n -> 1:#n)
63498=Start LOOP through all elements (1:comp -> 1:comp)
634E3=(f) :: caseTRUE <False> ; == True / <False>
63547=(# #') :: #=casedrpfls <False> ;      ==  False / # <False>
6356A=(Ob f) :: casedrpfls <False> ;        ==  False / Ob <False> 
63583=(Ob1 Ob2 f) :: case2drpfls <False> ;  ==  False / Ob1 Ob2 <False> 
6359C=(f) :: caseFALSE <False> ;            ==  False / <False>
635C4=Internal <> (2:Any 1:Any -> 1:T/F)
635D8=Internal DUP2 and EQ (2:Any 1:Any -> 3:Any 2:Any 1:T/F)
635EC=(Ob1)   :: DUPEQ: Ob2 ;   -> 2:Ob1 1:T/F)
635F1=(Ob1)   :: EQ: Ob2 ;   -> 1:T/F
6362D=#n or #m = #0 ? (2:#n 1:#m -> 1:T/F)
636A0=(1:comp -> 2:Ob 1:True / ...2:Obn 1:False)
63704=(2:#m 1:#n -> 3:#m 2:#n 1:#m+n)
63790=INDEX@ and #- (1:#n -> 1:#n-index)
637A4=Internal SWAPOVER and #- (2:#n 1:#m -> 2:#m 1:#n-m)
637CC=Internal #- #1+
63808=Internal #+ #1-
6381C=(f) :: COLAITE <True> <False> <Never> ;
6383A=ERRORSTO and ERRJMP (1:#errornumber)
63880=:: RSWAP 'R DROP RSWAP ;
63880=Advances return stack pointer over one object
6389E=Clears a rectangular region in grob(5:grob 4:#x1 3:#y1 2:#x2 1:#y1 ->)
638B2=(Ob f) :: casedrptru <False> ;  ==  True / Ob <False>
638CB=(f) :: NOTcaseTRUE <False> ;  == True / <False>
638E4=If True then Return, else DROP and continue (:: NOTcase DROP RDROP ;)
638FD=(Meta1 Meta2 -> Meta2 meta1) (meta1 has no count)
63911=(Meta1 Meta2 -> Meta2)
639DE=Recalls 2 objects from prev (And advances) -> (2:Ob1 1:Ob2)
639FC=Recalls 1 ob from prev & pops return stack
63A15=:: ONECOLA <This> <Never> ;  ==  One <This>
63A29=Store stk1 into ''dvar' (LAM)
63A3D=Store stk1 into ''LNAME' (LAM)
63A56=Is pop stk1 stepwise deriv. ? (xDER = XLIB 2 248) (1:Any -> 1:T/F)
63B19=If pop stk1 not True, then Bad Argument Value
63B2D=If copy type(stk1) <> %, then Bad Argument Type (1:Any -> 1:Any)
63B5A=Unevaluated * (multiply)
63B6E=Unevaluated delta (stepwise derivative)
63B82=Internal / and LR->R (2:%% 1:%% -> 1:%)
63B96=Internal SB->LR (1:# -> 1:%%)
63BBE=Internal SWAP and / (2:%% 1:%% -> 1:%%)
63BD2=If True then Return, DROP and DoBadKey, else continue
63BEB=If True then Return, and DoBadKey, else continue
63C04=Get Grob width (1:Grob -> 1:#width
63CA4=(Any Ob1 Ob2) :: EQUALcasedrp <True> <False> ; == <True> / Any <False>
63CBD=If DUP#0= then DROP & return, else continue
63CD6=(Ob1 Ob2) :: jEQcase <True> <False> ;  ==  <True> / <False>
63CD6=If EQ then COLA else SKIP
63CEA=If AND then COLA else SKIP
63CFE=If EQUAL then COLA else SKIP
63D12=If #< then COLA else SKIP
63D26=If #1= then COLA else SKIP
63D3A=If #<> then COLA else SKIP
63D4E=If #2> then COLA else SKIP
63D67=If #> then COLA else SKIP
63D7B=If %0= then COLA else SKIP
63D8F=If TYPEREAL? then COLA else SKIP
63DA3=If DUPTYPEARRY? then COLA else SKIP
63DB7=If DUPTYPELIST? then COLA else SKIP
63DCB=If EditLExists? then COLA else SKIP
63DDF=If ANDNOT then COLA else SKIP
63DF3=If EQUALNOT then COLA else SKIP
63E07=If DUPTYPEIDNT? NOT then COLA else SKIP
63E1B=If DUPTYPEREAL? NOT then COLA else SKIP
63E2F=If EQ then do else SKIP
63ED9=Is userflag #n set? & ITE (1:#n)
63EED=Is systemflag #n set? & ITE (1:#n)
63F01=(Meta1 Meta2 -> ALG_Meta1Meta2&Ob) (Ob next in this instr. stream)
63F01=Example: A B + #3 C D - #3  :: top&Cr x* ; -> ALG_(A+B)*(C-D)
63F1A=(Meta1 Meta2 Meta3 -> Meta2 Meta3 Meta1 Meta1)
63F2E=(Meta1 Meta2 Meta3 -> Meta2 Meta3&Meta1)
63F42=(Meta1 Meta2 Meta3 -> Meta3 Meta1&Meta2)
63F56=Example: A B + C D - * #7 -> C D - #3 A B + #3
63F56=Splits meta object (Meta1&Meta2&<op> -> Meta2 Meta1) (<op> is dropped)
63F6A=Internal + and SWAP ($)
63F92=(Meta without last operator -> Meta1 Meta2)
63F92=Example: A B + C D - #6 -> A B + #3 C D - #3
63FA6=(Meta Ob ->)
63FCE=If DUPTYPESECO? NOT then Ob>Seco
63FE7=Internal 1 ->PROGRAM (1:Any -> 1:seco)
63FFB=Internal 2 ->PROGRAM (2:Any 1:Any -> 1:seco)
6400F=Stores zero to ISTOP
64023=Hidden recall (1:ID/LAM) -> (2:contents 1:True / 1:False)
64037=Sets Hidden dir environment for next command only
64078=Hidden store (2:Any 1:ID/LAM)
6408C=Purges hidden variable (1:ID/LAM)
640A0=Binds CONTEXT and LCONTEXT to 2 NULLLAMs
640BE=Stores HiddenDir to both CONTEXT and LCONTEXT
640CD=Stores NULLDIR as Hidden directory and recalls it (1:->DIR)
640FA=Restores CONTEXT (1LAM) and LCONTEXT (2LAM) from LAMs
64127=Returns TRUE is ob1 is embedded in or is ob2 (2:Ob2 1:Ob1 -> 1:T/F)
6416D=Returns stack depth in upSTK application
6419A=If ERROR@ is one of {<13Eh> <123h> <DFFh>} then ERRJMP
641CC=DUP and execute next object
641CC=Example: DUP4UNROLL primitive points here and next obj is 4UNROLL
64214=MC: push A.A and C.A as # (small meaning <= 2B )
64236=MC: push A.A as # (small)
64345=Example: 1 2 3 4 5 6 7 8 9 #9 #4 #8 -> 4 5 6 7 8 #5 
64345=SUB of Meta object (Meta #start #end -> Meta') (Does range check)
643BD=(meta Any #start #n #start -> meta Any #n)(meta count #n is displaced)
643BD=Drops obs from meta starting from #start+1
643BD=Example:1 2 3 4 5 6 7 8 9 #2 #6 #9 #6 -> 1 2 3 4 5 6 #2 #6
643EF=Is ob equal to any element of comp? (2:Ob 1:comp -> 2:Ob 1:T / 1:F)
643F9=         Finds ID_X and returns TRUE
643F9=Example: :: :: 'ID_X GOTO matchob?Lp ; ID_Y ID_X ID_Z ;
643F9=Is ob equal to one of returnstack composite? (2:Ob -> 2:Ob 1:T | 1:F)
64426=(3:comp 2:Ob 1:pred -> 1:#n / #0 if not found)
64426=Example: To find first ob less than five: :: {list} %5 ' %< POSCOMP ;
64426=Match ob to composite with predicate
6443A=(3:Ob 2:pred 1:#index -> 1:#n / #0 if not found)
6443A=Do >R to match to stack composite
6448A=Example: {list} #5 #=POSCOMP searches from #5 in the list
644A3=Internal POS (2:comp 1:Any -> 1:#i / 1:#0 if not found)
644BC=Internal POS (2:Ob 1:Comp -> 1:#n | #0)
644D0=(2:comp 1:Matchingprg -> 2:Ob 1:True / 1:False)
644D0=:: ' Find1stT.1 ' :: ' Find1st.1 EQUAL ; Find1stTrue ;
644D0=Example: To find first 0 :: {list} ' :: %0 EQUAL ; Find1stTrue ;
644D0=Example: To see if Find1stT.1 calls itself:
644D0=Finds matching object in composite
644EE=Example: Find1stTrue calls like this: :: SWAP >R COLA Find1stTrue.1 ;
644EE=Matches to composite in return stack (1:prg -> 2:Ob 1:T / 1:F)
6452F=(3:Ob 2:matchingprg 1:comp -> 2:Nextob 1:True / 1:False)
6452F=Does matching 2 at a time, if first matches, gives second
64548=(2:Ob 1:matchprg -> 2:Ob 1:True / 3:Ob 2:Lastob 1:False)
64548=Does matching to composite in return stack 2 at a time
64548=If first matches, gives second else gives last
64593=:: ' EQ SWAP LookUp ;
645B1=Internal POS w/start (3:$ 2:$/Char 1:#start -> 1:#pos)
645BD=Internal POS w/limit (3:$ 2:$/Char 1:#limit -> #pos)
647A2=Internal DTAG level 2 object
647BB=Tags objects on stack (...2:Ob2 1:{"tagn"..."tag2"})
6480B=(2:comp 1:#offset -> 4:comp 3:#nextoffset 2:ob 1:True /2:comp 1:False)
6480B=Return ob with offset (GETI !!) (Use starting offset #5)
653C4=Reference to message table for library 00B (XLIB 11) (726A5)
6594E=Internal POKE (2:HXS_data 1:HXS_address ->)
6595A=HXS_target is overwritten for it's length
6595A=Internal PEEK (2:HXS_target 1:HXS_address -> 1:HXS)
6595A=WP restriction, thus user level hxs is maximum (16 nibbles)
659DE=Draws symbolic to HBUFF (1:sym) (Saves current application 1st)
65A29=A NOP program ( :: NOP ; )
65A38=A NOP program ( :: NOP ; )
65D1A=Pops #, skips until null marker, then fetches Meta ob address to D1
65E2D=Takes # from DAT1, returns address past meta in C.A (D1 same)
65E48=Skips stack levels until past EqwrNullMarker{}
66118=(3:#a 2:#b 3:#c -> 4:#a 3:#b 2:#a-1 1:#c+1)
66D06=blanked cursor (Graphic 4 x 6)
66D26=big Sigma (Graphic 16 x 18)
66D82=?? two vertical dots (Graphic 3 x 8)
66DA6=?? two vertical dots (Graphic 3 x 6)
66DC6=small close paren (Graphic 6 x 6)
66DE6=small open paren (Graphic 6 x 6)
66E8D=Graphic template (Graphic 0 x 0)
66EA5=Equation Writer cursor (big) (Graphic 6 x 10)
66ECD=Equation Writer cursor (mediam) (Graphic 6 x 8)
66EF1=Equation Writer cursor (small) (Graphic 4 x 6)
66F11=blanked cursor (Graphic 6 x 8)
66F35=blanked cursor (Graphic 6 x 10)
66F5D=inverse arrow up (Graphic 7 x 5)
66F7D=inverse arrow up (Graphic 5 x 4)
68159=(Meta #n -> #n-1-size(Meta) )
685C9=(Meta ... Meta #m --> Meta ... Meta #n)
685C9=Calculates location of next Meta
685C9=Use start value #1 for #m, then PICK will give len of Meta etc)
68B7B=Enter Equation Writer with no equation
68BDA=Enter Equation Writer (1:ALG/UM -> 2:ALG/UM 1:T <ENTER> | 1:F <ATTN>)
68C6B=Executed when all LAMs are bound etc
6910C=(2:$ 1:$ -> 1:$) (2:"2" 1:"1" -> 1:"212")
69454={ DoENTERkey NOP EVAL EVAL ->NUM ->NUM }
699C5=Draws symbolic to HBUFF, (Called by Symb>HBuff) (1:sym)
699ED=(2:$ 1:TRUE (??) ) Binds LAMs etc, stack 2 is the algebraic as $
6A0F2=Try above 2 with for example SQRT(X), X/2 on the stack
6AAD1=Replaces RATIO with / in Meta (Meta Any -> Meta' Any)
6CFDC=Removes possible 's from start & end (1:$ -> 1:$)
6D28B=#- with no wraparound (no 'negative' results)
6D327=Takes SUB$ from start to 2nd last char (1:$ -> 1:$)
7000A=Reason of warm start
7005F=4 nibbles for temporary CRC save
70070=F or 0
70072=Time initialised by ON-D SIN
7008C=22 chars for system test messages (Hidden ROM routines)
700E4=3 nibbles to store ram base + size (base*256+size)
700E7=Return address used by hidden ROM routines (+RSTK save)
701FC=RS-232 receive buffer (256 bytes) in RAM (data added by interrupts)
70200=Time Init (RAM)
70401=3[XH ? RH RF]0           RF=XOFF transmitted
70401=RH:RECV handshake used , XH=XMIT handshaking recognized 
70402=3[RF ? ? ?]0  RF set when buffer is almost filled, but XMIT is busy
7042C=[Present? Writeable? Merged? ?]
7042D=Negated, ie C0000 means 40000
7045C=Temprary save for A.A used by UnCover4K
70461=3 nibbles for saved status register (UnCover4K)
70475=Saved D1, RTSK, B.A (MLGOTO:) (+ F??)
70489=#3A nibbles for interrupt storage are for registers
704C3=3 nibbles for output register shadow
704C6=Address of 1st displayed grob line
704CB=End address of display grob
704CB=RAM size ??
704D6=Current clock speed (5 nibbles for Hz??)
704DB=Somehow related to HOME directory. (Base address for RAM? F or 7?)
704DC=0 = keyboard enabled?
704DD=13 nibbles for a single keypress from a ScanKeys call
704EA=34 nibbles
7050C=Storage for a key popped from the keybuffer
70513=3 nibs for PICT display line offset (Normally 000) ????????
7051B=2 nibs for window height
7051D=Temporary save for RSTK for ON_/ key (6 levels)
7053B=11 nibbles for R2.A and R1.A save for ON_/ (Mid nibble scratch?)
70551=pointer to menu display
70556=ptr to Stack Display
7055B=ptr to current display
70560=Pointer to PICT
70565=ptr to PICT (Grob)
7056F=heap pointer
70574=saved B (return stack pointer)
70579=saved D1 (RPL stack pointer)
7057E=bottom (start) of stack (grows down)
70583=local var ptr addr (Counter in @@)
70588=Pointer to current loop information
7058D=Menu key program locations??
70592=ptr to HOME directory
70597=end HOME directory (ptr to start of port0)
7059C=ptr to Current Directory
705A1=ptr to Temp Directory
705A6=ptr to User Keys
705AB=ptr to Alarm List
705B0=saved D0 (RPL thread pointer)
705B5=temporary save A.A
705BA=Arguments saved by CK<n>(NOLASTWD) (5 nibbles each)
705D3=Memory reserved for handling memory out situations (HXS B8 ss...)
705D9=ROM: ML Version Output
705DD=Address of last command ($ for user commands ??) (00000 = none) 
705F6=Address of kermit error message
70600=Storage for user error messages
7065A=Last command saved by CK<N> (5 nibbles for address of program)
7066E=saved D (free stack space)
70673=Last Error Code
7068F=16 nibbles not used  (??)
7069F=Stack Size saved by CK<n>(NOLASTWD) (5 nibbles for @DSKBOT-D1)
706A4=Random Seed
706C2=HI [LowBat(P2) LowBat(P1) LowBat(S) OK] LOW
706C3=(Busy = 80, alpha = 40, right = 20, left = 10)
706C5=-01 [Princip. Sol,  Symb. Const,    Num Results,   Not Used     ] -04
706C6=-05 [Wordsize1,     Wordsize 2,     Wordsize4,     Wordsize 8   ] -08
706C7=-09 [Wordsize16,    Wordsize32,     Bin/Hex,       Oct/Hex      ] -12
706C8=-13 [Not Used,      Not Used,       Polar          Spherical    ] -16
706C9=-17 [Radians,       Grads,          2D Complex     Underflow err] -20
706CA=-21 [Overflow err,  Infinite Res,   Neg underflow, Pos underflow] -24
706CB=-25 [Overflow,      Infinite        Not Used,      Not Used     ] -28
706CC=-29 [Not Used,      Param. plot,    Curvefill off, XOR cursor   ] -32
706CD=-33 [I/O to IR,     Print to serial,Binary I/O,    Recv overwrite] -36
706CE=-37 [Double-space,  Auto Linefeed,  I/O msg off,   Clock display] -40
706CF=-41 [24/12 hours,   European clock, RPT no repeat, Alarms saved ] -44
706D0=-45 [DispRound1,    DispRound2,     DispRound4,    DispRound8   ] -48
706D1=-49 [FIX/ENG,       SCI/ENG,        Comma fraction,Single-line  ] -52
706D2=-53 [Parentheses,   Not Used,       No LastArgs,   Beep off     ] -56
706D3=-57 [Alrm beep off, Verbose msg off,Fast Catalog,  Alpha lock   ] -60
706D4=-61 [User lock,     User Active,    Vectored,      Index wrap   ] -64
706D5=RPL System Flags 1 thru 4
706D6=RPL System Flags 5 thru 8
706D7=RPL System Flags 9 thru 12
706D8=RPL System Flags 13 thru 16
706D9=RPL System Flags 17 thru 20
706DA=RPL System Flags 21 thru 24
706DB=RPL System Flags 25 thru 28
706DC=RPL System Flags 29 thru 32
706DD=RPL System Flags 33 thru 36
706DE=RPL System Flags 37 thru 40
706DF=RPL System Flags 41 thru 44
706E0=RPL System Flags 45 thru 48
706E1=RPL System Flags 49 thru 52
706E2=RPL System Flags 53 thru 56
706E3=RPL System Flags 57 thru 60
706E4=RPL System Flags 61 thru 64
706E5=Unused 2 nibbles???
706E7=How many chars scrolled off screen +1 ?
706EC=Number of edit lines (total) (EDITPARTS gives one bigger)
706F6=Number of the first line displayed
706FD=Number of argument pointers saved by CK<n> in ArgPntrs (1 nibble)
706FF=Saved Last Error code (#)
70704=Position (total) of the cursor in the command-line
70709=Position (line) of the cursor in the command-line
7070E=Position of cursor in screen
70713=GROB for displaying lines of stack. Enough mem for 1 medium char
7073B=Cursor location in graph
70740=Cursor location in graph
7074E=Cursor blink counter
7074F=One nibble for indentation counter
70750=Saved RSTK during garbage collection
70770=Max string compile length (2 nibs)
70793=Delayed alpha lock indicator
70794=PRG mode indicator
7079D=1 if Clock is on (?)
707A6=Saved status after OPENIO
707C9=Menu Offset, 5 nibbles
707D3=Last Menu Offset, 5 nibbles
707D9=Known Libraries (count:3 lib#:3 adr:5 lib#:3 adr:5,...)
72000=Message table for library 000
737EC=1 nibble for size
737EC=2 nibble offset to next unit (00 = end of units)
737EC=2 nibbles for size + nibbles for quantity string
737EC=Else 2 nibble exponent + sized mantissa (size from above)
737EC=If size = 0, 5 nibble address to %% number
737EC=unit in ascii
737EC=For each unit:
737EC=	8 4-nibble offsets for each lenght of $unit
737EC=Contains unit masks and factors for all internal units
737EC=Structure:
74228=For each prefix char the associated exponent
7427C=Hash table for library 700 (XLIB 1792)
7448A=Hash table for library 002 (XLIB 2)
76CC5:comb(-x,y)
76E27=x=xpon(x)
76E2D:x<>0?
76E30:Yes - continue
76E32:No - return - inf
76E35:- sign
76E3A:xpon(-x)
76ECE:ln(-x) --> unf
76EE5:x<>0?
76EE8:Yes - continue
76EEA:No set infinite result
76EEC:ln(0)
76EF0:-inf
76EFA:x<0?
76EFD:Yes - set unf result
7709F=x=exp(x)
7709F=Uses: R0 ST10 (sEXPNEG) ST11 (sEXPM)
7709F:Clr [XM,SB]
770A2:Clr EXPM
770A9=x=expm(x)
770A9=Uses: R0 ST10 (sEXPNEG) ST11 (sEXPM)
770AC:Set EXPM
770B2:Init result
770B8:Set negative x
770BB:x < 0?
770BE:Yes - cont
770C0:Clr negative x
770C3:Clr x sign
770C9:C.A = exp
770CB:C.S = 0 (sign)
770CE:exp*2
770D0:x exp > 0
770D3:x exp < 0 - C.A = exp
770D5:x normalized?
770D8:Yes - continue
770DA:No - normalize
770DF:Recollect exp info
770F9:x exp > 0, continue
7746C:nroot(1,0)=unf
774F7:0^0
77501:0^x, x>=0 ?
77504:Yes - continue
77506:No - set inf for 0^(-x)
77517:y<>0?
7751A:Yes - continue
7751C:Assume y>=0?
77524:Set y<0
77527:x<>0?
7752A:Yes - cont
7752C:y>=0?
7752F:Yes - return 0
77533:Set 0^(-x) = nroot(0,-y)
77540:Is x=1?
77544:No
77547:Yes - set nroot(1,0)
7754B:-1 < x < 1?
7754D:Yes - check y sign
77553:set nroot(-x,+y)
77567:nroot(-x,+y)
77751:asin(x>1) etc
77F9D:First digit zero?
77FA0:Yes - mantissa zero, return
77FA4:num *= 100
77FA6:Get fractional part
77FAD:No fractional part?
77FB0:None, exit
77FB9:min.sec -= min.sec*.4
77FC3:min.sec -= min.sec*.4
77FCB:sec -= sec*.4
77FD1:num /= 100
77FD3:Normalize float
77FDA:C.WP = fraction
77FDD:frac /= 10
77FE3:frac *= 4
77FE6:frac -= (frac/10)*4
77FEC:C.X = low digits
77FEF:Shift sgn digit to B.S
77FF2:Zero sgn?
77FF5:Yes - set carry
77FF7:Shift back
77FFD:Clear XS
78000:Add 00000000000000xx to num
78003:Clear low digits
78008:Add 0000000000000xxx to num
7800B:Clear low digits
7A32B=Small font, 1 nibble for x-size then 5 rows of 2 bytes for grob data
7A689=Characater array. Used for displaying chars >= A0
7AA5D=DoMenuKey1NS	DoMenuKey1LS	DoMenuKey1RS	CHR_A,CHR_a,chr_alpha
7AA94=DoMenuKey2NS	DoMenuKey2LS	DoMenuKey2RS	CHR_B,CHR_b,chr_beta
7AACB=DoMenuKey3NS	DoMenuKey3LS	DoMenuKey3RS	CHR_C,CHR_c,chr_Delta
7AB02=DoMenuKey4NS	DoMenuKey4LS	DoMenuKey4RS	CHR_D,CHR_d,chr_delta
7AB39=DoMenuKey5NS	DoMenuKey5LS	DoMenuKey5RS	CHR_E,CHR_e,chr_epsilon
7AB70=DoMenuKey6NS	DoMenuKey6LS	DoMenuKey6RS	CHR_F,CHR_f,chr_theta
7ABA7=DoMathMenu,DoPrintMenu,xPR1,CHR_G,CHR_g,chr_gamma
7ABDE=DoPrgmMenu,DoIOMenu,xSERVER,CHR_H,CHR_h,chr_eta
7AC15=DoCstMenu,DoModeMenu,DoCustomMenu,CHR_I,CHR_i,chr_inf
7AC4C=DoVarMenu,DoMemoryMenu,DoAritMenu,CHR_J,CHR_j,chr_|
7AC83=DoUpKey,DoLibraryMenu,DoUpKeyRS,CHR_K,CHR_k,chr_up
7ACBA=DoNextRow,DoPrevRow,DoFirstRow,CHR_L,CHR_l,chr_lamda
7ACF1=Do'Key,xUPDIR,xHOME,CHR_M,CHR_m,chr_'
7AD28=DoStoKey,xDEFINE,xRCL,CHR_N,CHR_n,chr_mu
7AD5F=xEVAL,x>Q,x>NUM,CHR_O,CHR_o,chr_Omega
7AD96=DoLeftKey,xGRAPH,DoLeftKeyRS,CHR_P,CHR_p,chr_<-
7ADCD=DoDownKey,DoReviewKey,DoDownKeyRS,CHR_Q,CHR_q,chr_down
7AE04=DoRightKey,xSWAP,DoRightKeyRS,CHR_R,CHR_r,chr_rho
7AE3B=xSIN,xASIN,xDER,CHR_S,CHR_s,chr_sigma
7AE72=xCOS,xACOS,xINTEGRAL,CHR_T,CHR_t,chr_tau
7AEA9=xTAN,xATAN,xSUM,CHR_U,CHR_u,chr_%
7AEE0=xSQRT,xSQ,xrpnXROOT,CHR_V,CHR_v,chr_~
7AF17=x^,xALOG,xLOG,CHR_W,CHR_w,chr_omega
7AF4E=xINV,xEXP,xLN,CHR_X,CHR_x,chr_xbar
7AF85=DoEnterKey,DoEnterKeyLS,DoEnterKeyRS,DoEnterKey,chr_&,chr_@
7AFBC=DoNegKey,DoEditKey,DoVisitKey,CHR_Y,CHR_y,chr_+/-
7AFF3=DoEexKey,Do2Dkey,Do3Dkey,CHR_Z,CHR_z,chr_Pi
7B02A=DoDelKey,DoPurgeKey,DoClvarKey,DoDelKey,chr_!,chr_inv_!
7B061=DoBackspcKey,xDROP,xCLEAR,DoBackspcKey,CHR_?,CHR_inv_?
7B098=1A/LockA,TogUser,TogEntry,LockA/0A,TogLowCase,TogIns
7B0CF=CHR_7,DoSolveMenu,DoSolvrMenu,CHR_7,DoInv7Key,DoInv7KeyRS
7B106=CHR_8,DoPlotMenu,DoPlotrMenu,CHR_8,DoInv8Key,DoInv8KeyRS
7B13D=CHR_9,DoAlgebraMenu,DoCatKeyCHR_9,DoInv9Key,DoInv9KeyRS
7B174=x/,Do()Key,Do#Key,CHR_/,Do()Key,CHR_#
7B1AB=DoLSkey,DoNSkey,DoLSkey,DoLSKeyA,DoNSKeyA,DoLSKeyA
7B1E2=CHR_4,DoTimeMenu,DoTimeCat,CHR_4,CHR_$,chr_cent
7B219=CHR_5,DoStatMenu,DoStatMenuRS,CHR_5,chr_pound,chr_yen
7B250=CHR_6,DoUnitsMenu,DoUnitCmdMenu,CHR_6,chr_currency,chr_degree
7B287=x*,Do[]Key,Do_Key,CHR_*,Do[]Key,CHR_UndScore
7B2BE=DoRSKey,DoRSKey,DoNSKey,DoRSKeyA,DoRSKeyA,DoNSKeyA
7B2F5=CHR_1,DoRadKey,DoPolarKey,CHR_1,$_==,chr_<>
7B32C=CHR_2,DoLastStk,xLASTARG,CHR_2,CHR_<,CHR_>
7B363=CHR_3,DoLastCmd,DoLastMenu,CHR_3,CHR_<=,CHR_>=
7B39A=x-,Do<<>>Key,Do""Key,CHR_-,Do<<>>KeyLS,CHR_DblQuote
7B3D1=TurnOnKey,xCONT,TurnOffKey,TurnOnKey,xCONT,TurnOffKey
7B408=CHR_0,x=,xALG->,CHR_0,CHR_=,CHR_->
7B43F=Do.Key , Do,Key , DoNewlineKeyey, Do.Key , Do,Key , DoNewlineKey
7B476=CHR_Space,xPI,CHR_Angle,CHR_Space,CHR_Pi,CHR_Angle
7B4AD=x+,Do{}Key,Do::Key,CHR_+,Do{}Key,CHR_:
7B4E4=Array of binary arrays ( [KDefs11 ... KDefs95] )
7B65B=(Meta1 Meta2 Meta3 Ob -> Meta3&Ob Meta1&Meta2 x+)
7B679=(Meta1 Meta2 Meta3 Ob -> Meta2&Ob Meta3&Meta1 x-)
7B6C9=(Meta1 Meta2 Meta3 Ob -> Meta3&Ob Meta1&Meta2)
7B6DD=(Meta1 Meta2 Meta3 Ob -> Meta2&Ob Meta1&Meta3)
7B728=(Meta1 Meta2 Meta3 Ob -> Meta3&Ob Meta1&Meta2 x*)
7B746=(Meta1 Meta2 Meta3 Ob -> Meta2&Ob Meta3&Meta1 x/)
7DBBF={ <-T T-> <-M M-> AF <--> (<- ->) <-A A-> (()) -() }
7DC05={ <-T T-> <-M M-> <-D ->D (<- ->) <-A A-> <--> (()) -() 1/() L() }
7DC5A={ 1/() E() <-D D-> <-A ->A }
7DC82={ 1/() E^ ->TRG D-> }
7DCA0={ -() L* NullMenuKey D-> }
7DCBE={ ->() }
7DCCD={ <-T ->T }
7DCE1={ ->() }
7DCF0={ ->DEF TRG* }
7DD04={ ->DEF }
7E128=!!!!!! Addresses changed in rev J until 7FF64 !!!!!!!
7F663=( Meta --> Meta )  If Meta contains IDs functions are not EVALed
7F6D1=(1:Ob) #port is next in this stream
7FA65=(2:{} 1:%port)
7FB23=RCLDIRLIBS (1:DIR -> $NAME %LIBNUM #ADDR ... #n)
7FE06=(2:ID/LAM/#libnum 1:#-1,#0,#1 or #2)
7FE48=(1:ID/LAM/#libnum) (Looks in every port)
7FEE1=Removes libs from protected ports from the RCLDIRLIBS output
7FFF0="HP48-E"
